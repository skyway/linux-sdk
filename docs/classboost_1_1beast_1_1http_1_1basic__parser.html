<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
<head>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
        'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
        })(window,document,'script','dataLayer','GTM-NN5JX4B');</script>
    <!-- End Google Tag Manager -->
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=11"/>
    <meta name="generator" content="Doxygen 1.9.8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>SkyWay Linux SDK</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="resize.js"></script>
    <script type="text/javascript" src="navtreedata.js"></script>
    <script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="search/searchdata.js"></script>
    <script type="text/javascript" src="search/search.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NN5JX4B"
        height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
            <tbody>
                <tr id="projectrow">
                    <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
                    <td id="projectalign">
                        <div id="projectname">SkyWay Linux SDK
                        </div>
                    </td>
                </tr>
            </tbody>
        </table>
    </div><!-- 構築: Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'検索');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','検索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classboost_1_1beast_1_1http_1_1basic__parser.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">公開型</a> &#124;
<a href="#pub-methods">公開メンバ関数</a> &#124;
<a href="#pro-methods">限定公開メンバ関数</a> &#124;
<a href="#friends">フレンド</a> &#124;
<a href="classboost_1_1beast_1_1http_1_1basic__parser-members.html">全メンバ一覧</a>  </div>
  <div class="headertitle">
<div class="title">boost::beast::http::basic_parser&lt; isRequest &gt; クラステンプレート<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="basic__parser_8hpp_source.html">basic_parser.hpp</a>&gt;</code></p>
<div class="dynheader">
boost::beast::http::basic_parser&lt; isRequest &gt; の継承関係図</div>
<div class="dyncontent">
 <div class="center">
  <img src="classboost_1_1beast_1_1http_1_1basic__parser.png" usemap="#boost::beast::http::basic_5Fparser_3C_20isRequest_20_3E_map" alt=""/>
  <map id="boost::beast::http::basic_5Fparser_3C_20isRequest_20_3E_map" name="boost::beast::http::basic_5Fparser_3C_20isRequest_20_3E_map">
<area href="structboost_1_1beast_1_1http_1_1detail_1_1basic__parser__base.html" alt="boost::beast::http::detail::basic_parser_base" shape="rect" coords="0,0,261,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
公開型</h2></td></tr>
<tr class="memitem:a07cdae5d96411538e3a18a7a69427fdb"><td class="memItemLeft" align="right" valign="top"><a id="a07cdae5d96411538e3a18a7a69427fdb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a07cdae5d96411538e3a18a7a69427fdb">is_request</a> = std::integral_constant&lt; bool, isRequest &gt;</td></tr>
<tr class="memdesc:a07cdae5d96411538e3a18a7a69427fdb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>true</code> if this parser parses requests, <code>false</code> for responses. <br /></td></tr>
<tr class="separator:a07cdae5d96411538e3a18a7a69427fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
公開メンバ関数</h2></td></tr>
<tr class="memitem:afddc7ef74ac165f078b63986f88c87e8"><td class="memItemLeft" align="right" valign="top"><a id="afddc7ef74ac165f078b63986f88c87e8"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#afddc7ef74ac165f078b63986f88c87e8">~basic_parser</a> ()=default</td></tr>
<tr class="memdesc:afddc7ef74ac165f078b63986f88c87e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor <br /></td></tr>
<tr class="separator:afddc7ef74ac165f078b63986f88c87e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae09dd9061a6306dc6d61e916d07f2cb"><td class="memItemLeft" align="right" valign="top"><a id="aae09dd9061a6306dc6d61e916d07f2cb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#aae09dd9061a6306dc6d61e916d07f2cb">basic_parser</a> (<a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">basic_parser</a> const &amp;)=delete</td></tr>
<tr class="memdesc:aae09dd9061a6306dc6d61e916d07f2cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor <br /></td></tr>
<tr class="separator:aae09dd9061a6306dc6d61e916d07f2cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc39e96d1eba1057803c513f00e09a88"><td class="memItemLeft" align="right" valign="top"><a id="abc39e96d1eba1057803c513f00e09a88"></a>
<a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">basic_parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#abc39e96d1eba1057803c513f00e09a88">operator=</a> (<a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">basic_parser</a> const &amp;)=delete</td></tr>
<tr class="memdesc:abc39e96d1eba1057803c513f00e09a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment <br /></td></tr>
<tr class="separator:abc39e96d1eba1057803c513f00e09a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dea57b7580e58a2c3b35f7e16e95758"><td class="memItemLeft" align="right" valign="top"><a id="a6dea57b7580e58a2c3b35f7e16e95758"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a6dea57b7580e58a2c3b35f7e16e95758">got_some</a> () const</td></tr>
<tr class="memdesc:a6dea57b7580e58a2c3b35f7e16e95758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the parser has received at least one byte of input. <br /></td></tr>
<tr class="separator:a6dea57b7580e58a2c3b35f7e16e95758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370a556057bd1e542f2e54e843dbac1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a370a556057bd1e542f2e54e843dbac1d">is_done</a> () const</td></tr>
<tr class="separator:a370a556057bd1e542f2e54e843dbac1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08016379a9858456c069333fd9c3ad55"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a08016379a9858456c069333fd9c3ad55">is_header_done</a> () const</td></tr>
<tr class="separator:a08016379a9858456c069333fd9c3ad55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa638fcd0bab91215154625f0f5b9a345"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#aa638fcd0bab91215154625f0f5b9a345">upgrade</a> () const</td></tr>
<tr class="separator:aa638fcd0bab91215154625f0f5b9a345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ef707ae9e6564a1137336a75962bf7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a13ef707ae9e6564a1137336a75962bf7">chunked</a> () const</td></tr>
<tr class="separator:a13ef707ae9e6564a1137336a75962bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526185ddd60ccb4bfb7f50b2ff7bbb59"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a526185ddd60ccb4bfb7f50b2ff7bbb59">keep_alive</a> () const</td></tr>
<tr class="separator:a526185ddd60ccb4bfb7f50b2ff7bbb59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be5a827eed5160aeb11dc4b8d1443e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1optional.html">boost::optional</a>&lt; std::uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a3be5a827eed5160aeb11dc4b8d1443e4">content_length</a> () const</td></tr>
<tr class="separator:a3be5a827eed5160aeb11dc4b8d1443e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47b83affaed66cc87150431b7604f57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1optional.html">boost::optional</a>&lt; std::uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#ab47b83affaed66cc87150431b7604f57">content_length_remaining</a> () const</td></tr>
<tr class="separator:ab47b83affaed66cc87150431b7604f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285c1e3e9501f5aa80e0e7b7526642a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a285c1e3e9501f5aa80e0e7b7526642a9">need_eof</a> () const</td></tr>
<tr class="separator:a285c1e3e9501f5aa80e0e7b7526642a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16820f60fb34f319a1e134410aaeacc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#aa16820f60fb34f319a1e134410aaeacc">body_limit</a> (<a class="el" href="classboost_1_1optional.html">boost::optional</a>&lt; std::uint64_t &gt; v)</td></tr>
<tr class="separator:aa16820f60fb34f319a1e134410aaeacc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe943a02c95d4bf1271d98d701addfd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#afe943a02c95d4bf1271d98d701addfd3">header_limit</a> (std::uint32_t v)</td></tr>
<tr class="separator:afe943a02c95d4bf1271d98d701addfd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7131d08a701e9769caa3fe0947a9823b"><td class="memItemLeft" align="right" valign="top"><a id="a7131d08a701e9769caa3fe0947a9823b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a7131d08a701e9769caa3fe0947a9823b">eager</a> () const</td></tr>
<tr class="memdesc:a7131d08a701e9769caa3fe0947a9823b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the eager parse option is set. <br /></td></tr>
<tr class="separator:a7131d08a701e9769caa3fe0947a9823b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf8eb23a75eb6c47a30d1b26b65c733"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a9bf8eb23a75eb6c47a30d1b26b65c733">eager</a> (bool v)</td></tr>
<tr class="separator:a9bf8eb23a75eb6c47a30d1b26b65c733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a856938912bf561834c965481bcb69"><td class="memItemLeft" align="right" valign="top"><a id="a04a856938912bf561834c965481bcb69"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a04a856938912bf561834c965481bcb69">skip</a> () const</td></tr>
<tr class="memdesc:a04a856938912bf561834c965481bcb69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the skip parse option is set. <br /></td></tr>
<tr class="separator:a04a856938912bf561834c965481bcb69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af4582d87275d76a8d694e88f372ccf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a5af4582d87275d76a8d694e88f372ccf">skip</a> (bool v)</td></tr>
<tr class="separator:a5af4582d87275d76a8d694e88f372ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac128c3885a041add27097754304808f4"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence &gt; </td></tr>
<tr class="memitem:ac128c3885a041add27097754304808f4"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#ac128c3885a041add27097754304808f4">put</a> (ConstBufferSequence const &amp;buffers, <a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;ec)</td></tr>
<tr class="separator:ac128c3885a041add27097754304808f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b7b64ea2620919197d66d13ae3c1e5"><td class="memItemLeft" align="right" valign="top"><a id="ac7b7b64ea2620919197d66d13ae3c1e5"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>put</b> (<a class="el" href="classboost_1_1asio_1_1const__buffer.html">net::const_buffer</a> buffer, <a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;ec)</td></tr>
<tr class="separator:ac7b7b64ea2620919197d66d13ae3c1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2fbbb5513978d2aa09d6d4c7ec93f2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#af2fbbb5513978d2aa09d6d4c7ec93f2b">put_eof</a> (<a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;ec)</td></tr>
<tr class="separator:af2fbbb5513978d2aa09d6d4c7ec93f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
限定公開メンバ関数</h2></td></tr>
<tr class="memitem:a8506b7b4f249d932408bc8a4bb63b995"><td class="memItemLeft" align="right" valign="top"><a id="a8506b7b4f249d932408bc8a4bb63b995"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a8506b7b4f249d932408bc8a4bb63b995">basic_parser</a> ()=default</td></tr>
<tr class="memdesc:a8506b7b4f249d932408bc8a4bb63b995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor <br /></td></tr>
<tr class="separator:a8506b7b4f249d932408bc8a4bb63b995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297985f4259daf7d71c93dee21405be8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a297985f4259daf7d71c93dee21405be8">basic_parser</a> (<a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">basic_parser</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a297985f4259daf7d71c93dee21405be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bdd4c0345447fe61212e08a42244432"><td class="memItemLeft" align="right" valign="top"><a id="a9bdd4c0345447fe61212e08a42244432"></a>
<a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">basic_parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a9bdd4c0345447fe61212e08a42244432">operator=</a> (<a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">basic_parser</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:a9bdd4c0345447fe61212e08a42244432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment <br /></td></tr>
<tr class="separator:a9bdd4c0345447fe61212e08a42244432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2fb672c49d4c98b7cf19887f3dd6c4a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#ab2fb672c49d4c98b7cf19887f3dd6c4a">on_request_impl</a> (verb method, <a class="el" href="classboost_1_1basic__string__view.html">string_view</a> method_str, <a class="el" href="classboost_1_1basic__string__view.html">string_view</a> target, int version, <a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;ec)=0</td></tr>
<tr class="separator:ab2fb672c49d4c98b7cf19887f3dd6c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b2c98e4b770d5807b99242a31b1091"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#ad5b2c98e4b770d5807b99242a31b1091">on_response_impl</a> (int code, <a class="el" href="classboost_1_1basic__string__view.html">string_view</a> reason, int version, <a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;ec)=0</td></tr>
<tr class="separator:ad5b2c98e4b770d5807b99242a31b1091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b943ee89dd9797be7d9f58a759c408"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a96b943ee89dd9797be7d9f58a759c408">on_field_impl</a> (field name, <a class="el" href="classboost_1_1basic__string__view.html">string_view</a> name_string, <a class="el" href="classboost_1_1basic__string__view.html">string_view</a> value, <a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;ec)=0</td></tr>
<tr class="separator:a96b943ee89dd9797be7d9f58a759c408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88533b98e8d396cc903444a7618de0fe"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a88533b98e8d396cc903444a7618de0fe">on_header_impl</a> (<a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;ec)=0</td></tr>
<tr class="separator:a88533b98e8d396cc903444a7618de0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3cc43dade8dc2e5fef1887ea9d488e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#aff3cc43dade8dc2e5fef1887ea9d488e">on_body_init_impl</a> (<a class="el" href="classboost_1_1optional.html">boost::optional</a>&lt; std::uint64_t &gt; const &amp;<a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a3be5a827eed5160aeb11dc4b8d1443e4">content_length</a>, <a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;ec)=0</td></tr>
<tr class="separator:aff3cc43dade8dc2e5fef1887ea9d488e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d14e005f550e726c66380a4ba910b1d"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a7d14e005f550e726c66380a4ba910b1d">on_body_impl</a> (<a class="el" href="classboost_1_1basic__string__view.html">string_view</a> body, <a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;ec)=0</td></tr>
<tr class="separator:a7d14e005f550e726c66380a4ba910b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0d6b7c1ed8996dd8e6bf1bd0db989e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a9c0d6b7c1ed8996dd8e6bf1bd0db989e">on_chunk_header_impl</a> (std::uint64_t size, <a class="el" href="classboost_1_1basic__string__view.html">string_view</a> extensions, <a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;ec)=0</td></tr>
<tr class="separator:a9c0d6b7c1ed8996dd8e6bf1bd0db989e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06953676af09d66f0623a81dc533110f"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a06953676af09d66f0623a81dc533110f">on_chunk_body_impl</a> (std::uint64_t remain, <a class="el" href="classboost_1_1basic__string__view.html">string_view</a> body, <a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;ec)=0</td></tr>
<tr class="separator:a06953676af09d66f0623a81dc533110f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad541cd20c1303bec016d5efc69af2d32"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#ad541cd20c1303bec016d5efc69af2d32">on_finish_impl</a> (<a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;ec)=0</td></tr>
<tr class="separator:ad541cd20c1303bec016d5efc69af2d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
フレンド</h2></td></tr>
<tr class="memitem:ac53d707595e73424c366de0b5238a80b"><td class="memItemLeft" align="right" valign="top"><a id="ac53d707595e73424c366de0b5238a80b"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>basic_parser_test</b></td></tr>
<tr class="separator:ac53d707595e73424c366de0b5238a80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">詳解</h2>
<div class="textblock"><h3>template&lt;bool isRequest&gt;<br />
class boost::beast::http::basic_parser&lt; isRequest &gt;</h3>

<p>A parser for decoding HTTP/1 wire format messages.</p>
<p>This parser is designed to efficiently parse messages in the HTTP/1 wire format. It allocates no memory when input is presented as a single contiguous buffer, and uses minimal state. It will handle chunked encoding and it understands the semantics of the Connection, Content-Length, and Upgrade fields. The parser is optimized for the case where the input buffer sequence consists of a single contiguous buffer. The <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">beast::basic_flat_buffer</a> class is provided, which guarantees that the input sequence of the stream buffer will be represented by exactly one contiguous buffer. To ensure the optimum performance of the parser, use <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">beast::basic_flat_buffer</a> with HTTP algorithms such as read, read_some, async_read, and async_read_some. Alternatively, the caller may use custom techniques to ensure that the structured portion of the HTTP message (header or chunk header) is contained in a linear buffer.</p>
<p>The interface to the parser uses virtual member functions. To use this class, derive your type from <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">basic_parser</a>. When bytes are presented, the implementation will make a series of zero or more calls to virtual functions, which the derived class must implement.</p>
<p>Every virtual function must be provided by the derived class, or else a compilation error will be generated. The implementation will make sure that <code>ec</code> is clear before each virtual function is invoked. If a virtual function sets an error, it is propagated out of the parser to the caller.</p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">isRequest</td><td>A <code>bool</code> indicating whether the parser will be presented with request or response message.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>If the parser encounters a field value with obs-fold longer than 4 kilobytes in length, an error is generated. </dd></dl>
</div><h2 class="groupheader">構築子と解体子</h2>
<a id="a297985f4259daf7d71c93dee21405be8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a297985f4259daf7d71c93dee21405be8">&#9670;&nbsp;</a></span>basic_parser()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest &gt;::<a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">basic_parser</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">basic_parser</a>&lt; isRequest &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor</p>
<dl class="section note"><dt>覚え書き</dt><dd></dd></dl>
<p>After the move, the only valid operation on the moved-from object is destruction. </p>

</div>
</div>
<h2 class="groupheader">関数詳解</h2>
<a id="aa16820f60fb34f319a1e134410aaeacc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16820f60fb34f319a1e134410aaeacc">&#9670;&nbsp;</a></span>body_limit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest &gt;::body_limit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1optional.html">boost::optional</a>&lt; std::uint64_t &gt;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the limit on the payload body.</p>
<p>This function sets the maximum allowed size of the payload body, before any encodings except chunked have been removed. Depending on the message semantics, one of these cases will apply:</p>
<ul>
<li>The Content-Length is specified and exceeds the limit. In this case the result error::body_limit is returned immediately after the header is parsed.</li>
</ul>
<ul>
<li>The Content-Length is unspecified and the chunked encoding is not specified as the last encoding. In this case the end of message is determined by the end of file indicator on the associated stream or input source. If a sufficient number of body payload octets are presented to the parser to exceed the configured limit, the parse fails with the result error::body_limit</li>
</ul>
<ul>
<li>The Transfer-Encoding specifies the chunked encoding as the last encoding. In this case, when the number of payload body octets produced by removing the chunked encoding exceeds the configured limit, the parse fails with the result error::body_limit.</li>
</ul>
<p>Setting the limit after any body octets have been parsed results in undefined behavior.</p>
<p>The default limit is 1MB for requests and 8MB for responses.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>An optional integral value representing the body limit. If this is equal to <code>boost::none</code>, then the body limit is disabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13ef707ae9e6564a1137336a75962bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ef707ae9e6564a1137336a75962bf7">&#9670;&nbsp;</a></span>chunked()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest &gt;::chunked </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the last value for Transfer-Encoding is "chunked".</p>
<dl class="section note"><dt>覚え書き</dt><dd>The return value is undefined unless <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a08016379a9858456c069333fd9c3ad55">is_header_done</a> would return <code>true</code>. </dd></dl>

</div>
</div>
<a id="a3be5a827eed5160aeb11dc4b8d1443e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be5a827eed5160aeb11dc4b8d1443e4">&#9670;&nbsp;</a></span>content_length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1optional.html">boost::optional</a>&lt; std::uint64_t &gt; <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest &gt;::content_length</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the optional value of Content-Length if known.</p>
<dl class="section note"><dt>覚え書き</dt><dd>The return value is undefined unless <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a08016379a9858456c069333fd9c3ad55">is_header_done</a> would return <code>true</code>. </dd></dl>

</div>
</div>
<a id="ab47b83affaed66cc87150431b7604f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab47b83affaed66cc87150431b7604f57">&#9670;&nbsp;</a></span>content_length_remaining()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1optional.html">boost::optional</a>&lt; std::uint64_t &gt; <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest &gt;::content_length_remaining</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the remaining content length if known</p>
<p>If the message header specifies a Content-Length, the return value will be the number of bytes remaining in the payload body have not yet been parsed.</p>
<dl class="section note"><dt>覚え書き</dt><dd>The return value is undefined unless <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a08016379a9858456c069333fd9c3ad55">is_header_done</a> would return <code>true</code>. </dd></dl>

</div>
</div>
<a id="a9bf8eb23a75eb6c47a30d1b26b65c733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bf8eb23a75eb6c47a30d1b26b65c733">&#9670;&nbsp;</a></span>eager()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest &gt;::eager </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the eager parse option.</p>
<p>Normally the parser returns after successfully parsing a structured element (header, chunk header, or chunk body) even if there are octets remaining in the input. This is necessary when attempting to parse the header first, or when the caller wants to inspect information which may be invalidated by subsequent parsing, such as a chunk extension. The <code>eager</code> option controls whether the parser keeps going after parsing structured element if there are octets remaining in the buffer and no error occurs. This option is automatically set or cleared during certain stream operations to improve performance with no change in functionality.</p>
<p>The default setting is <code>false</code>.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td><code>true</code> to set the eager parse option or <code>false</code> to disable it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe943a02c95d4bf1271d98d701addfd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe943a02c95d4bf1271d98d701addfd3">&#9670;&nbsp;</a></span>header_limit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest &gt;::header_limit </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set a limit on the total size of the header.</p>
<p>This function sets the maximum allowed size of the header including all field name, value, and delimiter characters and also including the CRLF sequences in the serialized input. If the end of the header is not found within the limit of the header size, the error error::header_limit is returned by <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#ac128c3885a041add27097754304808f4">put</a>.</p>
<p>Setting the limit after any header octets have been parsed results in undefined behavior. </p>

</div>
</div>
<a id="a370a556057bd1e542f2e54e843dbac1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a370a556057bd1e542f2e54e843dbac1d">&#9670;&nbsp;</a></span>is_done()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest &gt;::is_done </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the message is complete.</p>
<p>The message is complete after the full header is prduced and one of the following is true:</p>
<ul>
<li>The skip body option was set.</li>
</ul>
<ul>
<li>The semantics of the message indicate there is no body.</li>
</ul>
<ul>
<li>The semantics of the message indicate a body is expected, and the entire body was parsed. </li>
</ul>

</div>
</div>
<a id="a08016379a9858456c069333fd9c3ad55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08016379a9858456c069333fd9c3ad55">&#9670;&nbsp;</a></span>is_header_done()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest &gt;::is_header_done </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>true</code> if a the parser has produced the full header. </p>

</div>
</div>
<a id="a526185ddd60ccb4bfb7f50b2ff7bbb59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a526185ddd60ccb4bfb7f50b2ff7bbb59">&#9670;&nbsp;</a></span>keep_alive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest &gt;::keep_alive</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the message has keep-alive connection semantics.</p>
<p>This function always returns <code>false</code> if <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a285c1e3e9501f5aa80e0e7b7526642a9">need_eof</a> would return <code>false</code>.</p>
<dl class="section note"><dt>覚え書き</dt><dd>The return value is undefined unless <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a08016379a9858456c069333fd9c3ad55">is_header_done</a> would return <code>true</code>. </dd></dl>

</div>
</div>
<a id="a285c1e3e9501f5aa80e0e7b7526642a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a285c1e3e9501f5aa80e0e7b7526642a9">&#9670;&nbsp;</a></span>need_eof()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest &gt;::need_eof </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the message semantics require an end of file.</p>
<p>Depending on the contents of the header, the parser may require and end of file notification to know where the end of the body lies. If this function returns <code>true</code> it will be necessary to call <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#af2fbbb5513978d2aa09d6d4c7ec93f2b">put_eof</a> when there will never be additional data from the input. </p>

</div>
</div>
<a id="a7d14e005f550e726c66380a4ba910b1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d14e005f550e726c66380a4ba910b1d">&#9670;&nbsp;</a></span>on_body_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest &gt;::on_body_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1basic__string__view.html">string_view</a>&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called each time additional data is received representing the content body.</p>
<p>This virtual function is invoked for each piece of the body which is received while parsing of a message. This function is only used when no chunked transfer encoding is present.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">body</td><td>A string holding the additional body contents. This may contain nulls or unprintable characters.</td></tr>
    <tr><td class="paramname">ec</td><td>An output parameter which the function may set to indicate an error. The error will be clear before this function is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a06953676af09d66f0623a81dc533110f">on_chunk_body_impl</a> </dd></dl>

</div>
</div>
<a id="aff3cc43dade8dc2e5fef1887ea9d488e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff3cc43dade8dc2e5fef1887ea9d488e">&#9670;&nbsp;</a></span>on_body_init_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest &gt;::on_body_init_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1optional.html">boost::optional</a>&lt; std::uint64_t &gt; const &amp;&#160;</td>
          <td class="paramname"><em>content_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called once before the body is processed.</p>
<p>This virtual function is invoked once, before the content body is processed (but after the complete header is received).</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">content_length</td><td>A value representing the content length in bytes if the length is known (this can include a zero length). Otherwise, the value will be <code>boost::none</code>.</td></tr>
    <tr><td class="paramname">ec</td><td>An output parameter which the function may set to indicate an error. The error will be clear before this function is invoked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06953676af09d66f0623a81dc533110f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06953676af09d66f0623a81dc533110f">&#9670;&nbsp;</a></span>on_chunk_body_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest &gt;::on_chunk_body_impl </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>remain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1basic__string__view.html">string_view</a>&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called each time additional data is received representing part of a body chunk.</p>
<p>This virtual function is invoked for each piece of the body which is received while parsing of a message. This function is only used when no chunked transfer encoding is present.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">remain</td><td>The number of bytes remaining in this chunk. This includes the contents of passed <code>body</code>. If this value is zero, then this represents the final chunk.</td></tr>
    <tr><td class="paramname">body</td><td>A string holding the additional body contents. This may contain nulls or unprintable characters.</td></tr>
    <tr><td class="paramname">ec</td><td>An output parameter which the function may set to indicate an error. The error will be clear before this function is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>This function should return the number of bytes actually consumed from the <code>body</code> value. Any bytes that are not consumed on this call will be presented in a subsequent call.</dd></dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a7d14e005f550e726c66380a4ba910b1d">on_body_impl</a> </dd></dl>

</div>
</div>
<a id="a9c0d6b7c1ed8996dd8e6bf1bd0db989e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c0d6b7c1ed8996dd8e6bf1bd0db989e">&#9670;&nbsp;</a></span>on_chunk_header_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest &gt;::on_chunk_header_impl </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1basic__string__view.html">string_view</a>&#160;</td>
          <td class="paramname"><em>extensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called each time a new chunk header of a chunk encoded body is received.</p>
<p>This function is invoked each time a new chunk header is received. The function is only used when the chunked transfer encoding is present.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size of this chunk, in bytes.</td></tr>
    <tr><td class="paramname">extensions</td><td>A string containing the entire chunk extensions. This may be empty, indicating no extensions are present.</td></tr>
    <tr><td class="paramname">ec</td><td>An output parameter which the function may set to indicate an error. The error will be clear before this function is invoked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96b943ee89dd9797be7d9f58a759c408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96b943ee89dd9797be7d9f58a759c408">&#9670;&nbsp;</a></span>on_field_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest &gt;::on_field_impl </td>
          <td>(</td>
          <td class="paramtype">field&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1basic__string__view.html">string_view</a>&#160;</td>
          <td class="paramname"><em>name_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1basic__string__view.html">string_view</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called once for each complete field in the HTTP header.</p>
<p>This virtual function is invoked for each field that is received while parsing an HTTP message.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The known field enum value. If the name of the field is not recognized, this value will be field::unknown.</td></tr>
    <tr><td class="paramname">name_string</td><td>The exact name of the field as received from the input, represented as a string.</td></tr>
    <tr><td class="paramname">value</td><td>A string holding the value of the field.</td></tr>
    <tr><td class="paramname">ec</td><td>An output parameter which the function may set to indicate an error. The error will be clear before this function is invoked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad541cd20c1303bec016d5efc69af2d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad541cd20c1303bec016d5efc69af2d32">&#9670;&nbsp;</a></span>on_finish_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest &gt;::on_finish_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called once when the complete message is received.</p>
<p>This virtual function is invoked once, after successfully parsing a complete HTTP message.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>An output parameter which the function may set to indicate an error. The error will be clear before this function is invoked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88533b98e8d396cc903444a7618de0fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88533b98e8d396cc903444a7618de0fe">&#9670;&nbsp;</a></span>on_header_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest &gt;::on_header_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called once after the complete HTTP header is received.</p>
<p>This virtual function is invoked once, after the complete HTTP header is received while parsing a message.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>An output parameter which the function may set to indicate an error. The error will be clear before this function is invoked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2fb672c49d4c98b7cf19887f3dd6c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2fb672c49d4c98b7cf19887f3dd6c4a">&#9670;&nbsp;</a></span>on_request_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest &gt;::on_request_impl </td>
          <td>(</td>
          <td class="paramtype">verb&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1basic__string__view.html">string_view</a>&#160;</td>
          <td class="paramname"><em>method_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1basic__string__view.html">string_view</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called after receiving the request-line.</p>
<p>This virtual function is invoked after receiving a request-line when parsing HTTP requests. It can only be called when <code>isRequest == true</code>.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">method</td><td>The verb enumeration. If the method string is not one of the predefined strings, this value will be verb::unknown.</td></tr>
    <tr><td class="paramname">method_str</td><td>The unmodified string representing the verb.</td></tr>
    <tr><td class="paramname">target</td><td>The request-target.</td></tr>
    <tr><td class="paramname">version</td><td>The HTTP-version. This will be 10 for HTTP/1.0, and 11 for HTTP/1.1.</td></tr>
    <tr><td class="paramname">ec</td><td>An output parameter which the function may set to indicate an error. The error will be clear before this function is invoked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad5b2c98e4b770d5807b99242a31b1091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5b2c98e4b770d5807b99242a31b1091">&#9670;&nbsp;</a></span>on_response_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest &gt;::on_response_impl </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1basic__string__view.html">string_view</a>&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called after receiving the status-line.</p>
<p>This virtual function is invoked after receiving a status-line when parsing HTTP responses. It can only be called when <code>isRequest == false</code>.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>The numeric status code.</td></tr>
    <tr><td class="paramname">reason</td><td>The reason-phrase. Note that this value is now obsolete, and only provided for historical or diagnostic purposes.</td></tr>
    <tr><td class="paramname">version</td><td>The HTTP-version. This will be 10 for HTTP/1.0, and 11 for HTTP/1.1.</td></tr>
    <tr><td class="paramname">ec</td><td>An output parameter which the function may set to indicate an error. The error will be clear before this function is invoked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac128c3885a041add27097754304808f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac128c3885a041add27097754304808f4">&#9670;&nbsp;</a></span>put()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest&gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest &gt;::put </td>
          <td>(</td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a buffer sequence to the parser.</p>
<p>This function attempts to incrementally parse the HTTP message data stored in the caller provided buffers. Upon success, a positive return value indicates that the parser made forward progress, consuming that number of bytes.</p>
<p>In some cases there may be an insufficient number of octets in the input buffer in order to make forward progress. This is indicated by the code error::need_more. When this happens, the caller should place additional bytes into the buffer sequence and call <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#ac128c3885a041add27097754304808f4">put</a> again.</p>
<p>The error code error::need_more is special. When this error is returned, a subsequent call to <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#ac128c3885a041add27097754304808f4">put</a> may succeed if the buffers have been updated. Otherwise, upon error the parser may not be restarted.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>An object meeting the requirements of <em>ConstBufferSequence</em> that represents the next chunk of message data. If the length of this buffer sequence is one, the implementation will not allocate additional memory. The class <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">beast::basic_flat_buffer</a> is provided as one way to meet this requirement</td></tr>
    <tr><td class="paramname">ec</td><td>Set to the error, if any occurred.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The number of octets consumed in the buffer sequence. The caller should remove these octets even if the error is set. </dd></dl>

</div>
</div>
<a id="af2fbbb5513978d2aa09d6d4c7ec93f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2fbbb5513978d2aa09d6d4c7ec93f2b">&#9670;&nbsp;</a></span>put_eof()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest &gt;::put_eof </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inform the parser that the end of stream was reached.</p>
<p>In certain cases, HTTP needs to know where the end of the stream is. For example, sometimes servers send responses without Content-Length and expect the client to consume input (for the body) until EOF. Callbacks and errors will still be processed as usual.</p>
<p>This is typically called when a read from the underlying stream object sets the error code to <code>net::error::eof</code>.</p>
<dl class="section note"><dt>覚え書き</dt><dd>Only valid after parsing a complete header.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to the error, if any occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5af4582d87275d76a8d694e88f372ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af4582d87275d76a8d694e88f372ccf">&#9670;&nbsp;</a></span>skip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest &gt;::skip </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the skip parse option.</p>
<p>This option controls whether or not the parser expects to see an HTTP body, regardless of the presence or absence of certain fields such as Content-Length or a chunked Transfer-Encoding. Depending on the request, some responses do not carry a body. For example, a 200 response to a CONNECT request from a tunneling proxy, or a response to a HEAD request. In these cases, callers may use this function inform the parser that no body is expected. The parser will consider the message complete after the header has been received.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td><code>true</code> to set the skip body option or <code>false</code> to disable it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>This function must called before any bytes are processed. </dd></dl>

</div>
</div>
<a id="aa638fcd0bab91215154625f0f5b9a345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa638fcd0bab91215154625f0f5b9a345">&#9670;&nbsp;</a></span>upgrade()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest &gt;::upgrade </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the message is an upgrade message.</p>
<dl class="section note"><dt>覚え書き</dt><dd>The return value is undefined unless <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a08016379a9858456c069333fd9c3ad55">is_header_done</a> would return <code>true</code>. </dd></dl>

</div>
</div>
<hr/>このクラス詳解は次のファイルから抽出されました:<ul>
<li>include/external/boost/boost/beast/http/<a class="el" href="basic__parser_8hpp_source.html">basic_parser.hpp</a></li>
<li>include/external/boost/boost/beast/http/impl/basic_parser.ipp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceboost.html">boost</a></li><li class="navelem"><b>beast</b></li><li class="navelem"><b>http</b></li><li class="navelem"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">basic_parser</a></li>
    <li class="footer">構築:
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
