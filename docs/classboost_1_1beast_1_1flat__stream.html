<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
<head>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
        'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
        })(window,document,'script','dataLayer','GTM-NN5JX4B');</script>
    <!-- End Google Tag Manager -->
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=11"/>
    <meta name="generator" content="Doxygen 1.9.8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>SkyWay Linux SDK</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="resize.js"></script>
    <script type="text/javascript" src="navtreedata.js"></script>
    <script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="search/searchdata.js"></script>
    <script type="text/javascript" src="search/search.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NN5JX4B"
        height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
            <tbody>
                <tr id="projectrow">
                    <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
                    <td id="projectalign">
                        <div id="projectname">SkyWay Linux SDK
                        </div>
                    </td>
                </tr>
            </tbody>
        </table>
    </div><!-- 構築: Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'検索');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','検索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classboost_1_1beast_1_1flat__stream.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">クラス</a> &#124;
<a href="#pub-types">公開型</a> &#124;
<a href="#pub-methods">公開メンバ関数</a> &#124;
<a href="classboost_1_1beast_1_1flat__stream-members.html">全メンバ一覧</a>  </div>
  <div class="headertitle">
<div class="title">boost::beast::flat_stream&lt; NextLayer &gt; クラステンプレート</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="flat__stream_8hpp_source.html">flat_stream.hpp</a>&gt;</code></p>
<div class="dynheader">
boost::beast::flat_stream&lt; NextLayer &gt; の継承関係図</div>
<div class="dyncontent">
 <div class="center">
  <img src="classboost_1_1beast_1_1flat__stream.png" usemap="#boost::beast::flat_5Fstream_3C_20NextLayer_20_3E_map" alt=""/>
  <map id="boost::beast::flat_5Fstream_3C_20NextLayer_20_3E_map" name="boost::beast::flat_5Fstream_3C_20NextLayer_20_3E_map">
<area href="classboost_1_1beast_1_1detail_1_1flat__stream__base.html" alt="boost::beast::detail::flat_stream_base" shape="rect" coords="0,0,227,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
クラス</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1beast_1_1flat__stream_1_1ops.html">ops</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
公開型</h2></td></tr>
<tr class="memitem:a3c7be682f9493aa4f334499b97c80c8b"><td class="memItemLeft" align="right" valign="top"><a id="a3c7be682f9493aa4f334499b97c80c8b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1flat__stream.html#a3c7be682f9493aa4f334499b97c80c8b">next_layer_type</a> = typename std::remove_reference&lt; NextLayer &gt;::<a class="el" href="structboost_1_1type.html">type</a></td></tr>
<tr class="memdesc:a3c7be682f9493aa4f334499b97c80c8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the next layer. <br /></td></tr>
<tr class="separator:a3c7be682f9493aa4f334499b97c80c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfc604e2737ae77defc1bb0f3badf72"><td class="memItemLeft" align="right" valign="top"><a id="a3cfc604e2737ae77defc1bb0f3badf72"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1flat__stream.html#a3cfc604e2737ae77defc1bb0f3badf72">executor_type</a> = beast::executor_type&lt; <a class="el" href="classboost_1_1beast_1_1flat__stream.html#a3c7be682f9493aa4f334499b97c80c8b">next_layer_type</a> &gt;</td></tr>
<tr class="memdesc:a3cfc604e2737ae77defc1bb0f3badf72"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the executor associated with the object. <br /></td></tr>
<tr class="separator:a3cfc604e2737ae77defc1bb0f3badf72"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
公開メンバ関数</h2></td></tr>
<tr class="memitem:a0d090657885f0d802a548cce9801d6b0"><td class="memItemLeft" align="right" valign="top"><a id="a0d090657885f0d802a548cce9801d6b0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>flat_stream</b> (<a class="el" href="classboost_1_1beast_1_1flat__stream.html">flat_stream</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a0d090657885f0d802a548cce9801d6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432e14cd9c4265992baef8fe7f8cba2b"><td class="memItemLeft" align="right" valign="top"><a id="a432e14cd9c4265992baef8fe7f8cba2b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>flat_stream</b> (<a class="el" href="classboost_1_1beast_1_1flat__stream.html">flat_stream</a> const &amp;)=default</td></tr>
<tr class="separator:a432e14cd9c4265992baef8fe7f8cba2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858858fc6272cf86d88be77a9316fd42"><td class="memItemLeft" align="right" valign="top"><a id="a858858fc6272cf86d88be77a9316fd42"></a>
<a class="el" href="classboost_1_1beast_1_1flat__stream.html">flat_stream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classboost_1_1beast_1_1flat__stream.html">flat_stream</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a858858fc6272cf86d88be77a9316fd42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45408764a20b4adb1e01cf0d91bfd330"><td class="memItemLeft" align="right" valign="top"><a id="a45408764a20b4adb1e01cf0d91bfd330"></a>
<a class="el" href="classboost_1_1beast_1_1flat__stream.html">flat_stream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classboost_1_1beast_1_1flat__stream.html">flat_stream</a> const &amp;)=default</td></tr>
<tr class="separator:a45408764a20b4adb1e01cf0d91bfd330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff6614f49be63f442ff490abc226e2d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1flat__stream.html#a7ff6614f49be63f442ff490abc226e2d">~flat_stream</a> ()=default</td></tr>
<tr class="separator:a7ff6614f49be63f442ff490abc226e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e26098d3fc45739e5cbd4f6c9a43e6b"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a3e26098d3fc45739e5cbd4f6c9a43e6b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1flat__stream.html#a3e26098d3fc45739e5cbd4f6c9a43e6b">flat_stream</a> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:a3e26098d3fc45739e5cbd4f6c9a43e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e2ca6d083cf084dc1c4862abbd4e29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1flat__stream.html#a3cfc604e2737ae77defc1bb0f3badf72">executor_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1flat__stream.html#a41e2ca6d083cf084dc1c4862abbd4e29">get_executor</a> () noexcept</td></tr>
<tr class="separator:a41e2ca6d083cf084dc1c4862abbd4e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e98951f266b16c68ba64ea29fe35d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1flat__stream.html#a3c7be682f9493aa4f334499b97c80c8b">next_layer_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1flat__stream.html#a99e98951f266b16c68ba64ea29fe35d2">next_layer</a> () noexcept</td></tr>
<tr class="separator:a99e98951f266b16c68ba64ea29fe35d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244db2f38150792bd99a63449a4fb9ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1flat__stream.html#a3c7be682f9493aa4f334499b97c80c8b">next_layer_type</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1flat__stream.html#a244db2f38150792bd99a63449a4fb9ab">next_layer</a> () const noexcept</td></tr>
<tr class="separator:a244db2f38150792bd99a63449a4fb9ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53c4bb96c9fe451e1ac0a56dc5ff951"><td class="memTemplParams" colspan="2">template&lt;class MutableBufferSequence &gt; </td></tr>
<tr class="memitem:ae53c4bb96c9fe451e1ac0a56dc5ff951"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1flat__stream.html#ae53c4bb96c9fe451e1ac0a56dc5ff951">read_some</a> (MutableBufferSequence const &amp;buffers)</td></tr>
<tr class="separator:ae53c4bb96c9fe451e1ac0a56dc5ff951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184eeb4cf9007e38746b31783acbe39b"><td class="memTemplParams" colspan="2">template&lt;class MutableBufferSequence &gt; </td></tr>
<tr class="memitem:a184eeb4cf9007e38746b31783acbe39b"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1flat__stream.html#a184eeb4cf9007e38746b31783acbe39b">read_some</a> (MutableBufferSequence const &amp;buffers, <a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;ec)</td></tr>
<tr class="separator:a184eeb4cf9007e38746b31783acbe39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ad1d26ad8bdee426a8da5c12cec6b9"><td class="memTemplParams" colspan="2">template&lt;class MutableBufferSequence , BOOST_BEAST_ASYNC_TPARAM2 ReadHandler = net::default_completion_token_t&lt;executor_type&gt;&gt; </td></tr>
<tr class="memitem:ac9ad1d26ad8bdee426a8da5c12cec6b9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1flat__stream.html#ac9ad1d26ad8bdee426a8da5c12cec6b9">async_read_some</a> (MutableBufferSequence const &amp;buffers, ReadHandler &amp;&amp;handler=net::default_completion_token_t&lt; <a class="el" href="classboost_1_1beast_1_1flat__stream.html#a3cfc604e2737ae77defc1bb0f3badf72">executor_type</a> &gt;{})</td></tr>
<tr class="separator:ac9ad1d26ad8bdee426a8da5c12cec6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab7dad79440cb6a70d0d96fa61e73e9"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence &gt; </td></tr>
<tr class="memitem:a4ab7dad79440cb6a70d0d96fa61e73e9"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1flat__stream.html#a4ab7dad79440cb6a70d0d96fa61e73e9">write_some</a> (ConstBufferSequence const &amp;buffers)</td></tr>
<tr class="separator:a4ab7dad79440cb6a70d0d96fa61e73e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34343f0b321435083f45da4beefc8ef0"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence &gt; </td></tr>
<tr class="memitem:a34343f0b321435083f45da4beefc8ef0"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1flat__stream.html#a34343f0b321435083f45da4beefc8ef0">write_some</a> (ConstBufferSequence const &amp;buffers, <a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;ec)</td></tr>
<tr class="separator:a34343f0b321435083f45da4beefc8ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93150487ba1f25763bc5398adff9281f"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence , BOOST_BEAST_ASYNC_TPARAM2 WriteHandler = net::default_completion_token_t&lt;executor_type&gt;&gt; </td></tr>
<tr class="memitem:a93150487ba1f25763bc5398adff9281f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1flat__stream.html#a93150487ba1f25763bc5398adff9281f">async_write_some</a> (ConstBufferSequence const &amp;buffers, WriteHandler &amp;&amp;handler=net::default_completion_token_t&lt; <a class="el" href="classboost_1_1beast_1_1flat__stream.html#a3cfc604e2737ae77defc1bb0f3badf72">executor_type</a> &gt;{})</td></tr>
<tr class="separator:a93150487ba1f25763bc5398adff9281f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">詳解</h2>
<div class="textblock"><h3>template&lt;class NextLayer&gt;<br />
class boost::beast::flat_stream&lt; NextLayer &gt;</h3>

<p>Stream wrapper to improve write performance.</p>
<p>This wrapper flattens writes for buffer sequences having length greater than 1 and total size below a predefined amount, using a dynamic memory allocation. It is primarily designed to overcome a performance limitation of the current version of <code>net::ssl::stream</code>, which does not use OpenSSL's scatter/gather interface for its low-level read some and write some operations.</p>
<p>It is normally not necessary to use this class directly if you are already using <a class="el" href="classboost_1_1beast_1_1ssl__stream.html">ssl_stream</a>. The following examples shows how to use this class with the ssl stream that comes with networking:</p>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<p>To use the <a class="el" href="classboost_1_1beast_1_1flat__stream.html">flat_stream</a> template with SSL streams, declare a variable of the correct type. Parameters passed to the constructor will be forwarded to the next layer's constructor:</p>
<div class="fragment"><div class="line">flat_stream&lt;net::ssl::stream&lt;ip::tcp::socket&gt;&gt; fs{ioc, ctx};</div>
</div><!-- fragment --><p> Alternatively you can write </p><div class="fragment"><div class="line">ssl::stream&lt;ip::tcp::socket&gt; ss{ioc, ctx};</div>
<div class="line">flat_stream&lt;net::ssl::stream&lt;ip::tcp::socket&gt;&amp;&gt; fs{ss};</div>
</div><!-- fragment --><p>The resulting stream may be passed to any stream algorithms which operate on synchronous or asynchronous read or write streams, examples include:</p>
<ul>
<li><code>net::read</code>, <code>net::async_read</code></li>
</ul>
<ul>
<li><code>net::write</code>, <code>net::async_write</code></li>
</ul>
<ul>
<li><code>net::read_until</code>, <code>net::async_read_until</code></li>
</ul>
<p>The stream may also be used as a template parameter in other stream wrappers, such as for websocket: </p><div class="fragment"><div class="line">websocket::stream&lt;flat_stream&lt;net::ssl::stream&lt;ip::tcp::socket&gt;&gt;&gt; ws{ioc, ctx};</div>
</div><!-- fragment --><dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NextLayer</td><td>The type representing the next layer, to which data will be read and written during operations. For synchronous operations, the type must support the <b>SyncStream</b> concept. For asynchronous operations, the type must support the <b>AsyncStream</b> concept. This type will usually be some variation of <code>net::ssl::stream</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Concepts</dt><dd><ul>
<li>SyncStream </li>
<li>AsyncStream</li>
</ul>
</dd></dl>
<dl class="section see"><dt>参照</dt><dd><ul>
<li><a href="https://github.com/boostorg/asio/issues/100">https://github.com/boostorg/asio/issues/100</a> </li>
<li><a href="https://github.com/boostorg/beast/issues/1108">https://github.com/boostorg/beast/issues/1108</a> </li>
<li><a href="https://stackoverflow.com/questions/38198638/openssl-ssl-write-from-multiple-buffers-ssl-writev">https://stackoverflow.com/questions/38198638/openssl-ssl-write-from-multiple-buffers-ssl-writev</a> </li>
<li><a href="https://stackoverflow.com/questions/50026167/performance-drop-on-port-from-beast-1-0-0-b66-to-boost-1-67-0-beast">https://stackoverflow.com/questions/50026167/performance-drop-on-port-from-beast-1-0-0-b66-to-boost-1-67-0-beast</a> </li>
</ul>
</dd></dl>
</div><h2 class="groupheader">構築子と解体子</h2>
<a id="a7ff6614f49be63f442ff490abc226e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ff6614f49be63f442ff490abc226e2d">&#9670;&nbsp;</a></span>~flat_stream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1flat__stream.html">boost::beast::flat_stream</a>&lt; NextLayer &gt;::~<a class="el" href="classboost_1_1beast_1_1flat__stream.html">flat_stream</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor</p>
<p>The treatment of pending operations will be the same as that of the next layer. </p>

</div>
</div>
<a id="a3e26098d3fc45739e5cbd4f6c9a43e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e26098d3fc45739e5cbd4f6c9a43e6b">&#9670;&nbsp;</a></span>flat_stream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1flat__stream.html">boost::beast::flat_stream</a>&lt; NextLayer &gt;::<a class="el" href="classboost_1_1beast_1_1flat__stream.html">flat_stream</a> </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor</p>
<p>Arguments, if any, are forwarded to the next layer's constructor. </p>

</div>
</div>
<h2 class="groupheader">関数詳解</h2>
<a id="ac9ad1d26ad8bdee426a8da5c12cec6b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9ad1d26ad8bdee426a8da5c12cec6b9">&#9670;&nbsp;</a></span>async_read_some()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class MutableBufferSequence , BOOST_BEAST_ASYNC_TPARAM2 ReadHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1flat__stream.html">boost::beast::flat_stream</a>&lt; NextLayer &gt;::async_read_some </td>
          <td>(</td>
          <td class="paramtype">MutableBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em> = <code>net::default_completion_token_t&lt;<a class="el" href="classboost_1_1beast_1_1flat__stream.html#a3cfc604e2737ae77defc1bb0f3badf72">executor_type</a>&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start an asynchronous read.</p>
<p>This function is used to asynchronously read one or more bytes of data from the stream. The function call always returns immediately.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The buffers into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying buffers is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(</div>
<div class="line">    error_code <span class="keyword">const</span>&amp; error,        <span class="comment">// Result of operation.</span></div>
<div class="line">    std::size_t bytes_transferred   <span class="comment">// Number of bytes read.</span></div>
<div class="line">);</div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>net::post</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>The <code>read_some</code> operation may not read all of the requested number of bytes. Consider using the function <code>net::async_read</code> if you need to ensure that the requested amount of data is read before the asynchronous operation completes. </dd></dl>

</div>
</div>
<a id="a93150487ba1f25763bc5398adff9281f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93150487ba1f25763bc5398adff9281f">&#9670;&nbsp;</a></span>async_write_some()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence , BOOST_BEAST_ASYNC_TPARAM2 WriteHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1flat__stream.html">boost::beast::flat_stream</a>&lt; NextLayer &gt;::async_write_some </td>
          <td>(</td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em> = <code>net::default_completion_token_t&lt;<a class="el" href="classboost_1_1beast_1_1flat__stream.html#a3cfc604e2737ae77defc1bb0f3badf72">executor_type</a>&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start an asynchronous write.</p>
<p>This function is used to asynchronously write one or more bytes of data to the stream. The function call always returns immediately.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The data to be written to the stream. Although the buffers object may be copied as necessary, ownership of the underlying buffers is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(</div>
<div class="line">    error_code <span class="keyword">const</span>&amp; ec,           <span class="comment">// Result of operation.</span></div>
<div class="line">    std::size_t bytes_transferred   <span class="comment">// Number of bytes written.</span></div>
<div class="line">);</div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>net::post</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>The <code>async_write_some</code> operation may not transmit all of the data to the peer. Consider using the function <code>net::async_write</code> if you need to ensure that all data is written before the asynchronous operation completes. </dd></dl>

</div>
</div>
<a id="a41e2ca6d083cf084dc1c4862abbd4e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41e2ca6d083cf084dc1c4862abbd4e29">&#9670;&nbsp;</a></span>get_executor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1flat__stream.html#a3cfc604e2737ae77defc1bb0f3badf72">executor_type</a> <a class="el" href="classboost_1_1beast_1_1flat__stream.html">boost::beast::flat_stream</a>&lt; NextLayer &gt;::get_executor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the executor associated with the object.</p>
<p>This function may be used to obtain the executor object that the stream uses to dispatch handlers for asynchronous operations.</p>
<dl class="section return"><dt>戻り値</dt><dd>A copy of the executor that stream will use to dispatch handlers. </dd></dl>

</div>
</div>
<a id="a244db2f38150792bd99a63449a4fb9ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244db2f38150792bd99a63449a4fb9ab">&#9670;&nbsp;</a></span>next_layer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1flat__stream.html#a3c7be682f9493aa4f334499b97c80c8b">next_layer_type</a> const&amp; <a class="el" href="classboost_1_1beast_1_1flat__stream.html">boost::beast::flat_stream</a>&lt; NextLayer &gt;::next_layer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a reference to the next layer</p>
<p>This function returns a reference to the next layer in a stack of stream layers.</p>
<dl class="section return"><dt>戻り値</dt><dd>A reference to the next layer in the stack of stream layers. </dd></dl>

</div>
</div>
<a id="a99e98951f266b16c68ba64ea29fe35d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99e98951f266b16c68ba64ea29fe35d2">&#9670;&nbsp;</a></span>next_layer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1flat__stream.html#a3c7be682f9493aa4f334499b97c80c8b">next_layer_type</a>&amp; <a class="el" href="classboost_1_1beast_1_1flat__stream.html">boost::beast::flat_stream</a>&lt; NextLayer &gt;::next_layer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a reference to the next layer</p>
<p>This function returns a reference to the next layer in a stack of stream layers.</p>
<dl class="section return"><dt>戻り値</dt><dd>A reference to the next layer in the stack of stream layers. </dd></dl>

</div>
</div>
<a id="ae53c4bb96c9fe451e1ac0a56dc5ff951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53c4bb96c9fe451e1ac0a56dc5ff951">&#9670;&nbsp;</a></span>read_some() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class MutableBufferSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1flat__stream.html">boost::beast::flat_stream</a>&lt; NextLayer &gt;::read_some </td>
          <td>(</td>
          <td class="paramtype">MutableBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read some data from the stream.</p>
<p>This function is used to read data from the stream. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The buffers into which the data will be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The number of bytes read.</dd></dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classboost_1_1system_1_1system__error.html">boost::system::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>The <code>read_some</code> operation may not read all of the requested number of bytes. Consider using the function <code>net::read</code> if you need to ensure that the requested amount of data is read before the blocking operation completes. </dd></dl>

</div>
</div>
<a id="a184eeb4cf9007e38746b31783acbe39b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a184eeb4cf9007e38746b31783acbe39b">&#9670;&nbsp;</a></span>read_some() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class MutableBufferSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1flat__stream.html">boost::beast::flat_stream</a>&lt; NextLayer &gt;::read_some </td>
          <td>(</td>
          <td class="paramtype">MutableBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read some data from the stream.</p>
<p>This function is used to read data from the stream. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The buffers into which the data will be read.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The number of bytes read.</dd></dl>
<dl class="section note"><dt>覚え書き</dt><dd>The <code>read_some</code> operation may not read all of the requested number of bytes. Consider using the function <code>net::read</code> if you need to ensure that the requested amount of data is read before the blocking operation completes. </dd></dl>

</div>
</div>
<a id="a4ab7dad79440cb6a70d0d96fa61e73e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ab7dad79440cb6a70d0d96fa61e73e9">&#9670;&nbsp;</a></span>write_some() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1flat__stream.html">boost::beast::flat_stream</a>&lt; NextLayer &gt;::write_some </td>
          <td>(</td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write some data to the stream.</p>
<p>This function is used to write data on the stream. The function call will block until one or more bytes of data has been written successfully, or until an error occurs.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The data to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The number of bytes written.</dd></dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classboost_1_1system_1_1system__error.html">boost::system::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>The <code>write_some</code> operation may not transmit all of the data to the peer. Consider using the function <code>net::write</code> if you need to ensure that all data is written before the blocking operation completes. </dd></dl>

</div>
</div>
<a id="a34343f0b321435083f45da4beefc8ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34343f0b321435083f45da4beefc8ef0">&#9670;&nbsp;</a></span>write_some() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1flat__stream.html">boost::beast::flat_stream</a>&lt; NextLayer &gt;::write_some </td>
          <td>(</td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write some data to the stream.</p>
<p>This function is used to write data on the stream. The function call will block until one or more bytes of data has been written successfully, or until an error occurs.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The data to be written.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The number of bytes written.</dd></dl>
<dl class="section note"><dt>覚え書き</dt><dd>The <code>write_some</code> operation may not transmit all of the data to the peer. Consider using the function <code>net::write</code> if you need to ensure that all data is written before the blocking operation completes. </dd></dl>

</div>
</div>
<hr/>このクラス詳解は次のファイルから抽出されました:<ul>
<li>include/external/boost/boost/beast/core/<a class="el" href="flat__stream_8hpp_source.html">flat_stream.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceboost.html">boost</a></li><li class="navelem"><b>beast</b></li><li class="navelem"><a class="el" href="classboost_1_1beast_1_1flat__stream.html">flat_stream</a></li>
    <li class="footer">構築:
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
