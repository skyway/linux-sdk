<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
<head>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
        'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
        })(window,document,'script','dataLayer','GTM-NN5JX4B');</script>
    <!-- End Google Tag Manager -->
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=11"/>
    <meta name="generator" content="Doxygen 1.9.8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>SkyWay Linux SDK</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="resize.js"></script>
    <script type="text/javascript" src="navtreedata.js"></script>
    <script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="search/searchdata.js"></script>
    <script type="text/javascript" src="search/search.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NN5JX4B"
        height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
            <tbody>
                <tr id="projectrow">
                    <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
                    <td id="projectalign">
                        <div id="projectname">SkyWay Linux SDK
                        </div>
                    </td>
                </tr>
            </tbody>
        </table>
    </div><!-- 構築: Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'検索');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','検索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classboost_1_1asio_1_1ip_1_1basic__resolver.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">クラス</a> &#124;
<a href="#pub-types">公開型</a> &#124;
<a href="#pub-methods">公開メンバ関数</a> &#124;
<a href="#pub-attribs">公開変数類</a> &#124;
<a href="classboost_1_1asio_1_1ip_1_1basic__resolver-members.html">全メンバ一覧</a>  </div>
  <div class="headertitle">
<div class="title">boost::asio::ip::basic_resolver&lt; InternetProtocol, Executor &gt; クラステンプレート</div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides endpoint resolution functionality.  
 <a href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#details">[詳解]</a></p>

<p><code>#include &lt;<a class="el" href="basic__resolver_8hpp_source.html">basic_resolver.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
クラス</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1asio_1_1ip_1_1basic__resolver_1_1rebind__executor.html">rebind_executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebinds the resolver type to another executor.  <a href="structboost_1_1asio_1_1ip_1_1basic__resolver_1_1rebind__executor.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
公開型</h2></td></tr>
<tr class="memitem:a89f64df3455328230d76c27f64ffb40e"><td class="memItemLeft" align="right" valign="top"><a id="a89f64df3455328230d76c27f64ffb40e"></a>
typedef Executor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a89f64df3455328230d76c27f64ffb40e">executor_type</a></td></tr>
<tr class="memdesc:a89f64df3455328230d76c27f64ffb40e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the executor associated with the object. <br /></td></tr>
<tr class="separator:a89f64df3455328230d76c27f64ffb40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0694f56847528e6d427f67967c0df855"><td class="memItemLeft" align="right" valign="top"><a id="a0694f56847528e6d427f67967c0df855"></a>
typedef InternetProtocol&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a0694f56847528e6d427f67967c0df855">protocol_type</a></td></tr>
<tr class="memdesc:a0694f56847528e6d427f67967c0df855"><td class="mdescLeft">&#160;</td><td class="mdescRight">The protocol type. <br /></td></tr>
<tr class="separator:a0694f56847528e6d427f67967c0df855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f1027fdcfd3e348e7084345c350b11e"><td class="memItemLeft" align="right" valign="top"><a id="a8f1027fdcfd3e348e7084345c350b11e"></a>
typedef InternetProtocol::endpoint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a8f1027fdcfd3e348e7084345c350b11e">endpoint_type</a></td></tr>
<tr class="memdesc:a8f1027fdcfd3e348e7084345c350b11e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The endpoint type. <br /></td></tr>
<tr class="separator:a8f1027fdcfd3e348e7084345c350b11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399dca14777c0bcc4884c8133967c31d"><td class="memItemLeft" align="right" valign="top"><a id="a399dca14777c0bcc4884c8133967c31d"></a>
typedef <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver__query.html">basic_resolver_query</a>&lt; InternetProtocol &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a399dca14777c0bcc4884c8133967c31d">query</a></td></tr>
<tr class="memdesc:a399dca14777c0bcc4884c8133967c31d"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.) The query type. <br /></td></tr>
<tr class="separator:a399dca14777c0bcc4884c8133967c31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3776563a25de0bb5b9926802fc3eb5"><td class="memItemLeft" align="right" valign="top"><a id="a5a3776563a25de0bb5b9926802fc3eb5"></a>
typedef <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver__iterator.html">basic_resolver_iterator</a>&lt; InternetProtocol &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a5a3776563a25de0bb5b9926802fc3eb5">iterator</a></td></tr>
<tr class="memdesc:a5a3776563a25de0bb5b9926802fc3eb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.) The iterator type. <br /></td></tr>
<tr class="separator:a5a3776563a25de0bb5b9926802fc3eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a195ff55e2a1512e40becf9f050e6a97a"><td class="memItemLeft" align="right" valign="top"><a id="a195ff55e2a1512e40becf9f050e6a97a"></a>
typedef <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver__results.html">basic_resolver_results</a>&lt; InternetProtocol &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a195ff55e2a1512e40becf9f050e6a97a">results_type</a></td></tr>
<tr class="memdesc:a195ff55e2a1512e40becf9f050e6a97a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The results type. <br /></td></tr>
<tr class="separator:a195ff55e2a1512e40becf9f050e6a97a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
公開メンバ関数</h2></td></tr>
<tr class="memitem:a912fd93033e67e853311784e49f4bf24"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a912fd93033e67e853311784e49f4bf24">basic_resolver</a> (const <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a89f64df3455328230d76c27f64ffb40e">executor_type</a> &amp;ex)</td></tr>
<tr class="memdesc:a912fd93033e67e853311784e49f4bf24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct with executor.  <a href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a912fd93033e67e853311784e49f4bf24">[詳解]</a><br /></td></tr>
<tr class="separator:a912fd93033e67e853311784e49f4bf24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04aa8dce1f3bd9ca8afafb77ebc3b608"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext &gt; </td></tr>
<tr class="memitem:a04aa8dce1f3bd9ca8afafb77ebc3b608"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a04aa8dce1f3bd9ca8afafb77ebc3b608">basic_resolver</a> (ExecutionContext &amp;context, typename <a class="el" href="structboost_1_1asio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structboost_1_1is__convertible.html">is_convertible</a>&lt; ExecutionContext &amp;, <a class="el" href="classboost_1_1asio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;::<a class="el" href="structboost_1_1type.html">type</a> *=0)</td></tr>
<tr class="memdesc:a04aa8dce1f3bd9ca8afafb77ebc3b608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct with execution context.  <a href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a04aa8dce1f3bd9ca8afafb77ebc3b608">[詳解]</a><br /></td></tr>
<tr class="separator:a04aa8dce1f3bd9ca8afafb77ebc3b608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad837d51ffec9afc9ca67b23cadf6216a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#ad837d51ffec9afc9ca67b23cadf6216a">~basic_resolver</a> ()</td></tr>
<tr class="memdesc:ad837d51ffec9afc9ca67b23cadf6216a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the resolver.  <a href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#ad837d51ffec9afc9ca67b23cadf6216a">[詳解]</a><br /></td></tr>
<tr class="separator:ad837d51ffec9afc9ca67b23cadf6216a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278363d1eff339fbd49a18336754416c"><td class="memItemLeft" align="right" valign="top"><a id="a278363d1eff339fbd49a18336754416c"></a>
<a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a89f64df3455328230d76c27f64ffb40e">executor_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a278363d1eff339fbd49a18336754416c">get_executor</a> () BOOST_ASIO_NOEXCEPT</td></tr>
<tr class="memdesc:a278363d1eff339fbd49a18336754416c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the executor associated with the object. <br /></td></tr>
<tr class="separator:a278363d1eff339fbd49a18336754416c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1232a1ac86579a3ad0dc64d1d581d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a6c1232a1ac86579a3ad0dc64d1d581d2">cancel</a> ()</td></tr>
<tr class="memdesc:a6c1232a1ac86579a3ad0dc64d1d581d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel any asynchronous operations that are waiting on the resolver.  <a href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a6c1232a1ac86579a3ad0dc64d1d581d2">[詳解]</a><br /></td></tr>
<tr class="separator:a6c1232a1ac86579a3ad0dc64d1d581d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aec94df9a9f1714d6a46d2f8c276b3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a195ff55e2a1512e40becf9f050e6a97a">results_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a5aec94df9a9f1714d6a46d2f8c276b3a">resolve</a> (const <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a399dca14777c0bcc4884c8133967c31d">query</a> &amp;q)</td></tr>
<tr class="separator:a5aec94df9a9f1714d6a46d2f8c276b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05ef3e6fc554d4491cab3189fb889c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a195ff55e2a1512e40becf9f050e6a97a">results_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#ae05ef3e6fc554d4491cab3189fb889c8">resolve</a> (const <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a399dca14777c0bcc4884c8133967c31d">query</a> &amp;q, <a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a> &amp;ec)</td></tr>
<tr class="separator:ae05ef3e6fc554d4491cab3189fb889c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab720ef7aa8d98e53988fc54678dac0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a195ff55e2a1512e40becf9f050e6a97a">results_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#aab720ef7aa8d98e53988fc54678dac0c">resolve</a> (BOOST_ASIO_STRING_VIEW_PARAM host, BOOST_ASIO_STRING_VIEW_PARAM service)</td></tr>
<tr class="memdesc:aab720ef7aa8d98e53988fc54678dac0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform forward resolution of a query to a list of entries.  <a href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#aab720ef7aa8d98e53988fc54678dac0c">[詳解]</a><br /></td></tr>
<tr class="separator:aab720ef7aa8d98e53988fc54678dac0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7036a41fa98c1ac50df9083f20debb81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a195ff55e2a1512e40becf9f050e6a97a">results_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a7036a41fa98c1ac50df9083f20debb81">resolve</a> (BOOST_ASIO_STRING_VIEW_PARAM host, BOOST_ASIO_STRING_VIEW_PARAM service, <a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a7036a41fa98c1ac50df9083f20debb81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform forward resolution of a query to a list of entries.  <a href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a7036a41fa98c1ac50df9083f20debb81">[詳解]</a><br /></td></tr>
<tr class="separator:a7036a41fa98c1ac50df9083f20debb81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab717df75bed24807c3bd69e7fbc0bae7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a195ff55e2a1512e40becf9f050e6a97a">results_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#ab717df75bed24807c3bd69e7fbc0bae7">resolve</a> (BOOST_ASIO_STRING_VIEW_PARAM host, BOOST_ASIO_STRING_VIEW_PARAM service, resolver_base::flags resolve_flags)</td></tr>
<tr class="memdesc:ab717df75bed24807c3bd69e7fbc0bae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform forward resolution of a query to a list of entries.  <a href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#ab717df75bed24807c3bd69e7fbc0bae7">[詳解]</a><br /></td></tr>
<tr class="separator:ab717df75bed24807c3bd69e7fbc0bae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9704b80774d6919a1710d322d9fa2e37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a195ff55e2a1512e40becf9f050e6a97a">results_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a9704b80774d6919a1710d322d9fa2e37">resolve</a> (BOOST_ASIO_STRING_VIEW_PARAM host, BOOST_ASIO_STRING_VIEW_PARAM service, resolver_base::flags resolve_flags, <a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a9704b80774d6919a1710d322d9fa2e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform forward resolution of a query to a list of entries.  <a href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a9704b80774d6919a1710d322d9fa2e37">[詳解]</a><br /></td></tr>
<tr class="separator:a9704b80774d6919a1710d322d9fa2e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcef4da2d83bdccd2965723686c92eb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a195ff55e2a1512e40becf9f050e6a97a">results_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#abcef4da2d83bdccd2965723686c92eb0">resolve</a> (const <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a0694f56847528e6d427f67967c0df855">protocol_type</a> &amp;protocol, BOOST_ASIO_STRING_VIEW_PARAM host, BOOST_ASIO_STRING_VIEW_PARAM service)</td></tr>
<tr class="memdesc:abcef4da2d83bdccd2965723686c92eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform forward resolution of a query to a list of entries.  <a href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#abcef4da2d83bdccd2965723686c92eb0">[詳解]</a><br /></td></tr>
<tr class="separator:abcef4da2d83bdccd2965723686c92eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a233cf63203ae892d180603b7ff3a60cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a195ff55e2a1512e40becf9f050e6a97a">results_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a233cf63203ae892d180603b7ff3a60cf">resolve</a> (const <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a0694f56847528e6d427f67967c0df855">protocol_type</a> &amp;protocol, BOOST_ASIO_STRING_VIEW_PARAM host, BOOST_ASIO_STRING_VIEW_PARAM service, <a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a233cf63203ae892d180603b7ff3a60cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform forward resolution of a query to a list of entries.  <a href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a233cf63203ae892d180603b7ff3a60cf">[詳解]</a><br /></td></tr>
<tr class="separator:a233cf63203ae892d180603b7ff3a60cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e45f2df6952d27ac9807d76b9f83c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a195ff55e2a1512e40becf9f050e6a97a">results_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a11e45f2df6952d27ac9807d76b9f83c0">resolve</a> (const <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a0694f56847528e6d427f67967c0df855">protocol_type</a> &amp;protocol, BOOST_ASIO_STRING_VIEW_PARAM host, BOOST_ASIO_STRING_VIEW_PARAM service, resolver_base::flags resolve_flags)</td></tr>
<tr class="memdesc:a11e45f2df6952d27ac9807d76b9f83c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform forward resolution of a query to a list of entries.  <a href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a11e45f2df6952d27ac9807d76b9f83c0">[詳解]</a><br /></td></tr>
<tr class="separator:a11e45f2df6952d27ac9807d76b9f83c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dfb80e5267b8ebd2f9a8e4ac4e725ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a195ff55e2a1512e40becf9f050e6a97a">results_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a4dfb80e5267b8ebd2f9a8e4ac4e725ad">resolve</a> (const <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a0694f56847528e6d427f67967c0df855">protocol_type</a> &amp;protocol, BOOST_ASIO_STRING_VIEW_PARAM host, BOOST_ASIO_STRING_VIEW_PARAM service, resolver_base::flags resolve_flags, <a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a4dfb80e5267b8ebd2f9a8e4ac4e725ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform forward resolution of a query to a list of entries.  <a href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a4dfb80e5267b8ebd2f9a8e4ac4e725ad">[詳解]</a><br /></td></tr>
<tr class="separator:a4dfb80e5267b8ebd2f9a8e4ac4e725ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed8eeeb7dbc6e4616212c1dab270416"><td class="memTemplParams" colspan="2">template&lt;BOOST_ASIO_COMPLETION_TOKEN_FOR(void(boost::system::error_code, results_type)) ResolveHandler BOOST_ASIO_DEFAULT_COMPLETION_TOKEN_TYPE(executor_type) &gt; </td></tr>
<tr class="memitem:a0ed8eeeb7dbc6e4616212c1dab270416"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a0ed8eeeb7dbc6e4616212c1dab270416">BOOST_ASIO_INITFN_AUTO_RESULT_TYPE</a> (ResolveHandler, void(<a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>, <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a195ff55e2a1512e40becf9f050e6a97a">results_type</a>)) async_resolve(const <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a399dca14777c0bcc4884c8133967c31d">query</a> &amp;q</td></tr>
<tr class="separator:a0ed8eeeb7dbc6e4616212c1dab270416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57cd891d9b0607d3217cb9ca055d62a5"><td class="memItemLeft" align="right" valign="top"><a id="a57cd891d9b0607d3217cb9ca055d62a5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_ASIO_MOVE_ARG</b> (ResolveHandler) handler BOOST_ASIO_DEFAULT_COMPLETION_TOKEN(<a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a89f64df3455328230d76c27f64ffb40e">executor_type</a>))</td></tr>
<tr class="separator:a57cd891d9b0607d3217cb9ca055d62a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1461864a9727c521ad0a34dd842ed90"><td class="memTemplParams" colspan="2">template&lt;BOOST_ASIO_COMPLETION_TOKEN_FOR(void(boost::system::error_code, results_type)) ResolveHandler BOOST_ASIO_DEFAULT_COMPLETION_TOKEN_TYPE(executor_type) &gt; </td></tr>
<tr class="memitem:af1461864a9727c521ad0a34dd842ed90"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#af1461864a9727c521ad0a34dd842ed90">BOOST_ASIO_INITFN_AUTO_RESULT_TYPE</a> (ResolveHandler, void(<a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>, <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a195ff55e2a1512e40becf9f050e6a97a">results_type</a>)) async_resolve(BOOST_ASIO_STRING_VIEW_PARAM host</td></tr>
<tr class="memdesc:af1461864a9727c521ad0a34dd842ed90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously perform forward resolution of a query to a list of entries.  <a href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#af1461864a9727c521ad0a34dd842ed90">[詳解]</a><br /></td></tr>
<tr class="separator:af1461864a9727c521ad0a34dd842ed90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff47bb2f680b644f3f78461c9d73c656"><td class="memItemLeft" align="right" valign="top"><a id="aff47bb2f680b644f3f78461c9d73c656"></a>
BOOST_ASIO_STRING_VIEW_PARAM&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_ASIO_MOVE_ARG</b> (ResolveHandler) handler BOOST_ASIO_DEFAULT_COMPLETION_TOKEN(<a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a89f64df3455328230d76c27f64ffb40e">executor_type</a>))</td></tr>
<tr class="separator:aff47bb2f680b644f3f78461c9d73c656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1461864a9727c521ad0a34dd842ed90"><td class="memTemplParams" colspan="2">template&lt;BOOST_ASIO_COMPLETION_TOKEN_FOR(void(boost::system::error_code, results_type)) ResolveHandler BOOST_ASIO_DEFAULT_COMPLETION_TOKEN_TYPE(executor_type) &gt; </td></tr>
<tr class="memitem:af1461864a9727c521ad0a34dd842ed90"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#af1461864a9727c521ad0a34dd842ed90">BOOST_ASIO_INITFN_AUTO_RESULT_TYPE</a> (ResolveHandler, void(<a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>, <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a195ff55e2a1512e40becf9f050e6a97a">results_type</a>)) async_resolve(BOOST_ASIO_STRING_VIEW_PARAM host</td></tr>
<tr class="memdesc:af1461864a9727c521ad0a34dd842ed90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously perform forward resolution of a query to a list of entries.  <a href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#af1461864a9727c521ad0a34dd842ed90">[詳解]</a><br /></td></tr>
<tr class="separator:af1461864a9727c521ad0a34dd842ed90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcbce28fb260dcc5564e3894bd2862b3"><td class="memItemLeft" align="right" valign="top"><a id="abcbce28fb260dcc5564e3894bd2862b3"></a>
BOOST_ASIO_STRING_VIEW_PARAM resolver_base::flags&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_ASIO_MOVE_ARG</b> (ResolveHandler) handler BOOST_ASIO_DEFAULT_COMPLETION_TOKEN(<a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a89f64df3455328230d76c27f64ffb40e">executor_type</a>))</td></tr>
<tr class="separator:abcbce28fb260dcc5564e3894bd2862b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3236a23bcf30885b9765c98904ef4fc9"><td class="memTemplParams" colspan="2">template&lt;BOOST_ASIO_COMPLETION_TOKEN_FOR(void(boost::system::error_code, results_type)) ResolveHandler BOOST_ASIO_DEFAULT_COMPLETION_TOKEN_TYPE(executor_type) &gt; </td></tr>
<tr class="memitem:a3236a23bcf30885b9765c98904ef4fc9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a3236a23bcf30885b9765c98904ef4fc9">BOOST_ASIO_INITFN_AUTO_RESULT_TYPE</a> (ResolveHandler, void(<a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>, <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a195ff55e2a1512e40becf9f050e6a97a">results_type</a>)) async_resolve(const <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a0694f56847528e6d427f67967c0df855">protocol_type</a> &amp;protocol</td></tr>
<tr class="memdesc:a3236a23bcf30885b9765c98904ef4fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously perform forward resolution of a query to a list of entries.  <a href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a3236a23bcf30885b9765c98904ef4fc9">[詳解]</a><br /></td></tr>
<tr class="separator:a3236a23bcf30885b9765c98904ef4fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62333935cdef656407295ee4b4d39678"><td class="memItemLeft" align="right" valign="top"><a id="a62333935cdef656407295ee4b4d39678"></a>
BOOST_ASIO_STRING_VIEW_PARAM BOOST_ASIO_STRING_VIEW_PARAM&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_ASIO_MOVE_ARG</b> (ResolveHandler) handler BOOST_ASIO_DEFAULT_COMPLETION_TOKEN(<a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a89f64df3455328230d76c27f64ffb40e">executor_type</a>))</td></tr>
<tr class="separator:a62333935cdef656407295ee4b4d39678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3236a23bcf30885b9765c98904ef4fc9"><td class="memTemplParams" colspan="2">template&lt;BOOST_ASIO_COMPLETION_TOKEN_FOR(void(boost::system::error_code, results_type)) ResolveHandler BOOST_ASIO_DEFAULT_COMPLETION_TOKEN_TYPE(executor_type) &gt; </td></tr>
<tr class="memitem:a3236a23bcf30885b9765c98904ef4fc9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a3236a23bcf30885b9765c98904ef4fc9">BOOST_ASIO_INITFN_AUTO_RESULT_TYPE</a> (ResolveHandler, void(<a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>, <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a195ff55e2a1512e40becf9f050e6a97a">results_type</a>)) async_resolve(const <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a0694f56847528e6d427f67967c0df855">protocol_type</a> &amp;protocol</td></tr>
<tr class="memdesc:a3236a23bcf30885b9765c98904ef4fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously perform forward resolution of a query to a list of entries.  <a href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a3236a23bcf30885b9765c98904ef4fc9">[詳解]</a><br /></td></tr>
<tr class="separator:a3236a23bcf30885b9765c98904ef4fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df45c70e1c7931657094feaa1b7c94e"><td class="memItemLeft" align="right" valign="top"><a id="a0df45c70e1c7931657094feaa1b7c94e"></a>
BOOST_ASIO_STRING_VIEW_PARAM BOOST_ASIO_STRING_VIEW_PARAM resolver_base::flags&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_ASIO_MOVE_ARG</b> (ResolveHandler) handler BOOST_ASIO_DEFAULT_COMPLETION_TOKEN(<a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a89f64df3455328230d76c27f64ffb40e">executor_type</a>))</td></tr>
<tr class="separator:a0df45c70e1c7931657094feaa1b7c94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b1101ddafc29d6f12bdcdf04246cfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a195ff55e2a1512e40becf9f050e6a97a">results_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a62b1101ddafc29d6f12bdcdf04246cfc">resolve</a> (const <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a8f1027fdcfd3e348e7084345c350b11e">endpoint_type</a> &amp;e)</td></tr>
<tr class="memdesc:a62b1101ddafc29d6f12bdcdf04246cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform reverse resolution of an endpoint to a list of entries.  <a href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a62b1101ddafc29d6f12bdcdf04246cfc">[詳解]</a><br /></td></tr>
<tr class="separator:a62b1101ddafc29d6f12bdcdf04246cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10d3319667d82009a8c6208181ac4a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a195ff55e2a1512e40becf9f050e6a97a">results_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#ad10d3319667d82009a8c6208181ac4a4">resolve</a> (const <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a8f1027fdcfd3e348e7084345c350b11e">endpoint_type</a> &amp;e, <a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ad10d3319667d82009a8c6208181ac4a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform reverse resolution of an endpoint to a list of entries.  <a href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#ad10d3319667d82009a8c6208181ac4a4">[詳解]</a><br /></td></tr>
<tr class="separator:ad10d3319667d82009a8c6208181ac4a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21bcce9bc6f3b284760ba65f6b1ebba3"><td class="memTemplParams" colspan="2">template&lt;BOOST_ASIO_COMPLETION_TOKEN_FOR(void(boost::system::error_code, results_type)) ResolveHandler BOOST_ASIO_DEFAULT_COMPLETION_TOKEN_TYPE(executor_type) &gt; </td></tr>
<tr class="memitem:a21bcce9bc6f3b284760ba65f6b1ebba3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a21bcce9bc6f3b284760ba65f6b1ebba3">BOOST_ASIO_INITFN_AUTO_RESULT_TYPE</a> (ResolveHandler, void(<a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>, <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a195ff55e2a1512e40becf9f050e6a97a">results_type</a>)) async_resolve(const <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a8f1027fdcfd3e348e7084345c350b11e">endpoint_type</a> &amp;e</td></tr>
<tr class="separator:a21bcce9bc6f3b284760ba65f6b1ebba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57cd891d9b0607d3217cb9ca055d62a5"><td class="memItemLeft" align="right" valign="top"><a id="a57cd891d9b0607d3217cb9ca055d62a5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_ASIO_MOVE_ARG</b> (ResolveHandler) handler BOOST_ASIO_DEFAULT_COMPLETION_TOKEN(<a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a89f64df3455328230d76c27f64ffb40e">executor_type</a>))</td></tr>
<tr class="separator:a57cd891d9b0607d3217cb9ca055d62a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
公開変数類</h2></td></tr>
<tr class="memitem:aa9fd712626814c967a53a3b078d56b11"><td class="memItemLeft" align="right" valign="top"><a id="aa9fd712626814c967a53a3b078d56b11"></a>
BOOST_ASIO_STRING_VIEW_PARAM&#160;</td><td class="memItemRight" valign="bottom"><b>service</b></td></tr>
<tr class="separator:aa9fd712626814c967a53a3b078d56b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf2ce8d17bc3f413da31e8f3f537fc2"><td class="memItemLeft" align="right" valign="top"><a id="a5bf2ce8d17bc3f413da31e8f3f537fc2"></a>
BOOST_ASIO_STRING_VIEW_PARAM resolver_base::flags&#160;</td><td class="memItemRight" valign="bottom"><b>resolve_flags</b></td></tr>
<tr class="separator:a5bf2ce8d17bc3f413da31e8f3f537fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff55b7b17b3af331bfba7240f5182742"><td class="memItemLeft" align="right" valign="top"><a id="aff55b7b17b3af331bfba7240f5182742"></a>
BOOST_ASIO_STRING_VIEW_PARAM&#160;</td><td class="memItemRight" valign="bottom"><b>host</b></td></tr>
<tr class="separator:aff55b7b17b3af331bfba7240f5182742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9fd712626814c967a53a3b078d56b11"><td class="memItemLeft" align="right" valign="top"><a id="aa9fd712626814c967a53a3b078d56b11"></a>
BOOST_ASIO_STRING_VIEW_PARAM BOOST_ASIO_STRING_VIEW_PARAM&#160;</td><td class="memItemRight" valign="bottom"><b>service</b></td></tr>
<tr class="separator:aa9fd712626814c967a53a3b078d56b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124eb6af956cf100a14e53c77fb942b6"><td class="memItemLeft" align="right" valign="top"><a id="a124eb6af956cf100a14e53c77fb942b6"></a>
BOOST_ASIO_STRING_VIEW_PARAM BOOST_ASIO_STRING_VIEW_PARAM resolver_base::flags&#160;</td><td class="memItemRight" valign="bottom"><b>resolve_flags</b></td></tr>
<tr class="separator:a124eb6af956cf100a14e53c77fb942b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">詳解</h2>
<div class="textblock"><h3>template&lt;typename InternetProtocol, typename Executor&gt;<br />
class boost::asio::ip::basic_resolver&lt; InternetProtocol, Executor &gt;</h3>

<p>Provides endpoint resolution functionality. </p>
<p>The <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html" title="Provides endpoint resolution functionality.">basic_resolver</a> class template provides the ability to resolve a query to a list of endpoints.</p>
<dl class="section user"><dt>Thread Safety</dt><dd><em>Distinct</em> <em>objects:</em> Safe.<br  />
<em>Shared</em> <em>objects:</em> Unsafe. </dd></dl>
</div><h2 class="groupheader">構築子と解体子</h2>
<a id="a912fd93033e67e853311784e49f4bf24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a912fd93033e67e853311784e49f4bf24">&#9670;&nbsp;</a></span>basic_resolver() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html">boost::asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::<a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html">basic_resolver</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a89f64df3455328230d76c27f64ffb40e">executor_type</a> &amp;&#160;</td>
          <td class="paramname"><em>ex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct with executor. </p>
<p>This constructor creates a <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html" title="Provides endpoint resolution functionality.">basic_resolver</a>.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>The I/O executor that the resolver will use, by default, to dispatch handlers for any asynchronous operations performed on the resolver. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04aa8dce1f3bd9ca8afafb77ebc3b608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04aa8dce1f3bd9ca8afafb77ebc3b608">&#9670;&nbsp;</a></span>basic_resolver() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<div class="memtemplate">
template&lt;typename ExecutionContext &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html">boost::asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::<a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html">basic_resolver</a> </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structboost_1_1asio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structboost_1_1is__convertible.html">is_convertible</a>&lt; ExecutionContext &amp;, <a class="el" href="classboost_1_1asio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;::<a class="el" href="structboost_1_1type.html">type</a> *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct with execution context. </p>
<p>This constructor creates a <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html" title="Provides endpoint resolution functionality.">basic_resolver</a>.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>An execution context which provides the I/O executor that the resolver will use, by default, to dispatch handlers for any asynchronous operations performed on the resolver. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad837d51ffec9afc9ca67b23cadf6216a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad837d51ffec9afc9ca67b23cadf6216a">&#9670;&nbsp;</a></span>~basic_resolver()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html">boost::asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::~<a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html">basic_resolver</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the resolver. </p>
<p>This function destroys the resolver, cancelling any outstanding asynchronous wait operations associated with the resolver as if by calling <code>cancel</code>. </p>

</div>
</div>
<h2 class="groupheader">関数詳解</h2>
<a id="af1461864a9727c521ad0a34dd842ed90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1461864a9727c521ad0a34dd842ed90">&#9670;&nbsp;</a></span>BOOST_ASIO_INITFN_AUTO_RESULT_TYPE() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<div class="memtemplate">
template&lt;BOOST_ASIO_COMPLETION_TOKEN_FOR(void(boost::system::error_code, results_type)) ResolveHandler BOOST_ASIO_DEFAULT_COMPLETION_TOKEN_TYPE(executor_type) &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html">boost::asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::BOOST_ASIO_INITFN_AUTO_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">ResolveHandler&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(<a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>, <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a195ff55e2a1512e40becf9f050e6a97a">results_type</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously perform forward resolution of a query to a list of entries. </p>
<p>This function is used to resolve host and service names into a list of endpoint entries.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.</td></tr>
    <tr><td class="paramname">service</td><td>A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the resolve operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>&amp; error, <span class="comment">// Result of operation.</span></div>
<div class="line">  resolver::results_type results <span class="comment">// Resolved endpoints as a range.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using boost::asio::post().</td></tr>
  </table>
  </dd>
</dl>
<p>A successful resolve operation is guaranteed to pass a non-empty range to the handler.</p>
<dl class="section note"><dt>覚え書き</dt><dd>On POSIX systems, host names may be locally defined in the file <code>/etc/hosts</code>. On Windows, host names may be defined in the file <code>c:\windows\system32\drivers\etc\hosts</code>. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).</dd></dl>
<p>On POSIX systems, service names are typically defined in the file <code>/etc/services</code>. On Windows, service names may be found in the file <code>c:\windows\system32\drivers\etc\services</code>. Operating systems may use additional locations when resolving service names. </p>

</div>
</div>
<a id="af1461864a9727c521ad0a34dd842ed90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1461864a9727c521ad0a34dd842ed90">&#9670;&nbsp;</a></span>BOOST_ASIO_INITFN_AUTO_RESULT_TYPE() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<div class="memtemplate">
template&lt;BOOST_ASIO_COMPLETION_TOKEN_FOR(void(boost::system::error_code, results_type)) ResolveHandler BOOST_ASIO_DEFAULT_COMPLETION_TOKEN_TYPE(executor_type) &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html">boost::asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::BOOST_ASIO_INITFN_AUTO_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">ResolveHandler&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(<a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>, <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a195ff55e2a1512e40becf9f050e6a97a">results_type</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously perform forward resolution of a query to a list of entries. </p>
<p>This function is used to resolve host and service names into a list of endpoint entries.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.</td></tr>
    <tr><td class="paramname">service</td><td>A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.</td></tr>
    <tr><td class="paramname">resolve_flags</td><td>A set of flags that determine how name resolution should be performed. The default flags are suitable for communication with remote hosts. See the <a class="el" href="classboost_1_1asio_1_1ip_1_1resolver__base.html">resolver_base</a> documentation for the set of available flags.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the resolve operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>&amp; error, <span class="comment">// Result of operation.</span></div>
<div class="line">  resolver::results_type results <span class="comment">// Resolved endpoints as a range.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using boost::asio::post().</td></tr>
  </table>
  </dd>
</dl>
<p>A successful resolve operation is guaranteed to pass a non-empty range to the handler.</p>
<dl class="section note"><dt>覚え書き</dt><dd>On POSIX systems, host names may be locally defined in the file <code>/etc/hosts</code>. On Windows, host names may be defined in the file <code>c:\windows\system32\drivers\etc\hosts</code>. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).</dd></dl>
<p>On POSIX systems, service names are typically defined in the file <code>/etc/services</code>. On Windows, service names may be found in the file <code>c:\windows\system32\drivers\etc\services</code>. Operating systems may use additional locations when resolving service names. </p>

</div>
</div>
<a id="a21bcce9bc6f3b284760ba65f6b1ebba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21bcce9bc6f3b284760ba65f6b1ebba3">&#9670;&nbsp;</a></span>BOOST_ASIO_INITFN_AUTO_RESULT_TYPE() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<div class="memtemplate">
template&lt;BOOST_ASIO_COMPLETION_TOKEN_FOR(void(boost::system::error_code, results_type)) ResolveHandler BOOST_ASIO_DEFAULT_COMPLETION_TOKEN_TYPE(executor_type) &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html">boost::asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::BOOST_ASIO_INITFN_AUTO_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">ResolveHandler&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(<a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>, <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a195ff55e2a1512e40becf9f050e6a97a">results_type</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Asynchronously perform reverse resolution of an endpoint to a list of entries. This function is used to asynchronously resolve an endpoint into a list of endpoint entries.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>An endpoint object that determines what endpoints will be returned.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the resolve operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>&amp; error, <span class="comment">// Result of operation.</span></div>
<div class="line">  resolver::results_type results <span class="comment">// Resolved endpoints as a range.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using boost::asio::post().</td></tr>
  </table>
  </dd>
</dl>
<p>A successful resolve operation is guaranteed to pass a non-empty range to the handler. </p>

</div>
</div>
<a id="a3236a23bcf30885b9765c98904ef4fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3236a23bcf30885b9765c98904ef4fc9">&#9670;&nbsp;</a></span>BOOST_ASIO_INITFN_AUTO_RESULT_TYPE() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<div class="memtemplate">
template&lt;BOOST_ASIO_COMPLETION_TOKEN_FOR(void(boost::system::error_code, results_type)) ResolveHandler BOOST_ASIO_DEFAULT_COMPLETION_TOKEN_TYPE(executor_type) &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html">boost::asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::BOOST_ASIO_INITFN_AUTO_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">ResolveHandler&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(<a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>, <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a195ff55e2a1512e40becf9f050e6a97a">results_type</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously perform forward resolution of a query to a list of entries. </p>
<p>This function is used to resolve host and service names into a list of endpoint entries.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocol</td><td>A protocol object, normally representing either the IPv4 or IPv6 version of an internet protocol.</td></tr>
    <tr><td class="paramname">host</td><td>A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.</td></tr>
    <tr><td class="paramname">service</td><td>A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the resolve operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>&amp; error, <span class="comment">// Result of operation.</span></div>
<div class="line">  resolver::results_type results <span class="comment">// Resolved endpoints as a range.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using boost::asio::post().</td></tr>
  </table>
  </dd>
</dl>
<p>A successful resolve operation is guaranteed to pass a non-empty range to the handler.</p>
<dl class="section note"><dt>覚え書き</dt><dd>On POSIX systems, host names may be locally defined in the file <code>/etc/hosts</code>. On Windows, host names may be defined in the file <code>c:\windows\system32\drivers\etc\hosts</code>. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).</dd></dl>
<p>On POSIX systems, service names are typically defined in the file <code>/etc/services</code>. On Windows, service names may be found in the file <code>c:\windows\system32\drivers\etc\services</code>. Operating systems may use additional locations when resolving service names. </p>

</div>
</div>
<a id="a3236a23bcf30885b9765c98904ef4fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3236a23bcf30885b9765c98904ef4fc9">&#9670;&nbsp;</a></span>BOOST_ASIO_INITFN_AUTO_RESULT_TYPE() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<div class="memtemplate">
template&lt;BOOST_ASIO_COMPLETION_TOKEN_FOR(void(boost::system::error_code, results_type)) ResolveHandler BOOST_ASIO_DEFAULT_COMPLETION_TOKEN_TYPE(executor_type) &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html">boost::asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::BOOST_ASIO_INITFN_AUTO_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">ResolveHandler&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(<a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>, <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a195ff55e2a1512e40becf9f050e6a97a">results_type</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously perform forward resolution of a query to a list of entries. </p>
<p>This function is used to resolve host and service names into a list of endpoint entries.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocol</td><td>A protocol object, normally representing either the IPv4 or IPv6 version of an internet protocol.</td></tr>
    <tr><td class="paramname">host</td><td>A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.</td></tr>
    <tr><td class="paramname">service</td><td>A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.</td></tr>
    <tr><td class="paramname">resolve_flags</td><td>A set of flags that determine how name resolution should be performed. The default flags are suitable for communication with remote hosts. See the <a class="el" href="classboost_1_1asio_1_1ip_1_1resolver__base.html">resolver_base</a> documentation for the set of available flags.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the resolve operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>&amp; error, <span class="comment">// Result of operation.</span></div>
<div class="line">  resolver::results_type results <span class="comment">// Resolved endpoints as a range.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using boost::asio::post().</td></tr>
  </table>
  </dd>
</dl>
<p>A successful resolve operation is guaranteed to pass a non-empty range to the handler.</p>
<dl class="section note"><dt>覚え書き</dt><dd>On POSIX systems, host names may be locally defined in the file <code>/etc/hosts</code>. On Windows, host names may be defined in the file <code>c:\windows\system32\drivers\etc\hosts</code>. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).</dd></dl>
<p>On POSIX systems, service names are typically defined in the file <code>/etc/services</code>. On Windows, service names may be found in the file <code>c:\windows\system32\drivers\etc\services</code>. Operating systems may use additional locations when resolving service names. </p>

</div>
</div>
<a id="a0ed8eeeb7dbc6e4616212c1dab270416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed8eeeb7dbc6e4616212c1dab270416">&#9670;&nbsp;</a></span>BOOST_ASIO_INITFN_AUTO_RESULT_TYPE() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<div class="memtemplate">
template&lt;BOOST_ASIO_COMPLETION_TOKEN_FOR(void(boost::system::error_code, results_type)) ResolveHandler BOOST_ASIO_DEFAULT_COMPLETION_TOKEN_TYPE(executor_type) &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html">boost::asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::BOOST_ASIO_INITFN_AUTO_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">ResolveHandler&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(<a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>, <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a195ff55e2a1512e40becf9f050e6a97a">results_type</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>(Deprecated: Use overload with separate host and service parameters.) Asynchronously perform forward resolution of a query to a list of entries. This function is used to asynchronously resolve a query into a list of endpoint entries.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>A query object that determines what endpoints will be returned.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the resolve operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>&amp; error, <span class="comment">// Result of operation.</span></div>
<div class="line">  resolver::results_type results <span class="comment">// Resolved endpoints as a range.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using boost::asio::post().</td></tr>
  </table>
  </dd>
</dl>
<p>A successful resolve operation is guaranteed to pass a non-empty range to the handler. </p>

</div>
</div>
<a id="a6c1232a1ac86579a3ad0dc64d1d581d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c1232a1ac86579a3ad0dc64d1d581d2">&#9670;&nbsp;</a></span>cancel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html">boost::asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::cancel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel any asynchronous operations that are waiting on the resolver. </p>
<p>This function forces the completion of any pending asynchronous operations on the host resolver. The handler for each cancelled operation will be invoked with the boost::asio::error::operation_aborted error code. </p>

</div>
</div>
<a id="aab720ef7aa8d98e53988fc54678dac0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab720ef7aa8d98e53988fc54678dac0c">&#9670;&nbsp;</a></span>resolve() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a195ff55e2a1512e40becf9f050e6a97a">results_type</a> <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html">boost::asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::resolve </td>
          <td>(</td>
          <td class="paramtype">BOOST_ASIO_STRING_VIEW_PARAM&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOST_ASIO_STRING_VIEW_PARAM&#160;</td>
          <td class="paramname"><em>service</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform forward resolution of a query to a list of entries. </p>
<p>This function is used to resolve host and service names into a list of endpoint entries.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.</td></tr>
    <tr><td class="paramname">service</td><td>A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>A range object representing the list of endpoint entries. A successful call to this function is guaranteed to return a non-empty range.</dd></dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classboost_1_1system_1_1system__error.html">boost::system::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>On POSIX systems, host names may be locally defined in the file <code>/etc/hosts</code>. On Windows, host names may be defined in the file <code>c:\windows\system32\drivers\etc\hosts</code>. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).</dd></dl>
<p>On POSIX systems, service names are typically defined in the file <code>/etc/services</code>. On Windows, service names may be found in the file <code>c:\windows\system32\drivers\etc\services</code>. Operating systems may use additional locations when resolving service names. </p>

</div>
</div>
<a id="a7036a41fa98c1ac50df9083f20debb81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7036a41fa98c1ac50df9083f20debb81">&#9670;&nbsp;</a></span>resolve() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a195ff55e2a1512e40becf9f050e6a97a">results_type</a> <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html">boost::asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::resolve </td>
          <td>(</td>
          <td class="paramtype">BOOST_ASIO_STRING_VIEW_PARAM&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOST_ASIO_STRING_VIEW_PARAM&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform forward resolution of a query to a list of entries. </p>
<p>This function is used to resolve host and service names into a list of endpoint entries.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.</td></tr>
    <tr><td class="paramname">service</td><td>A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>A range object representing the list of endpoint entries. An empty range is returned if an error occurs. A successful call to this function is guaranteed to return a non-empty range.</dd></dl>
<dl class="section note"><dt>覚え書き</dt><dd>On POSIX systems, host names may be locally defined in the file <code>/etc/hosts</code>. On Windows, host names may be defined in the file <code>c:\windows\system32\drivers\etc\hosts</code>. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).</dd></dl>
<p>On POSIX systems, service names are typically defined in the file <code>/etc/services</code>. On Windows, service names may be found in the file <code>c:\windows\system32\drivers\etc\services</code>. Operating systems may use additional locations when resolving service names. </p>

</div>
</div>
<a id="ab717df75bed24807c3bd69e7fbc0bae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab717df75bed24807c3bd69e7fbc0bae7">&#9670;&nbsp;</a></span>resolve() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a195ff55e2a1512e40becf9f050e6a97a">results_type</a> <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html">boost::asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::resolve </td>
          <td>(</td>
          <td class="paramtype">BOOST_ASIO_STRING_VIEW_PARAM&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOST_ASIO_STRING_VIEW_PARAM&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">resolver_base::flags&#160;</td>
          <td class="paramname"><em>resolve_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform forward resolution of a query to a list of entries. </p>
<p>This function is used to resolve host and service names into a list of endpoint entries.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.</td></tr>
    <tr><td class="paramname">service</td><td>A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.</td></tr>
    <tr><td class="paramname">resolve_flags</td><td>A set of flags that determine how name resolution should be performed. The default flags are suitable for communication with remote hosts. See the <a class="el" href="classboost_1_1asio_1_1ip_1_1resolver__base.html">resolver_base</a> documentation for the set of available flags.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>A range object representing the list of endpoint entries. A successful call to this function is guaranteed to return a non-empty range.</dd></dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classboost_1_1system_1_1system__error.html">boost::system::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>On POSIX systems, host names may be locally defined in the file <code>/etc/hosts</code>. On Windows, host names may be defined in the file <code>c:\windows\system32\drivers\etc\hosts</code>. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).</dd></dl>
<p>On POSIX systems, service names are typically defined in the file <code>/etc/services</code>. On Windows, service names may be found in the file <code>c:\windows\system32\drivers\etc\services</code>. Operating systems may use additional locations when resolving service names. </p>

</div>
</div>
<a id="a9704b80774d6919a1710d322d9fa2e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9704b80774d6919a1710d322d9fa2e37">&#9670;&nbsp;</a></span>resolve() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a195ff55e2a1512e40becf9f050e6a97a">results_type</a> <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html">boost::asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::resolve </td>
          <td>(</td>
          <td class="paramtype">BOOST_ASIO_STRING_VIEW_PARAM&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOST_ASIO_STRING_VIEW_PARAM&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">resolver_base::flags&#160;</td>
          <td class="paramname"><em>resolve_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform forward resolution of a query to a list of entries. </p>
<p>This function is used to resolve host and service names into a list of endpoint entries.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.</td></tr>
    <tr><td class="paramname">service</td><td>A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.</td></tr>
    <tr><td class="paramname">resolve_flags</td><td>A set of flags that determine how name resolution should be performed. The default flags are suitable for communication with remote hosts. See the <a class="el" href="classboost_1_1asio_1_1ip_1_1resolver__base.html">resolver_base</a> documentation for the set of available flags.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>A range object representing the list of endpoint entries. An empty range is returned if an error occurs. A successful call to this function is guaranteed to return a non-empty range.</dd></dl>
<dl class="section note"><dt>覚え書き</dt><dd>On POSIX systems, host names may be locally defined in the file <code>/etc/hosts</code>. On Windows, host names may be defined in the file <code>c:\windows\system32\drivers\etc\hosts</code>. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).</dd></dl>
<p>On POSIX systems, service names are typically defined in the file <code>/etc/services</code>. On Windows, service names may be found in the file <code>c:\windows\system32\drivers\etc\services</code>. Operating systems may use additional locations when resolving service names. </p>

</div>
</div>
<a id="a62b1101ddafc29d6f12bdcdf04246cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b1101ddafc29d6f12bdcdf04246cfc">&#9670;&nbsp;</a></span>resolve() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a195ff55e2a1512e40becf9f050e6a97a">results_type</a> <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html">boost::asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::resolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a8f1027fdcfd3e348e7084345c350b11e">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform reverse resolution of an endpoint to a list of entries. </p>
<p>This function is used to resolve an endpoint into a list of endpoint entries.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>An endpoint object that determines what endpoints will be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>A range object representing the list of endpoint entries. A successful call to this function is guaranteed to return a non-empty range.</dd></dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classboost_1_1system_1_1system__error.html">boost::system::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad10d3319667d82009a8c6208181ac4a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad10d3319667d82009a8c6208181ac4a4">&#9670;&nbsp;</a></span>resolve() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a195ff55e2a1512e40becf9f050e6a97a">results_type</a> <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html">boost::asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::resolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a8f1027fdcfd3e348e7084345c350b11e">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform reverse resolution of an endpoint to a list of entries. </p>
<p>This function is used to resolve an endpoint into a list of endpoint entries.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>An endpoint object that determines what endpoints will be returned.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>A range object representing the list of endpoint entries. An empty range is returned if an error occurs. A successful call to this function is guaranteed to return a non-empty range. </dd></dl>

</div>
</div>
<a id="abcef4da2d83bdccd2965723686c92eb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcef4da2d83bdccd2965723686c92eb0">&#9670;&nbsp;</a></span>resolve() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a195ff55e2a1512e40becf9f050e6a97a">results_type</a> <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html">boost::asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::resolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a0694f56847528e6d427f67967c0df855">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOST_ASIO_STRING_VIEW_PARAM&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOST_ASIO_STRING_VIEW_PARAM&#160;</td>
          <td class="paramname"><em>service</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform forward resolution of a query to a list of entries. </p>
<p>This function is used to resolve host and service names into a list of endpoint entries.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocol</td><td>A protocol object, normally representing either the IPv4 or IPv6 version of an internet protocol.</td></tr>
    <tr><td class="paramname">host</td><td>A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.</td></tr>
    <tr><td class="paramname">service</td><td>A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>A range object representing the list of endpoint entries. A successful call to this function is guaranteed to return a non-empty range.</dd></dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classboost_1_1system_1_1system__error.html">boost::system::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>On POSIX systems, host names may be locally defined in the file <code>/etc/hosts</code>. On Windows, host names may be defined in the file <code>c:\windows\system32\drivers\etc\hosts</code>. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).</dd></dl>
<p>On POSIX systems, service names are typically defined in the file <code>/etc/services</code>. On Windows, service names may be found in the file <code>c:\windows\system32\drivers\etc\services</code>. Operating systems may use additional locations when resolving service names. </p>

</div>
</div>
<a id="a233cf63203ae892d180603b7ff3a60cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a233cf63203ae892d180603b7ff3a60cf">&#9670;&nbsp;</a></span>resolve() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a195ff55e2a1512e40becf9f050e6a97a">results_type</a> <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html">boost::asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::resolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a0694f56847528e6d427f67967c0df855">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOST_ASIO_STRING_VIEW_PARAM&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOST_ASIO_STRING_VIEW_PARAM&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform forward resolution of a query to a list of entries. </p>
<p>This function is used to resolve host and service names into a list of endpoint entries.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocol</td><td>A protocol object, normally representing either the IPv4 or IPv6 version of an internet protocol.</td></tr>
    <tr><td class="paramname">host</td><td>A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.</td></tr>
    <tr><td class="paramname">service</td><td>A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>A range object representing the list of endpoint entries. An empty range is returned if an error occurs. A successful call to this function is guaranteed to return a non-empty range.</dd></dl>
<dl class="section note"><dt>覚え書き</dt><dd>On POSIX systems, host names may be locally defined in the file <code>/etc/hosts</code>. On Windows, host names may be defined in the file <code>c:\windows\system32\drivers\etc\hosts</code>. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).</dd></dl>
<p>On POSIX systems, service names are typically defined in the file <code>/etc/services</code>. On Windows, service names may be found in the file <code>c:\windows\system32\drivers\etc\services</code>. Operating systems may use additional locations when resolving service names. </p>

</div>
</div>
<a id="a11e45f2df6952d27ac9807d76b9f83c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11e45f2df6952d27ac9807d76b9f83c0">&#9670;&nbsp;</a></span>resolve() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a195ff55e2a1512e40becf9f050e6a97a">results_type</a> <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html">boost::asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::resolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a0694f56847528e6d427f67967c0df855">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOST_ASIO_STRING_VIEW_PARAM&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOST_ASIO_STRING_VIEW_PARAM&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">resolver_base::flags&#160;</td>
          <td class="paramname"><em>resolve_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform forward resolution of a query to a list of entries. </p>
<p>This function is used to resolve host and service names into a list of endpoint entries.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocol</td><td>A protocol object, normally representing either the IPv4 or IPv6 version of an internet protocol.</td></tr>
    <tr><td class="paramname">host</td><td>A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.</td></tr>
    <tr><td class="paramname">service</td><td>A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.</td></tr>
    <tr><td class="paramname">resolve_flags</td><td>A set of flags that determine how name resolution should be performed. The default flags are suitable for communication with remote hosts. See the <a class="el" href="classboost_1_1asio_1_1ip_1_1resolver__base.html">resolver_base</a> documentation for the set of available flags.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>A range object representing the list of endpoint entries. A successful call to this function is guaranteed to return a non-empty range.</dd></dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classboost_1_1system_1_1system__error.html">boost::system::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>On POSIX systems, host names may be locally defined in the file <code>/etc/hosts</code>. On Windows, host names may be defined in the file <code>c:\windows\system32\drivers\etc\hosts</code>. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).</dd></dl>
<p>On POSIX systems, service names are typically defined in the file <code>/etc/services</code>. On Windows, service names may be found in the file <code>c:\windows\system32\drivers\etc\services</code>. Operating systems may use additional locations when resolving service names. </p>

</div>
</div>
<a id="a4dfb80e5267b8ebd2f9a8e4ac4e725ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dfb80e5267b8ebd2f9a8e4ac4e725ad">&#9670;&nbsp;</a></span>resolve() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a195ff55e2a1512e40becf9f050e6a97a">results_type</a> <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html">boost::asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::resolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a0694f56847528e6d427f67967c0df855">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOST_ASIO_STRING_VIEW_PARAM&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOST_ASIO_STRING_VIEW_PARAM&#160;</td>
          <td class="paramname"><em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">resolver_base::flags&#160;</td>
          <td class="paramname"><em>resolve_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform forward resolution of a query to a list of entries. </p>
<p>This function is used to resolve host and service names into a list of endpoint entries.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocol</td><td>A protocol object, normally representing either the IPv4 or IPv6 version of an internet protocol.</td></tr>
    <tr><td class="paramname">host</td><td>A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.</td></tr>
    <tr><td class="paramname">service</td><td>A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.</td></tr>
    <tr><td class="paramname">resolve_flags</td><td>A set of flags that determine how name resolution should be performed. The default flags are suitable for communication with remote hosts. See the <a class="el" href="classboost_1_1asio_1_1ip_1_1resolver__base.html">resolver_base</a> documentation for the set of available flags.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>A range object representing the list of endpoint entries. An empty range is returned if an error occurs. A successful call to this function is guaranteed to return a non-empty range.</dd></dl>
<dl class="section note"><dt>覚え書き</dt><dd>On POSIX systems, host names may be locally defined in the file <code>/etc/hosts</code>. On Windows, host names may be defined in the file <code>c:\windows\system32\drivers\etc\hosts</code>. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).</dd></dl>
<p>On POSIX systems, service names are typically defined in the file <code>/etc/services</code>. On Windows, service names may be found in the file <code>c:\windows\system32\drivers\etc\services</code>. Operating systems may use additional locations when resolving service names. </p>

</div>
</div>
<a id="a5aec94df9a9f1714d6a46d2f8c276b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aec94df9a9f1714d6a46d2f8c276b3a">&#9670;&nbsp;</a></span>resolve() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a195ff55e2a1512e40becf9f050e6a97a">results_type</a> <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html">boost::asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::resolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a399dca14777c0bcc4884c8133967c31d">query</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>(Deprecated: Use overload with separate host and service parameters.) Perform forward resolution of a query to a list of entries. This function is used to resolve a query into a list of endpoint entries.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>A query object that determines what endpoints will be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>A range object representing the list of endpoint entries. A successful call to this function is guaranteed to return a non-empty range.</dd></dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classboost_1_1system_1_1system__error.html">boost::system::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae05ef3e6fc554d4491cab3189fb889c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae05ef3e6fc554d4491cab3189fb889c8">&#9670;&nbsp;</a></span>resolve() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InternetProtocol , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a195ff55e2a1512e40becf9f050e6a97a">results_type</a> <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html">boost::asio::ip::basic_resolver</a>&lt; InternetProtocol, Executor &gt;::resolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html#a399dca14777c0bcc4884c8133967c31d">query</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>(Deprecated: Use overload with separate host and service parameters.) Perform forward resolution of a query to a list of entries. This function is used to resolve a query into a list of endpoint entries.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>A query object that determines what endpoints will be returned.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>A range object representing the list of endpoint entries. An empty range is returned if an error occurs. A successful call to this function is guaranteed to return a non-empty range. </dd></dl>

</div>
</div>
<hr/>このクラス詳解は次のファイルから抽出されました:<ul>
<li>include/external/boost/boost/asio/ip/<a class="el" href="basic__resolver_8hpp_source.html">basic_resolver.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="aclassboost_1_1system_1_1error__code_html"><div class="ttname"><a href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a></div><div class="ttdef"><b>Definition:</b> error_code.hpp:571</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceboost.html">boost</a></li><li class="navelem"><b>asio</b></li><li class="navelem"><b>ip</b></li><li class="navelem"><a class="el" href="classboost_1_1asio_1_1ip_1_1basic__resolver.html">basic_resolver</a></li>
    <li class="footer">構築:
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
