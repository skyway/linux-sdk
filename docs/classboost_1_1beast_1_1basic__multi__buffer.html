<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
<head>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
        'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
        })(window,document,'script','dataLayer','GTM-NN5JX4B');</script>
    <!-- End Google Tag Manager -->
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=11"/>
    <meta name="generator" content="Doxygen 1.9.8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>SkyWay Linux SDK</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="resize.js"></script>
    <script type="text/javascript" src="navtreedata.js"></script>
    <script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="search/searchdata.js"></script>
    <script type="text/javascript" src="search/search.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NN5JX4B"
        height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
            <tbody>
                <tr id="projectrow">
                    <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
                    <td id="projectalign">
                        <div id="projectname">SkyWay Linux SDK
                        </div>
                    </td>
                </tr>
            </tbody>
        </table>
    </div><!-- 構築: Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'検索');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','検索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classboost_1_1beast_1_1basic__multi__buffer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">クラス</a> &#124;
<a href="#pub-types">公開型</a> &#124;
<a href="#pub-methods">公開メンバ関数</a> &#124;
<a href="#friends">フレンド</a> &#124;
<a href="classboost_1_1beast_1_1basic__multi__buffer-members.html">全メンバ一覧</a>  </div>
  <div class="headertitle">
<div class="title">boost::beast::basic_multi_buffer&lt; Allocator &gt; クラステンプレート</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="multi__buffer_8hpp_source.html">multi_buffer.hpp</a>&gt;</code></p>
<div class="dynheader">
boost::beast::basic_multi_buffer&lt; Allocator &gt; の継承関係図</div>
<div class="dyncontent">
 <div class="center">
  <img src="classboost_1_1beast_1_1basic__multi__buffer.png" usemap="#boost::beast::basic_5Fmulti_5Fbuffer_3C_20Allocator_20_3E_map" alt=""/>
  <map id="boost::beast::basic_5Fmulti_5Fbuffer_3C_20Allocator_20_3E_map" name="boost::beast::basic_5Fmulti_5Fbuffer_3C_20Allocator_20_3E_map">
<area href="classboost_1_1empty___1_1empty__value.html" alt="boost::empty_::empty_value&lt; T, N, E &gt;" shape="rect" coords="0,0,262,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
クラス</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer_1_1subrange.html">subrange</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer_1_1subrange_3_01is_mutable_01_4.html">subrange&lt; isMutable &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
公開型</h2></td></tr>
<tr class="memitem:a5247f4edeea069ff3987a8133ea553f7"><td class="memItemLeft" align="right" valign="top"><a id="a5247f4edeea069ff3987a8133ea553f7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_buffers_type</b> = <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer_1_1subrange.html">subrange</a>&lt; false &gt;</td></tr>
<tr class="separator:a5247f4edeea069ff3987a8133ea553f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ce92101d20493830337a84a432ab32"><td class="memItemLeft" align="right" valign="top"><a id="ad0ce92101d20493830337a84a432ab32"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>mutable_buffers_type</b> = <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer_1_1subrange.html">subrange</a>&lt; true &gt;</td></tr>
<tr class="separator:ad0ce92101d20493830337a84a432ab32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea22101191464131a115472d6bdd9634"><td class="memItemLeft" align="right" valign="top"><a id="aea22101191464131a115472d6bdd9634"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#aea22101191464131a115472d6bdd9634">allocator_type</a> = Allocator</td></tr>
<tr class="memdesc:aea22101191464131a115472d6bdd9634"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of allocator used. <br /></td></tr>
<tr class="separator:aea22101191464131a115472d6bdd9634"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
公開メンバ関数</h2></td></tr>
<tr class="memitem:a1b09a7cfb5b0ffe15ba30b7f7ec88a3f"><td class="memItemLeft" align="right" valign="top"><a id="a1b09a7cfb5b0ffe15ba30b7f7ec88a3f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a1b09a7cfb5b0ffe15ba30b7f7ec88a3f">~basic_multi_buffer</a> ()</td></tr>
<tr class="memdesc:a1b09a7cfb5b0ffe15ba30b7f7ec88a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor <br /></td></tr>
<tr class="separator:a1b09a7cfb5b0ffe15ba30b7f7ec88a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c5fae0557e156ed23abb2e23ba73fa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#ad4c5fae0557e156ed23abb2e23ba73fa">basic_multi_buffer</a> () noexcept(default_nothrow)</td></tr>
<tr class="separator:ad4c5fae0557e156ed23abb2e23ba73fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7519bdfb2164b0c106b17965dfc3cf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a1d7519bdfb2164b0c106b17965dfc3cf">basic_multi_buffer</a> (std::size_t limit) noexcept(default_nothrow)</td></tr>
<tr class="separator:a1d7519bdfb2164b0c106b17965dfc3cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b6fc6e56a98d76fe22b4c345a7b980"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#ab2b6fc6e56a98d76fe22b4c345a7b980">basic_multi_buffer</a> (Allocator const &amp;alloc) noexcept</td></tr>
<tr class="separator:ab2b6fc6e56a98d76fe22b4c345a7b980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e25b5d82a92f23f393513828d5e65d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a99e25b5d82a92f23f393513828d5e65d">basic_multi_buffer</a> (std::size_t limit, Allocator const &amp;alloc) noexcept</td></tr>
<tr class="separator:a99e25b5d82a92f23f393513828d5e65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09bb97199c795210d77b2fee99b4ec4e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a09bb97199c795210d77b2fee99b4ec4e">basic_multi_buffer</a> (<a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">basic_multi_buffer</a> &amp;&amp;other) noexcept</td></tr>
<tr class="separator:a09bb97199c795210d77b2fee99b4ec4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77bbf728af4cab0fc0b5e50e04e043e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a77bbf728af4cab0fc0b5e50e04e043e3">basic_multi_buffer</a> (<a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">basic_multi_buffer</a> &amp;&amp;other, Allocator const &amp;alloc)</td></tr>
<tr class="separator:a77bbf728af4cab0fc0b5e50e04e043e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38b65000108e015204d9fa56e914a6d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#ad38b65000108e015204d9fa56e914a6d">basic_multi_buffer</a> (<a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">basic_multi_buffer</a> const &amp;other)</td></tr>
<tr class="separator:ad38b65000108e015204d9fa56e914a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd15be8e4777b2c8a968e65935b3c33"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a4dd15be8e4777b2c8a968e65935b3c33">basic_multi_buffer</a> (<a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">basic_multi_buffer</a> const &amp;other, Allocator const &amp;alloc)</td></tr>
<tr class="separator:a4dd15be8e4777b2c8a968e65935b3c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f35ea7a15d8ed1ebab8e9dfc33b8f2"><td class="memTemplParams" colspan="2">template&lt;class OtherAlloc &gt; </td></tr>
<tr class="memitem:ab2f35ea7a15d8ed1ebab8e9dfc33b8f2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#ab2f35ea7a15d8ed1ebab8e9dfc33b8f2">basic_multi_buffer</a> (<a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">basic_multi_buffer</a>&lt; OtherAlloc &gt; const &amp;other)</td></tr>
<tr class="separator:ab2f35ea7a15d8ed1ebab8e9dfc33b8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6692b7c3bbd740699bb69492395b05"><td class="memTemplParams" colspan="2">template&lt;class OtherAlloc &gt; </td></tr>
<tr class="memitem:acd6692b7c3bbd740699bb69492395b05"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#acd6692b7c3bbd740699bb69492395b05">basic_multi_buffer</a> (<a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">basic_multi_buffer</a>&lt; OtherAlloc &gt; const &amp;other, <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#aea22101191464131a115472d6bdd9634">allocator_type</a> const &amp;alloc)</td></tr>
<tr class="separator:acd6692b7c3bbd740699bb69492395b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5653bde07b215af7cd3a96cd2c95960d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">basic_multi_buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a5653bde07b215af7cd3a96cd2c95960d">operator=</a> (<a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">basic_multi_buffer</a> &amp;&amp;other)</td></tr>
<tr class="separator:a5653bde07b215af7cd3a96cd2c95960d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472edd9353ae62b2558b4d271d61b345"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">basic_multi_buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a472edd9353ae62b2558b4d271d61b345">operator=</a> (<a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">basic_multi_buffer</a> const &amp;other)</td></tr>
<tr class="separator:a472edd9353ae62b2558b4d271d61b345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc233cc16a3b20edef6b3e631880180a"><td class="memTemplParams" colspan="2">template&lt;class OtherAlloc &gt; </td></tr>
<tr class="memitem:acc233cc16a3b20edef6b3e631880180a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">basic_multi_buffer</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#acc233cc16a3b20edef6b3e631880180a">operator=</a> (<a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">basic_multi_buffer</a>&lt; OtherAlloc &gt; const &amp;other)</td></tr>
<tr class="separator:acc233cc16a3b20edef6b3e631880180a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46740a22435cfd29508d8cd71e4939b"><td class="memItemLeft" align="right" valign="top"><a id="ad46740a22435cfd29508d8cd71e4939b"></a>
<a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#aea22101191464131a115472d6bdd9634">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#ad46740a22435cfd29508d8cd71e4939b">get_allocator</a> () const</td></tr>
<tr class="memdesc:ad46740a22435cfd29508d8cd71e4939b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the allocator used. <br /></td></tr>
<tr class="separator:ad46740a22435cfd29508d8cd71e4939b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b8e8e24df75c6b714dbe29521a2f05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a14b8e8e24df75c6b714dbe29521a2f05">max_size</a> (std::size_t n) noexcept</td></tr>
<tr class="separator:a14b8e8e24df75c6b714dbe29521a2f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34026867fee11cb2be10f1f5bbfb4840"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a34026867fee11cb2be10f1f5bbfb4840">reserve</a> (std::size_t n)</td></tr>
<tr class="separator:a34026867fee11cb2be10f1f5bbfb4840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a236b685accb089dc4b469513a288c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a70a236b685accb089dc4b469513a288c">shrink_to_fit</a> ()</td></tr>
<tr class="separator:a70a236b685accb089dc4b469513a288c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbacd096aa3236e5ff69b0e7e9adfce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a9cbacd096aa3236e5ff69b0e7e9adfce">clear</a> () noexcept</td></tr>
<tr class="separator:a9cbacd096aa3236e5ff69b0e7e9adfce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7d04d833001ca47275478ce14f54cc"><td class="memItemLeft" align="right" valign="top"><a id="a1c7d04d833001ca47275478ce14f54cc"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a1c7d04d833001ca47275478ce14f54cc">size</a> () const noexcept</td></tr>
<tr class="memdesc:a1c7d04d833001ca47275478ce14f54cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of readable bytes. <br /></td></tr>
<tr class="separator:a1c7d04d833001ca47275478ce14f54cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea0f5a9b6f091b2330ac7848b1c3cfb"><td class="memItemLeft" align="right" valign="top"><a id="a9ea0f5a9b6f091b2330ac7848b1c3cfb"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a9ea0f5a9b6f091b2330ac7848b1c3cfb">max_size</a> () const noexcept</td></tr>
<tr class="memdesc:a9ea0f5a9b6f091b2330ac7848b1c3cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum number of bytes, both readable and writable, that can ever be held. <br /></td></tr>
<tr class="separator:a9ea0f5a9b6f091b2330ac7848b1c3cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0ea59be121e9c798e773532a8ebe6f"><td class="memItemLeft" align="right" valign="top"><a id="aaf0ea59be121e9c798e773532a8ebe6f"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#aaf0ea59be121e9c798e773532a8ebe6f">capacity</a> () const noexcept</td></tr>
<tr class="memdesc:aaf0ea59be121e9c798e773532a8ebe6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum number of bytes, both readable and writable, that can be held without requiring an allocation. <br /></td></tr>
<tr class="separator:aaf0ea59be121e9c798e773532a8ebe6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e71ca9869c2ea45655ae718437250f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer_1_1subrange.html">const_buffers_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a52e71ca9869c2ea45655ae718437250f">data</a> () const noexcept</td></tr>
<tr class="separator:a52e71ca9869c2ea45655ae718437250f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad5d6b7c6a4e033e1c329ba8cf274ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer_1_1subrange.html">const_buffers_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a7ad5d6b7c6a4e033e1c329ba8cf274ef">cdata</a> () const noexcept</td></tr>
<tr class="separator:a7ad5d6b7c6a4e033e1c329ba8cf274ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bbd30414fa0be23e70053d3c991bff5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer_1_1subrange.html">mutable_buffers_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a4bbd30414fa0be23e70053d3c991bff5">data</a> () noexcept</td></tr>
<tr class="separator:a4bbd30414fa0be23e70053d3c991bff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51eb183ba0daf9e4c94dd6b8d045f070"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer_1_1subrange.html">mutable_buffers_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a51eb183ba0daf9e4c94dd6b8d045f070">prepare</a> (size_type n)</td></tr>
<tr class="separator:a51eb183ba0daf9e4c94dd6b8d045f070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c380fdf77c5d5ef5aae090ba80ecdf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a75c380fdf77c5d5ef5aae090ba80ecdf">commit</a> (size_type n) noexcept</td></tr>
<tr class="separator:a75c380fdf77c5d5ef5aae090ba80ecdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3e2942f0eae34090638b77521896ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a9c3e2942f0eae34090638b77521896ef">consume</a> (size_type n) noexcept</td></tr>
<tr class="separator:a9c3e2942f0eae34090638b77521896ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a1b6934f8f64a81678b278c9f7687e"><td class="memTemplParams" colspan="2"><a id="a17a1b6934f8f64a81678b278c9f7687e"></a>
template&lt;class OtherAlloc &gt; </td></tr>
<tr class="memitem:a17a1b6934f8f64a81678b278c9f7687e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">basic_multi_buffer</a>&lt; OtherAlloc &gt; const &amp;other) -&gt; <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">basic_multi_buffer</a> &amp;</td></tr>
<tr class="separator:a17a1b6934f8f64a81678b278c9f7687e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
フレンド</h2></td></tr>
<tr class="memitem:a9d87536bfed92ec648af020519e66006"><td class="memTemplParams" colspan="2"><a id="a9d87536bfed92ec648af020519e66006"></a>
template&lt;class Alloc &gt; </td></tr>
<tr class="memitem:a9d87536bfed92ec648af020519e66006"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a9d87536bfed92ec648af020519e66006">swap</a> (<a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">basic_multi_buffer</a>&lt; Alloc &gt; &amp;lhs, <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">basic_multi_buffer</a>&lt; Alloc &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a9d87536bfed92ec648af020519e66006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchange two dynamic buffers <br /></td></tr>
<tr class="separator:a9d87536bfed92ec648af020519e66006"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">詳解</h2>
<div class="textblock"><h3>template&lt;class Allocator&gt;<br />
class boost::beast::basic_multi_buffer&lt; Allocator &gt;</h3>

<p>A dynamic buffer providing sequences of variable length.</p>
<p>A dynamic buffer encapsulates memory storage that may be automatically resized as required, where the memory is divided into two regions: readable bytes followed by writable bytes. These memory regions are internal to the dynamic buffer, but direct access to the elements is provided to permit them to be efficiently used with I/O operations.</p>
<p>The implementation uses a sequence of one or more byte arrays of varying sizes to represent the readable and writable bytes. Additional byte array objects are appended to the sequence to accommodate changes in the desired size. The behavior and implementation of this container is most similar to <code>std::deque</code>.</p>
<p>Objects of this type meet the requirements of <em>DynamicBuffer</em> and have the following additional properties:</p>
<ul>
<li>A mutable buffer sequence representing the readable bytes is returned by <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a52e71ca9869c2ea45655ae718437250f">data</a> when <code>this</code> is non-const.</li>
</ul>
<ul>
<li>Buffer sequences representing the readable and writable bytes, returned by <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a52e71ca9869c2ea45655ae718437250f">data</a> and <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a51eb183ba0daf9e4c94dd6b8d045f070">prepare</a>, may have length greater than one.</li>
</ul>
<ul>
<li>A configurable maximum size may be set upon construction and adjusted afterwards. Calls to <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a51eb183ba0daf9e4c94dd6b8d045f070">prepare</a> that would exceed this size will throw <code>std::length_error</code>.</li>
</ul>
<ul>
<li>Sequences previously obtained using <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a52e71ca9869c2ea45655ae718437250f">data</a> remain valid after calls to <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a51eb183ba0daf9e4c94dd6b8d045f070">prepare</a> or <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a75c380fdf77c5d5ef5aae090ba80ecdf">commit</a>.</li>
</ul>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Allocator</td><td>The allocator to use for managing memory. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">構築子と解体子</h2>
<a id="ad4c5fae0557e156ed23abb2e23ba73fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4c5fae0557e156ed23abb2e23ba73fa">&#9670;&nbsp;</a></span>basic_multi_buffer() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">boost::beast::basic_multi_buffer</a>&lt; Allocator &gt;::<a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">basic_multi_buffer</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor</p>
<p>After construction, <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#aaf0ea59be121e9c798e773532a8ebe6f">capacity</a> will return zero, and <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a14b8e8e24df75c6b714dbe29521a2f05">max_size</a> will return the largest value which may be passed to the allocator's <code>allocate</code> function. </p>

</div>
</div>
<a id="a1d7519bdfb2164b0c106b17965dfc3cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d7519bdfb2164b0c106b17965dfc3cf">&#9670;&nbsp;</a></span>basic_multi_buffer() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">boost::beast::basic_multi_buffer</a>&lt; Allocator &gt;::<a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">basic_multi_buffer</a> </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>limit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor</p>
<p>After construction, <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#aaf0ea59be121e9c798e773532a8ebe6f">capacity</a> will return zero, and <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a14b8e8e24df75c6b714dbe29521a2f05">max_size</a> will return the specified value of <code>limit</code>.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">limit</td><td>The desired maximum size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2b6fc6e56a98d76fe22b4c345a7b980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b6fc6e56a98d76fe22b4c345a7b980">&#9670;&nbsp;</a></span>basic_multi_buffer() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">boost::beast::basic_multi_buffer</a>&lt; Allocator &gt;::<a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">basic_multi_buffer</a> </td>
          <td>(</td>
          <td class="paramtype">Allocator const &amp;&#160;</td>
          <td class="paramname"><em>alloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor</p>
<p>After construction, <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#aaf0ea59be121e9c798e773532a8ebe6f">capacity</a> will return zero, and <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a14b8e8e24df75c6b714dbe29521a2f05">max_size</a> will return the largest value which may be passed to the allocator's <code>allocate</code> function.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>The allocator to use for the object.</td></tr>
  </table>
  </dd>
</dl>
<p>@esafe</p>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="a99e25b5d82a92f23f393513828d5e65d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99e25b5d82a92f23f393513828d5e65d">&#9670;&nbsp;</a></span>basic_multi_buffer() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">boost::beast::basic_multi_buffer</a>&lt; Allocator &gt;::<a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">basic_multi_buffer</a> </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator const &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor</p>
<p>After construction, <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#aaf0ea59be121e9c798e773532a8ebe6f">capacity</a> will return zero, and <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a14b8e8e24df75c6b714dbe29521a2f05">max_size</a> will return the specified value of <code>limit</code>.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">limit</td><td>The desired maximum size.</td></tr>
    <tr><td class="paramname">alloc</td><td>The allocator to use for the object.</td></tr>
  </table>
  </dd>
</dl>
<p>@esafe</p>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="a09bb97199c795210d77b2fee99b4ec4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09bb97199c795210d77b2fee99b4ec4e">&#9670;&nbsp;</a></span>basic_multi_buffer() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">boost::beast::basic_multi_buffer</a>&lt; Allocator &gt;::<a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">basic_multi_buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">basic_multi_buffer</a>&lt; Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move Constructor</p>
<p>The container is constructed with the contents of <code>other</code> using move semantics. The maximum size will be the same as the moved-from object.</p>
<p>Buffer sequences previously obtained from <code>other</code> using <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a52e71ca9869c2ea45655ae718437250f">data</a> or <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a51eb183ba0daf9e4c94dd6b8d045f070">prepare</a> remain valid after the move.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The object to move from. After the move, the moved-from object will have zero capacity, zero readable bytes, and zero writable bytes.</td></tr>
  </table>
  </dd>
</dl>
<p>@esafe</p>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="a77bbf728af4cab0fc0b5e50e04e043e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77bbf728af4cab0fc0b5e50e04e043e3">&#9670;&nbsp;</a></span>basic_multi_buffer() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">boost::beast::basic_multi_buffer</a>&lt; Allocator &gt;::<a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">basic_multi_buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">basic_multi_buffer</a>&lt; Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator const &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move Constructor</p>
<p>Using <code>alloc</code> as the allocator for the new container, the contents of <code>other</code> are moved. If <code>alloc != other.get_allocator()</code>, this results in a copy. The maximum size will be the same as the moved-from object.</p>
<p>Buffer sequences previously obtained from <code>other</code> using <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a52e71ca9869c2ea45655ae718437250f">data</a> or <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a51eb183ba0daf9e4c94dd6b8d045f070">prepare</a> become invalid after the move.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The object to move from. After the move, the moved-from object will have zero capacity, zero readable bytes, and zero writable bytes.</td></tr>
    <tr><td class="paramname">alloc</td><td>The allocator to use for the object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if <code>other.size()</code> exceeds the maximum allocation size of <code>alloc</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad38b65000108e015204d9fa56e914a6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad38b65000108e015204d9fa56e914a6d">&#9670;&nbsp;</a></span>basic_multi_buffer() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">boost::beast::basic_multi_buffer</a>&lt; Allocator &gt;::<a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">basic_multi_buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">basic_multi_buffer</a>&lt; Allocator &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy Constructor</p>
<p>This container is constructed with the contents of <code>other</code> using copy semantics. The maximum size will be the same as the copied object.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The object to copy from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if <code>other.size()</code> exceeds the maximum allocation size of the allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4dd15be8e4777b2c8a968e65935b3c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dd15be8e4777b2c8a968e65935b3c33">&#9670;&nbsp;</a></span>basic_multi_buffer() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">boost::beast::basic_multi_buffer</a>&lt; Allocator &gt;::<a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">basic_multi_buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">basic_multi_buffer</a>&lt; Allocator &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator const &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy Constructor</p>
<p>This container is constructed with the contents of <code>other</code> using copy semantics and the specified allocator. The maximum size will be the same as the copied object.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The object to copy from.</td></tr>
    <tr><td class="paramname">alloc</td><td>The allocator to use for the object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if <code>other.size()</code> exceeds the maximum allocation size of <code>alloc</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2f35ea7a15d8ed1ebab8e9dfc33b8f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2f35ea7a15d8ed1ebab8e9dfc33b8f2">&#9670;&nbsp;</a></span>basic_multi_buffer() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class OtherAlloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">boost::beast::basic_multi_buffer</a>&lt; Allocator &gt;::<a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">basic_multi_buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">basic_multi_buffer</a>&lt; OtherAlloc &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy Constructor</p>
<p>This container is constructed with the contents of <code>other</code> using copy semantics. The maximum size will be the same as the copied object.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The object to copy from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if <code>other.size()</code> exceeds the maximum allocation size of the allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd6692b7c3bbd740699bb69492395b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd6692b7c3bbd740699bb69492395b05">&#9670;&nbsp;</a></span>basic_multi_buffer() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class OtherAlloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">boost::beast::basic_multi_buffer</a>&lt; Allocator &gt;::<a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">basic_multi_buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">basic_multi_buffer</a>&lt; OtherAlloc &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#aea22101191464131a115472d6bdd9634">allocator_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy Constructor</p>
<p>This container is constructed with the contents of <code>other</code> using copy semantics. The maximum size will be the same as the copied object.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The object to copy from.</td></tr>
    <tr><td class="paramname">alloc</td><td>The allocator to use for the object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if <code>other.size()</code> exceeds the maximum allocation size of <code>alloc</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">関数詳解</h2>
<a id="a7ad5d6b7c6a4e033e1c329ba8cf274ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad5d6b7c6a4e033e1c329ba8cf274ef">&#9670;&nbsp;</a></span>cdata()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer_1_1subrange.html">const_buffers_type</a> <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">boost::beast::basic_multi_buffer</a>&lt; Allocator &gt;::cdata </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a constant buffer sequence representing the readable bytes</p>
<dl class="section note"><dt>覚え書き</dt><dd>The sequence may contain multiple contiguous memory regions. </dd></dl>

</div>
</div>
<a id="a9cbacd096aa3236e5ff69b0e7e9adfce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cbacd096aa3236e5ff69b0e7e9adfce">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">boost::beast::basic_multi_buffer</a>&lt; Allocator &gt;::clear</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the size of the readable and writable bytes to zero.</p>
<p>This clears the buffer without changing capacity. Buffer sequences previously obtained using <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a52e71ca9869c2ea45655ae718437250f">data</a> or <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a51eb183ba0daf9e4c94dd6b8d045f070">prepare</a> become invalid.</p>
<p>@esafe</p>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="a75c380fdf77c5d5ef5aae090ba80ecdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75c380fdf77c5d5ef5aae090ba80ecdf">&#9670;&nbsp;</a></span>commit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">boost::beast::basic_multi_buffer</a>&lt; Allocator &gt;::commit </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Append writable bytes to the readable bytes.</p>
<p>Appends n bytes from the start of the writable bytes to the end of the readable bytes. The remainder of the writable bytes are discarded. If n is greater than the number of writable bytes, all writable bytes are appended to the readable bytes.</p>
<p>All buffer sequences previously obtained using <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a51eb183ba0daf9e4c94dd6b8d045f070">prepare</a> are invalidated. Buffer sequences previously obtained using <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a52e71ca9869c2ea45655ae718437250f">data</a> remain valid.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of bytes to append. If this number is greater than the number of writable bytes, all writable bytes are appended.</td></tr>
  </table>
  </dd>
</dl>
<p>@esafe</p>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="a9c3e2942f0eae34090638b77521896ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c3e2942f0eae34090638b77521896ef">&#9670;&nbsp;</a></span>consume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">boost::beast::basic_multi_buffer</a>&lt; Allocator &gt;::consume </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove bytes from beginning of the readable bytes.</p>
<p>Removes n bytes from the beginning of the readable bytes.</p>
<p>All buffers sequences previously obtained using <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a52e71ca9869c2ea45655ae718437250f">data</a> or <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a51eb183ba0daf9e4c94dd6b8d045f070">prepare</a> are invalidated.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of bytes to remove. If this number is greater than the number of readable bytes, all readable bytes are removed.</td></tr>
  </table>
  </dd>
</dl>
<p>@esafe</p>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="a52e71ca9869c2ea45655ae718437250f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e71ca9869c2ea45655ae718437250f">&#9670;&nbsp;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">boost::beast::basic_multi_buffer</a>&lt; Allocator &gt;::data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a constant buffer sequence representing the readable bytes</p>
<dl class="section note"><dt>覚え書き</dt><dd>The sequence may contain multiple contiguous memory regions. </dd></dl>

</div>
</div>
<a id="a4bbd30414fa0be23e70053d3c991bff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bbd30414fa0be23e70053d3c991bff5">&#9670;&nbsp;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer_1_1subrange.html">mutable_buffers_type</a> <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">boost::beast::basic_multi_buffer</a>&lt; Allocator &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a mutable buffer sequence representing the readable bytes.</p>
<dl class="section note"><dt>覚え書き</dt><dd>The sequence may contain multiple contiguous memory regions. </dd></dl>

</div>
</div>
<a id="a14b8e8e24df75c6b714dbe29521a2f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14b8e8e24df75c6b714dbe29521a2f05">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">boost::beast::basic_multi_buffer</a>&lt; Allocator &gt;::max_size </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the maximum allowed capacity</p>
<p>This function changes the currently configured upper limit on capacity to the specified value.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The maximum number of bytes ever allowed for capacity.</td></tr>
  </table>
  </dd>
</dl>
<p>@esafe</p>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="a5653bde07b215af7cd3a96cd2c95960d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5653bde07b215af7cd3a96cd2c95960d">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">boost::beast::basic_multi_buffer</a>&lt; Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">basic_multi_buffer</a>&lt; Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move Assignment</p>
<p>The container is assigned with the contents of <code>other</code> using move semantics. The maximum size will be the same as the moved-from object.</p>
<p>Buffer sequences previously obtained from <code>other</code> using <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a52e71ca9869c2ea45655ae718437250f">data</a> or <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a51eb183ba0daf9e4c94dd6b8d045f070">prepare</a> remain valid after the move.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The object to move from. After the move, the moved-from object will have zero capacity, zero readable bytes, and zero writable bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a472edd9353ae62b2558b4d271d61b345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a472edd9353ae62b2558b4d271d61b345">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">boost::beast::basic_multi_buffer</a>&lt; Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">basic_multi_buffer</a>&lt; Allocator &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy Assignment</p>
<p>The container is assigned with the contents of <code>other</code> using copy semantics. The maximum size will be the same as the copied object.</p>
<p>After the copy, <code>this</code> will have zero writable bytes.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The object to copy from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if <code>other.size()</code> exceeds the maximum allocation size of the allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc233cc16a3b20edef6b3e631880180a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc233cc16a3b20edef6b3e631880180a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class OtherAlloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">basic_multi_buffer</a>&amp; <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">boost::beast::basic_multi_buffer</a>&lt; Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">basic_multi_buffer</a>&lt; OtherAlloc &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy Assignment</p>
<p>The container is assigned with the contents of <code>other</code> using copy semantics. The maximum size will be the same as the copied object.</p>
<p>After the copy, <code>this</code> will have zero writable bytes.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The object to copy from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if <code>other.size()</code> exceeds the maximum allocation size of the allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51eb183ba0daf9e4c94dd6b8d045f070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51eb183ba0daf9e4c94dd6b8d045f070">&#9670;&nbsp;</a></span>prepare()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">boost::beast::basic_multi_buffer</a>&lt; Allocator &gt;::prepare </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a mutable buffer sequence representing writable bytes.</p>
<p>Returns a mutable buffer sequence representing the writable bytes containing exactly <code>n</code> bytes of storage. Memory may be reallocated as needed.</p>
<p>All buffer sequences previously obtained using <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a51eb183ba0daf9e4c94dd6b8d045f070">prepare</a> are invalidated. Buffer sequences previously obtained using <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a52e71ca9869c2ea45655ae718437250f">data</a> remain valid.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The desired number of bytes in the returned buffer sequence.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if <code><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a1c7d04d833001ca47275478ce14f54cc" title="Returns the number of readable bytes.">size()</a> + n</code> exceeds <code><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a14b8e8e24df75c6b714dbe29521a2f05">max_size()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<p>@esafe</p>
<p>Strong guarantee. </p>

</div>
</div>
<a id="a34026867fee11cb2be10f1f5bbfb4840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34026867fee11cb2be10f1f5bbfb4840">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">boost::beast::basic_multi_buffer</a>&lt; Allocator &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Guarantee a minimum capacity</p>
<p>This function adjusts the internal storage (if necessary) to guarantee space for at least <code>n</code> bytes.</p>
<p>Buffer sequences previously obtained using <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a52e71ca9869c2ea45655ae718437250f">data</a> remain valid, while buffer sequences previously obtained using <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a51eb183ba0daf9e4c94dd6b8d045f070">prepare</a> become invalid.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The minimum number of byte for the new capacity. If this value is greater than the maximum size, then the maximum size will be adjusted upwards to this value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if n is larger than the maximum allocation size of the allocator.</td></tr>
  </table>
  </dd>
</dl>
<p>@esafe</p>
<p>Strong guarantee. </p>

</div>
</div>
<a id="a70a236b685accb089dc4b469513a288c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70a236b685accb089dc4b469513a288c">&#9670;&nbsp;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">boost::beast::basic_multi_buffer</a>&lt; Allocator &gt;::shrink_to_fit</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reallocate the buffer to fit the readable bytes exactly.</p>
<p>Buffer sequences previously obtained using <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a52e71ca9869c2ea45655ae718437250f">data</a> or <a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html#a51eb183ba0daf9e4c94dd6b8d045f070">prepare</a> become invalid.</p>
<p>@esafe</p>
<p>Strong guarantee. </p>

</div>
</div>
<hr/>このクラス詳解は次のファイルから抽出されました:<ul>
<li>include/external/boost/boost/beast/core/<a class="el" href="multi__buffer_8hpp_source.html">multi_buffer.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceboost.html">boost</a></li><li class="navelem"><b>beast</b></li><li class="navelem"><a class="el" href="classboost_1_1beast_1_1basic__multi__buffer.html">basic_multi_buffer</a></li>
    <li class="footer">構築:
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
