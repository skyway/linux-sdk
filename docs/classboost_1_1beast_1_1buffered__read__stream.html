<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
<head>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
        'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
        })(window,document,'script','dataLayer','GTM-NN5JX4B');</script>
    <!-- End Google Tag Manager -->
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=11"/>
    <meta name="generator" content="Doxygen 1.9.8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>SkyWay Linux SDK</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="resize.js"></script>
    <script type="text/javascript" src="navtreedata.js"></script>
    <script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="search/searchdata.js"></script>
    <script type="text/javascript" src="search/search.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NN5JX4B"
        height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
            <tbody>
                <tr id="projectrow">
                    <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
                    <td id="projectalign">
                        <div id="projectname">SkyWay Linux SDK
                        </div>
                    </td>
                </tr>
            </tbody>
        </table>
    </div><!-- 構築: Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'検索');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','検索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classboost_1_1beast_1_1buffered__read__stream.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">クラス</a> &#124;
<a href="#pub-types">公開型</a> &#124;
<a href="#pub-methods">公開メンバ関数</a> &#124;
<a href="classboost_1_1beast_1_1buffered__read__stream-members.html">全メンバ一覧</a>  </div>
  <div class="headertitle">
<div class="title">boost::beast::buffered_read_stream&lt; Stream, DynamicBuffer &gt; クラステンプレート</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="buffered__read__stream_8hpp_source.html">buffered_read_stream.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
クラス</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1beast_1_1buffered__read__stream_1_1ops.html">ops</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
公開型</h2></td></tr>
<tr class="memitem:a46cfab0977a97141dce3066cb293a014"><td class="memItemLeft" align="right" valign="top"><a id="a46cfab0977a97141dce3066cb293a014"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#a46cfab0977a97141dce3066cb293a014">buffer_type</a> = DynamicBuffer</td></tr>
<tr class="memdesc:a46cfab0977a97141dce3066cb293a014"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the internal buffer <br /></td></tr>
<tr class="separator:a46cfab0977a97141dce3066cb293a014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cba99566586b691901f1157bce08857"><td class="memItemLeft" align="right" valign="top"><a id="a0cba99566586b691901f1157bce08857"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#a0cba99566586b691901f1157bce08857">next_layer_type</a> = typename std::remove_reference&lt; Stream &gt;::<a class="el" href="structboost_1_1type.html">type</a></td></tr>
<tr class="memdesc:a0cba99566586b691901f1157bce08857"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the next layer. <br /></td></tr>
<tr class="separator:a0cba99566586b691901f1157bce08857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea719300560e0fc7dbccb717f19a513"><td class="memItemLeft" align="right" valign="top"><a id="aaea719300560e0fc7dbccb717f19a513"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>executor_type</b> = beast::executor_type&lt; <a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#a0cba99566586b691901f1157bce08857">next_layer_type</a> &gt;</td></tr>
<tr class="separator:aaea719300560e0fc7dbccb717f19a513"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
公開メンバ関数</h2></td></tr>
<tr class="memitem:a8bf5f9062db879343197fdc558c141da"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#a8bf5f9062db879343197fdc558c141da">buffered_read_stream</a> (<a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">buffered_read_stream</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a8bf5f9062db879343197fdc558c141da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f6608018f0380efaf15bec2c8e9b0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">buffered_read_stream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#aa9f6608018f0380efaf15bec2c8e9b0f">operator=</a> (<a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">buffered_read_stream</a> &amp;&amp;)=default</td></tr>
<tr class="separator:aa9f6608018f0380efaf15bec2c8e9b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59080b5ba9871ce78f5fb5ae42ddeff"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ae59080b5ba9871ce78f5fb5ae42ddeff"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#ae59080b5ba9871ce78f5fb5ae42ddeff">buffered_read_stream</a> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:ae59080b5ba9871ce78f5fb5ae42ddeff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4a88ca0f558c28f9865c0dce1e9b82"><td class="memItemLeft" align="right" valign="top"><a id="a4f4a88ca0f558c28f9865c0dce1e9b82"></a>
<a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#a0cba99566586b691901f1157bce08857">next_layer_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#a4f4a88ca0f558c28f9865c0dce1e9b82">next_layer</a> () noexcept</td></tr>
<tr class="memdesc:a4f4a88ca0f558c28f9865c0dce1e9b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the next layer. <br /></td></tr>
<tr class="separator:a4f4a88ca0f558c28f9865c0dce1e9b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d47bc148b514046fd79a76d479d169e"><td class="memItemLeft" align="right" valign="top"><a id="a3d47bc148b514046fd79a76d479d169e"></a>
<a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#a0cba99566586b691901f1157bce08857">next_layer_type</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#a3d47bc148b514046fd79a76d479d169e">next_layer</a> () const noexcept</td></tr>
<tr class="memdesc:a3d47bc148b514046fd79a76d479d169e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to the next layer. <br /></td></tr>
<tr class="separator:a3d47bc148b514046fd79a76d479d169e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b37b875912c094c31d7f1de2cb73c6"><td class="memItemLeft" align="right" valign="top">executor_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#ac1b37b875912c094c31d7f1de2cb73c6">get_executor</a> () noexcept</td></tr>
<tr class="separator:ac1b37b875912c094c31d7f1de2cb73c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca3c8dbfaddcdabd595b0ed032b5732"><td class="memItemLeft" align="right" valign="top">DynamicBuffer &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#acca3c8dbfaddcdabd595b0ed032b5732">buffer</a> () noexcept</td></tr>
<tr class="separator:acca3c8dbfaddcdabd595b0ed032b5732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95809b0e92f3e3cb2043ff9aa9bad7dd"><td class="memItemLeft" align="right" valign="top"><a id="a95809b0e92f3e3cb2043ff9aa9bad7dd"></a>
DynamicBuffer const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#a95809b0e92f3e3cb2043ff9aa9bad7dd">buffer</a> () const noexcept</td></tr>
<tr class="memdesc:a95809b0e92f3e3cb2043ff9aa9bad7dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the internal buffer <br /></td></tr>
<tr class="separator:a95809b0e92f3e3cb2043ff9aa9bad7dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21d2b18860e7c7551ac906f3f889b0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#af21d2b18860e7c7551ac906f3f889b0a">capacity</a> (std::size_t size) noexcept</td></tr>
<tr class="separator:af21d2b18860e7c7551ac906f3f889b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256284c91e8c07261f734f5655415e05"><td class="memTemplParams" colspan="2">template&lt;class MutableBufferSequence &gt; </td></tr>
<tr class="memitem:a256284c91e8c07261f734f5655415e05"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#a256284c91e8c07261f734f5655415e05">read_some</a> (MutableBufferSequence const &amp;buffers)</td></tr>
<tr class="separator:a256284c91e8c07261f734f5655415e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af612f292a3a2c3b50c213a5d1af7b766"><td class="memTemplParams" colspan="2">template&lt;class MutableBufferSequence &gt; </td></tr>
<tr class="memitem:af612f292a3a2c3b50c213a5d1af7b766"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#af612f292a3a2c3b50c213a5d1af7b766">read_some</a> (MutableBufferSequence const &amp;buffers, <a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;ec)</td></tr>
<tr class="separator:af612f292a3a2c3b50c213a5d1af7b766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f6cea8f26bdd54b84acf9845a72529"><td class="memTemplParams" colspan="2">template&lt;class MutableBufferSequence , BOOST_BEAST_ASYNC_TPARAM2 ReadHandler = net::default_completion_token_t&lt;executor_type&gt;&gt; </td></tr>
<tr class="memitem:a84f6cea8f26bdd54b84acf9845a72529"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#a84f6cea8f26bdd54b84acf9845a72529">async_read_some</a> (MutableBufferSequence const &amp;buffers, ReadHandler &amp;&amp;handler=net::default_completion_token_t&lt; executor_type &gt;{})</td></tr>
<tr class="separator:a84f6cea8f26bdd54b84acf9845a72529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ecec3fc91bd6a4abfeb225c1822e20f"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence &gt; </td></tr>
<tr class="memitem:a7ecec3fc91bd6a4abfeb225c1822e20f"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#a7ecec3fc91bd6a4abfeb225c1822e20f">write_some</a> (ConstBufferSequence const &amp;buffers)</td></tr>
<tr class="separator:a7ecec3fc91bd6a4abfeb225c1822e20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac452101fc0403cfb156cc4bf8251465f"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence &gt; </td></tr>
<tr class="memitem:ac452101fc0403cfb156cc4bf8251465f"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#ac452101fc0403cfb156cc4bf8251465f">write_some</a> (ConstBufferSequence const &amp;buffers, <a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;ec)</td></tr>
<tr class="separator:ac452101fc0403cfb156cc4bf8251465f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98fe4226014c3b9ff190a27b6d0d642f"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence , BOOST_BEAST_ASYNC_TPARAM2 WriteHandler = net::default_completion_token_t&lt;executor_type&gt;&gt; </td></tr>
<tr class="memitem:a98fe4226014c3b9ff190a27b6d0d642f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#a98fe4226014c3b9ff190a27b6d0d642f">async_write_some</a> (ConstBufferSequence const &amp;buffers, WriteHandler &amp;&amp;handler=net::default_completion_token_t&lt; executor_type &gt;{})</td></tr>
<tr class="separator:a98fe4226014c3b9ff190a27b6d0d642f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">詳解</h2>
<div class="textblock"><h3>template&lt;class Stream, class DynamicBuffer&gt;<br />
class boost::beast::buffered_read_stream&lt; Stream, DynamicBuffer &gt;</h3>

<p>A <em>Stream</em> with attached <em>DynamicBuffer</em> to buffer reads.</p>
<p>This wraps a <em>Stream</em> implementation so that calls to write are passed through to the underlying stream, while calls to read will first consume the input sequence stored in a <em>DynamicBuffer</em> which is part of the object.</p>
<p>The use-case for this class is different than that of the <code>net::buffered_read_stream</code>. It is designed to facilitate the use of <code>net::read_until</code>, and to allow buffers acquired during detection of handshakes to be made transparently available to callers. A hypothetical implementation of the buffered version of <code>net::ssl::stream::async_handshake</code> could make use of this wrapper.</p>
<p>Uses:</p>
<ul>
<li>Transparently leave untouched input acquired in calls to <code>net::read_until</code> behind for subsequent callers.</li>
</ul>
<ul>
<li>"Preload" a stream with handshake input data acquired from other sources.</li>
</ul>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// Process the next HTTP header on the stream,</span></div>
<div class="line"><span class="comment">// leaving excess bytes behind for the next call.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Stream, <span class="keyword">class</span> DynamicBuffer&gt;</div>
<div class="line"><span class="keywordtype">void</span> process_http_message(</div>
<div class="line">    buffered_read_stream&lt;Stream, DynamicBuffer&gt;&amp; stream)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Read up to and including the end of the HTTP</span></div>
<div class="line">    <span class="comment">// header, leaving the sequence in the stream&#39;s</span></div>
<div class="line">    <span class="comment">// buffer. read_until may read past the end of the</span></div>
<div class="line">    <span class="comment">// headers; the return value will include only the</span></div>
<div class="line">    <span class="comment">// part up to the end of the delimiter.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    std::size_t bytes_transferred =</div>
<div class="line">        net::read_until(</div>
<div class="line">            stream.next_layer(), stream.buffer(), <span class="stringliteral">&quot;\r\n\r\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Use buffers_prefix() to limit the input</span></div>
<div class="line">    <span class="comment">// sequence to only the data up to and including</span></div>
<div class="line">    <span class="comment">// the trailing &quot;\r\n\r\n&quot;.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="keyword">auto</span> header_buffers = buffers_prefix(</div>
<div class="line">        bytes_transferred, stream.buffer().data());</div>
<div class="line"> </div>
<div class="line">    ...</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Discard the portion of the input corresponding</span></div>
<div class="line">    <span class="comment">// to the HTTP headers.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    stream.buffer().consume(bytes_transferred);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Everything we read from the stream</span></div>
<div class="line">    <span class="comment">// is part of the content-body.</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stream</td><td>The type of stream to wrap.</td></tr>
    <tr><td class="paramname">DynamicBuffer</td><td>The type of stream buffer to use. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">構築子と解体子</h2>
<a id="a8bf5f9062db879343197fdc558c141da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bf5f9062db879343197fdc558c141da">&#9670;&nbsp;</a></span>buffered_read_stream() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class DynamicBuffer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">boost::beast::buffered_read_stream</a>&lt; Stream, DynamicBuffer &gt;::<a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">buffered_read_stream</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">buffered_read_stream</a>&lt; Stream, DynamicBuffer &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor.</p>
<dl class="section note"><dt>覚え書き</dt><dd>The behavior of move assignment on or from streams with active or pending operations is undefined. </dd></dl>

</div>
</div>
<a id="ae59080b5ba9871ce78f5fb5ae42ddeff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae59080b5ba9871ce78f5fb5ae42ddeff">&#9670;&nbsp;</a></span>buffered_read_stream() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class DynamicBuffer &gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">boost::beast::buffered_read_stream</a>&lt; Stream, DynamicBuffer &gt;::<a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">buffered_read_stream</a> </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct the wrapping stream.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Parameters forwarded to the <code>Stream</code> constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">関数詳解</h2>
<a id="a84f6cea8f26bdd54b84acf9845a72529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84f6cea8f26bdd54b84acf9845a72529">&#9670;&nbsp;</a></span>async_read_some()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class DynamicBuffer &gt; </div>
<div class="memtemplate">
template&lt;class MutableBufferSequence , BOOST_BEAST_ASYNC_TPARAM2 ReadHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">boost::beast::buffered_read_stream</a>&lt; Stream, DynamicBuffer &gt;::async_read_some </td>
          <td>(</td>
          <td class="paramtype">MutableBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em> = <code>net::default_completion_token_t&lt;executor_type&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start an asynchronous read.</p>
<p>This function is used to asynchronously read data from the stream. The function call always returns immediately.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(</div>
<div class="line">    error_code <span class="keyword">const</span>&amp; error,      <span class="comment">// result of operation</span></div>
<div class="line">    std::size_t bytes_transferred <span class="comment">// number of bytes transferred</span></div>
<div class="line">);</div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>net::post</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98fe4226014c3b9ff190a27b6d0d642f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98fe4226014c3b9ff190a27b6d0d642f">&#9670;&nbsp;</a></span>async_write_some()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class DynamicBuffer &gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence , BOOST_BEAST_ASYNC_TPARAM2 WriteHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">boost::beast::buffered_read_stream</a>&lt; Stream, DynamicBuffer &gt;::async_write_some </td>
          <td>(</td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em> = <code>net::default_completion_token_t&lt;executor_type&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start an asynchronous write.</p>
<p>This function is used to asynchronously write data from the stream. The function call always returns immediately.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>One or more data buffers to be written to the stream. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(</div>
<div class="line">    error_code <span class="keyword">const</span>&amp; error,      <span class="comment">// result of operation</span></div>
<div class="line">    std::size_t bytes_transferred <span class="comment">// number of bytes transferred</span></div>
<div class="line">);</div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>net::post</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acca3c8dbfaddcdabd595b0ed032b5732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca3c8dbfaddcdabd595b0ed032b5732">&#9670;&nbsp;</a></span>buffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class DynamicBuffer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DynamicBuffer&amp; <a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">boost::beast::buffered_read_stream</a>&lt; Stream, DynamicBuffer &gt;::buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access the internal buffer.</p>
<p>The internal buffer is returned. It is possible for the caller to break invariants with this function. For example, by causing the internal buffer size to increase beyond the caller defined maximum. </p>

</div>
</div>
<a id="af21d2b18860e7c7551ac906f3f889b0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af21d2b18860e7c7551ac906f3f889b0a">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class DynamicBuffer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">boost::beast::buffered_read_stream</a>&lt; Stream, DynamicBuffer &gt;::capacity </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the maximum buffer size.</p>
<p>This changes the maximum size of the internal buffer used to hold read data. No bytes are discarded by this call. If the buffer size is set to zero, no more data will be buffered.</p>
<p>Thread safety: The caller is responsible for making sure the call is made from the same implicit or explicit strand.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The number of bytes in the read buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>This is a soft limit. If the new maximum size is smaller than the amount of data in the buffer, no bytes are discarded. </dd></dl>

</div>
</div>
<a id="ac1b37b875912c094c31d7f1de2cb73c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b37b875912c094c31d7f1de2cb73c6">&#9670;&nbsp;</a></span>get_executor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class DynamicBuffer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">executor_type <a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">boost::beast::buffered_read_stream</a>&lt; Stream, DynamicBuffer &gt;::get_executor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the executor associated with the object.</p>
<p>This function may be used to obtain the executor object that the stream uses to dispatch handlers for asynchronous operations.</p>
<dl class="section return"><dt>戻り値</dt><dd>A copy of the executor that stream will use to dispatch handlers. </dd></dl>

</div>
</div>
<a id="aa9f6608018f0380efaf15bec2c8e9b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9f6608018f0380efaf15bec2c8e9b0f">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class DynamicBuffer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">buffered_read_stream</a>&amp; <a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">boost::beast::buffered_read_stream</a>&lt; Stream, DynamicBuffer &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">buffered_read_stream</a>&lt; Stream, DynamicBuffer &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move assignment.</p>
<dl class="section note"><dt>覚え書き</dt><dd>The behavior of move assignment on or from streams with active or pending operations is undefined. </dd></dl>

</div>
</div>
<a id="a256284c91e8c07261f734f5655415e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a256284c91e8c07261f734f5655415e05">&#9670;&nbsp;</a></span>read_some() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class DynamicBuffer &gt; </div>
<div class="memtemplate">
template&lt;class MutableBufferSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">boost::beast::buffered_read_stream</a>&lt; Stream, DynamicBuffer &gt;::read_some </td>
          <td>(</td>
          <td class="paramtype">MutableBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read some data from the stream.</p>
<p>This function is used to read data from the stream. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The number of bytes read.</dd></dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af612f292a3a2c3b50c213a5d1af7b766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af612f292a3a2c3b50c213a5d1af7b766">&#9670;&nbsp;</a></span>read_some() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class DynamicBuffer &gt; </div>
<div class="memtemplate">
template&lt;class MutableBufferSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">boost::beast::buffered_read_stream</a>&lt; Stream, DynamicBuffer &gt;::read_some </td>
          <td>(</td>
          <td class="paramtype">MutableBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read some data from the stream.</p>
<p>This function is used to read data from the stream. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to the error, if any occurred.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The number of bytes read, or 0 on error. </dd></dl>

</div>
</div>
<a id="a7ecec3fc91bd6a4abfeb225c1822e20f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ecec3fc91bd6a4abfeb225c1822e20f">&#9670;&nbsp;</a></span>write_some() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class DynamicBuffer &gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">boost::beast::buffered_read_stream</a>&lt; Stream, DynamicBuffer &gt;::write_some </td>
          <td>(</td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write some data to the stream.</p>
<p>This function is used to write data to the stream. The function call will block until one or more bytes of the data has been written successfully, or until an error occurs.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>One or more data buffers to be written to the stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The number of bytes written.</dd></dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac452101fc0403cfb156cc4bf8251465f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac452101fc0403cfb156cc4bf8251465f">&#9670;&nbsp;</a></span>write_some() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class DynamicBuffer &gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">boost::beast::buffered_read_stream</a>&lt; Stream, DynamicBuffer &gt;::write_some </td>
          <td>(</td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write some data to the stream.</p>
<p>This function is used to write data to the stream. The function call will block until one or more bytes of the data has been written successfully, or until an error occurs.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>One or more data buffers to be written to the stream.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to the error, if any occurred.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The number of bytes written. </dd></dl>

</div>
</div>
<hr/>このクラス詳解は次のファイルから抽出されました:<ul>
<li>include/external/boost/boost/beast/core/<a class="el" href="buffered__read__stream_8hpp_source.html">buffered_read_stream.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceboost.html">boost</a></li><li class="navelem"><b>beast</b></li><li class="navelem"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">buffered_read_stream</a></li>
    <li class="footer">構築:
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
