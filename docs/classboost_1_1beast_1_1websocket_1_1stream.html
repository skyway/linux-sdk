<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
<head>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
        'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
        })(window,document,'script','dataLayer','GTM-NN5JX4B');</script>
    <!-- End Google Tag Manager -->
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=11"/>
    <meta name="generator" content="Doxygen 1.9.8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>SkyWay Linux SDK</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="resize.js"></script>
    <script type="text/javascript" src="navtreedata.js"></script>
    <script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="search/searchdata.js"></script>
    <script type="text/javascript" src="search/search.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NN5JX4B"
        height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
            <tbody>
                <tr id="projectrow">
                    <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
                    <td id="projectalign">
                        <div id="projectname">SkyWay Linux SDK
                        </div>
                    </td>
                </tr>
            </tbody>
        </table>
    </div><!-- 構築: Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'検索');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','検索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classboost_1_1beast_1_1websocket_1_1stream.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">クラス</a> &#124;
<a href="#pub-types">公開型</a> &#124;
<a href="#pub-methods">公開メンバ関数</a> &#124;
<a href="#friends">フレンド</a> &#124;
<a href="classboost_1_1beast_1_1websocket_1_1stream-members.html">全メンバ一覧</a>  </div>
  <div class="headertitle">
<div class="title">boost::beast::websocket::stream&lt; NextLayer, deflateSupported &gt; クラステンプレート</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="external_2boost_2boost_2beast_2websocket_2stream_8hpp_source.html">stream.hpp</a>&gt;</code></p>
<div class="dynheader">
boost::beast::websocket::stream&lt; NextLayer, deflateSupported &gt; の継承関係図</div>
<div class="dyncontent">
 <div class="center">
  <img src="classboost_1_1beast_1_1websocket_1_1stream.png" usemap="#boost::beast::websocket::stream_3C_20NextLayer_2C_20deflateSupported_20_3E_map" alt=""/>
  <map id="boost::beast::websocket::stream_3C_20NextLayer_2C_20deflateSupported_20_3E_map" name="boost::beast::websocket::stream_3C_20NextLayer_2C_20deflateSupported_20_3E_map">
<area href="structboost_1_1beast_1_1websocket_1_1stream__base.html" alt="boost::beast::websocket::stream_base" shape="rect" coords="0,0,373,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
クラス</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream_1_1accept__op.html">accept_op</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream_1_1close__op.html">close_op</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream_1_1handshake__op.html">handshake_op</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream_1_1idle__ping__op.html">idle_ping_op</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1beast_1_1websocket_1_1stream_1_1impl__type.html">impl_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream_1_1ping__op.html">ping_op</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream_1_1read__op.html">read_op</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream_1_1read__some__op.html">read_some_op</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream_1_1response__op.html">response_op</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1beast_1_1websocket_1_1stream_1_1run__accept__op.html">run_accept_op</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1beast_1_1websocket_1_1stream_1_1run__close__op.html">run_close_op</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1beast_1_1websocket_1_1stream_1_1run__handshake__op.html">run_handshake_op</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1beast_1_1websocket_1_1stream_1_1run__ping__op.html">run_ping_op</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1beast_1_1websocket_1_1stream_1_1run__read__op.html">run_read_op</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1beast_1_1websocket_1_1stream_1_1run__read__some__op.html">run_read_some_op</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1beast_1_1websocket_1_1stream_1_1run__response__op.html">run_response_op</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1beast_1_1websocket_1_1stream_1_1run__write__some__op.html">run_write_some_op</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream_1_1write__some__op.html">write_some_op</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
公開型</h2></td></tr>
<tr class="memitem:a0e7fefd9e31d91026c491b975e6de018"><td class="memItemLeft" align="right" valign="top"><a id="a0e7fefd9e31d91026c491b975e6de018"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a0e7fefd9e31d91026c491b975e6de018">is_deflate_supported</a> = std::integral_constant&lt; bool, deflateSupported &gt;</td></tr>
<tr class="memdesc:a0e7fefd9e31d91026c491b975e6de018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if the permessage-deflate extension is supported <br /></td></tr>
<tr class="separator:a0e7fefd9e31d91026c491b975e6de018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4e593b1b583bfd6089f71e28df94a8"><td class="memItemLeft" align="right" valign="top"><a id="a1f4e593b1b583bfd6089f71e28df94a8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a1f4e593b1b583bfd6089f71e28df94a8">next_layer_type</a> = typename std::remove_reference&lt; NextLayer &gt;::<a class="el" href="structboost_1_1type.html">type</a></td></tr>
<tr class="memdesc:a1f4e593b1b583bfd6089f71e28df94a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the next layer. <br /></td></tr>
<tr class="separator:a1f4e593b1b583bfd6089f71e28df94a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d4fcaa810123a537bec2db4f34f571"><td class="memItemLeft" align="right" valign="top"><a id="a94d4fcaa810123a537bec2db4f34f571"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a94d4fcaa810123a537bec2db4f34f571">executor_type</a> = beast::executor_type&lt; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a1f4e593b1b583bfd6089f71e28df94a8">next_layer_type</a> &gt;</td></tr>
<tr class="memdesc:a94d4fcaa810123a537bec2db4f34f571"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the executor associated with the object. <br /></td></tr>
<tr class="separator:a94d4fcaa810123a537bec2db4f34f571"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
公開メンバ関数</h2></td></tr>
<tr class="memitem:a063c8449d4c3736c2de1ad579d9c6f24"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a063c8449d4c3736c2de1ad579d9c6f24">~stream</a> ()</td></tr>
<tr class="separator:a063c8449d4c3736c2de1ad579d9c6f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc5b73b681c878a950b31395b384d45"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a6bc5b73b681c878a950b31395b384d45">stream</a> (<a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">stream</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a6bc5b73b681c878a950b31395b384d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f6b609d93996044889a3a1042ac649"><td class="memItemLeft" align="right" valign="top"><a id="a93f6b609d93996044889a3a1042ac649"></a>
<a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">stream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a93f6b609d93996044889a3a1042ac649">operator=</a> (<a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">stream</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:a93f6b609d93996044889a3a1042ac649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment (deleted) <br /></td></tr>
<tr class="separator:a93f6b609d93996044889a3a1042ac649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc2da4a8c4afa4b2f7d3bd0e7ae8e25"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:afbc2da4a8c4afa4b2f7d3bd0e7ae8e25"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#afbc2da4a8c4afa4b2f7d3bd0e7ae8e25">stream</a> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:afbc2da4a8c4afa4b2f7d3bd0e7ae8e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b23fc090a9f22fd28fb8d0d6827e109"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a94d4fcaa810123a537bec2db4f34f571">executor_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a4b23fc090a9f22fd28fb8d0d6827e109">get_executor</a> () noexcept</td></tr>
<tr class="separator:a4b23fc090a9f22fd28fb8d0d6827e109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4823a02a93e831ad06e15056adb8209"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a1f4e593b1b583bfd6089f71e28df94a8">next_layer_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ae4823a02a93e831ad06e15056adb8209">next_layer</a> () noexcept</td></tr>
<tr class="separator:ae4823a02a93e831ad06e15056adb8209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f41c025fa7eefbb1c2fbe3e315bf102"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a1f4e593b1b583bfd6089f71e28df94a8">next_layer_type</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a2f41c025fa7eefbb1c2fbe3e315bf102">next_layer</a> () const noexcept</td></tr>
<tr class="separator:a2f41c025fa7eefbb1c2fbe3e315bf102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f50dcdd7701086aef084796a5ea57e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ac1f50dcdd7701086aef084796a5ea57e">is_open</a> () const noexcept</td></tr>
<tr class="separator:ac1f50dcdd7701086aef084796a5ea57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2403f32e02459ff0ce44e1e2f17c46e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#af2403f32e02459ff0ce44e1e2f17c46e">got_binary</a> () const noexcept</td></tr>
<tr class="separator:af2403f32e02459ff0ce44e1e2f17c46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666609a7cc058832e89bdbf60758674e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a666609a7cc058832e89bdbf60758674e">got_text</a> () const</td></tr>
<tr class="separator:a666609a7cc058832e89bdbf60758674e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a60357667041e297498915a2313205"><td class="memItemLeft" align="right" valign="top"><a id="a91a60357667041e297498915a2313205"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a91a60357667041e297498915a2313205">is_message_done</a> () const noexcept</td></tr>
<tr class="memdesc:a91a60357667041e297498915a2313205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the last completed read finished the current message. <br /></td></tr>
<tr class="separator:a91a60357667041e297498915a2313205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d416ef4de71bb5693ab3262c799b7ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1beast_1_1websocket_1_1close__reason.html">close_reason</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a4d416ef4de71bb5693ab3262c799b7ff">reason</a> () const noexcept</td></tr>
<tr class="separator:a4d416ef4de71bb5693ab3262c799b7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6708109e68191a15ed63c3fdcd32aede"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a6708109e68191a15ed63c3fdcd32aede">read_size_hint</a> (std::size_t initial_size=+tcp_frame_size) const</td></tr>
<tr class="separator:a6708109e68191a15ed63c3fdcd32aede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d77597e4be21a42cc89df7f69407119"><td class="memTemplParams" colspan="2">template&lt;class DynamicBuffer , class  = typename std::enable_if&lt;            ! std::is_integral&lt;DynamicBuffer&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a1d77597e4be21a42cc89df7f69407119"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a1d77597e4be21a42cc89df7f69407119">read_size_hint</a> (DynamicBuffer &amp;buffer) const</td></tr>
<tr class="separator:a1d77597e4be21a42cc89df7f69407119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3939645cf0861c4ffd96e935763ec3d6"><td class="memItemLeft" align="right" valign="top"><a id="a3939645cf0861c4ffd96e935763ec3d6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_option</b> (<a class="el" href="classboost_1_1beast_1_1websocket_1_1stream__base_1_1decorator.html">decorator</a> opt)</td></tr>
<tr class="separator:a3939645cf0861c4ffd96e935763ec3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01aa08af3085433e72583d7821520c4"><td class="memItemLeft" align="right" valign="top"><a id="ae01aa08af3085433e72583d7821520c4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>get_option</b> (<a class="el" href="structboost_1_1beast_1_1websocket_1_1stream__base_1_1timeout.html">timeout</a> &amp;opt)</td></tr>
<tr class="separator:ae01aa08af3085433e72583d7821520c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5a71ad029f9c8c40b5b7c7f8cb9098"><td class="memItemLeft" align="right" valign="top"><a id="a5c5a71ad029f9c8c40b5b7c7f8cb9098"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_option</b> (<a class="el" href="structboost_1_1beast_1_1websocket_1_1stream__base_1_1timeout.html">timeout</a> const &amp;opt)</td></tr>
<tr class="separator:a5c5a71ad029f9c8c40b5b7c7f8cb9098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba6e0873d5a4c25bc3bfa6b9b07bea1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#abba6e0873d5a4c25bc3bfa6b9b07bea1">set_option</a> (<a class="el" href="structboost_1_1beast_1_1websocket_1_1permessage__deflate.html">permessage_deflate</a> const &amp;o)</td></tr>
<tr class="separator:abba6e0873d5a4c25bc3bfa6b9b07bea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae203d157f68e6dca41dadec6ad04c717"><td class="memItemLeft" align="right" valign="top"><a id="ae203d157f68e6dca41dadec6ad04c717"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ae203d157f68e6dca41dadec6ad04c717">get_option</a> (<a class="el" href="structboost_1_1beast_1_1websocket_1_1permessage__deflate.html">permessage_deflate</a> &amp;o)</td></tr>
<tr class="memdesc:ae203d157f68e6dca41dadec6ad04c717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the permessage-deflate extension options <br /></td></tr>
<tr class="separator:ae203d157f68e6dca41dadec6ad04c717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad916dc41cffddf485355ef749ebdb6c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ad916dc41cffddf485355ef749ebdb6c1">auto_fragment</a> (bool value)</td></tr>
<tr class="separator:ad916dc41cffddf485355ef749ebdb6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf3aa4b53cd0331f6765389b0f734816"><td class="memItemLeft" align="right" valign="top"><a id="abf3aa4b53cd0331f6765389b0f734816"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#abf3aa4b53cd0331f6765389b0f734816">auto_fragment</a> () const</td></tr>
<tr class="memdesc:abf3aa4b53cd0331f6765389b0f734816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the automatic fragmentation option is set. <br /></td></tr>
<tr class="separator:abf3aa4b53cd0331f6765389b0f734816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc58448ca669614fd60c6c1d22ba7a41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#acc58448ca669614fd60c6c1d22ba7a41">binary</a> (bool value)</td></tr>
<tr class="separator:acc58448ca669614fd60c6c1d22ba7a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d6b84487a2556ef041611c45eb90ff"><td class="memItemLeft" align="right" valign="top"><a id="a32d6b84487a2556ef041611c45eb90ff"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a32d6b84487a2556ef041611c45eb90ff">binary</a> () const</td></tr>
<tr class="memdesc:a32d6b84487a2556ef041611c45eb90ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the binary message write option is set. <br /></td></tr>
<tr class="separator:a32d6b84487a2556ef041611c45eb90ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bfb1d3554e748cb0feb364626c15e73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a6bfb1d3554e748cb0feb364626c15e73">control_callback</a> (std::function&lt; void(frame_type, <a class="el" href="classboost_1_1basic__string__view.html">string_view</a>)&gt; cb)</td></tr>
<tr class="separator:a6bfb1d3554e748cb0feb364626c15e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab965b22b5b347ce06ee7b43b153008a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ab965b22b5b347ce06ee7b43b153008a2">control_callback</a> ()</td></tr>
<tr class="separator:ab965b22b5b347ce06ee7b43b153008a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ee32a8c28369a70ada79ec0ddfb384"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a75ee32a8c28369a70ada79ec0ddfb384">read_message_max</a> (std::size_t amount)</td></tr>
<tr class="separator:a75ee32a8c28369a70ada79ec0ddfb384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0095b4c31230dcaf8850035d6ad620a0"><td class="memItemLeft" align="right" valign="top"><a id="a0095b4c31230dcaf8850035d6ad620a0"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a0095b4c31230dcaf8850035d6ad620a0">read_message_max</a> () const</td></tr>
<tr class="memdesc:a0095b4c31230dcaf8850035d6ad620a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum incoming message size setting. <br /></td></tr>
<tr class="separator:a0095b4c31230dcaf8850035d6ad620a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea44d6b84f054bff2dcf52915070435"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a2ea44d6b84f054bff2dcf52915070435">secure_prng</a> (bool value)</td></tr>
<tr class="separator:a2ea44d6b84f054bff2dcf52915070435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e864693b45a726dac0bccacbcb94049"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a2e864693b45a726dac0bccacbcb94049">write_buffer_bytes</a> (std::size_t amount)</td></tr>
<tr class="separator:a2e864693b45a726dac0bccacbcb94049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e378e5f6cf61c86602c354cf261933b"><td class="memItemLeft" align="right" valign="top"><a id="a8e378e5f6cf61c86602c354cf261933b"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a8e378e5f6cf61c86602c354cf261933b">write_buffer_bytes</a> () const</td></tr>
<tr class="memdesc:a8e378e5f6cf61c86602c354cf261933b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the write buffer. <br /></td></tr>
<tr class="separator:a8e378e5f6cf61c86602c354cf261933b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e77bd4c9cf9d84f936439a14d88d6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a90e77bd4c9cf9d84f936439a14d88d6a">text</a> (bool value)</td></tr>
<tr class="separator:a90e77bd4c9cf9d84f936439a14d88d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb04699c02e36b2091da9802cd421f38"><td class="memItemLeft" align="right" valign="top"><a id="acb04699c02e36b2091da9802cd421f38"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#acb04699c02e36b2091da9802cd421f38">text</a> () const</td></tr>
<tr class="memdesc:acb04699c02e36b2091da9802cd421f38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the text message write option is set. <br /></td></tr>
<tr class="separator:acb04699c02e36b2091da9802cd421f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1986d6a1ae4a37100c00cb8ead32f97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aa1986d6a1ae4a37100c00cb8ead32f97">handshake</a> (<a class="el" href="classboost_1_1basic__string__view.html">string_view</a> host, <a class="el" href="classboost_1_1basic__string__view.html">string_view</a> target)</td></tr>
<tr class="separator:aa1986d6a1ae4a37100c00cb8ead32f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588d36ce6893e73e4e443c12902a89f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a588d36ce6893e73e4e443c12902a89f8">handshake</a> (<a class="el" href="classboost_1_1beast_1_1http_1_1message.html">response_type</a> &amp;res, <a class="el" href="classboost_1_1basic__string__view.html">string_view</a> host, <a class="el" href="classboost_1_1basic__string__view.html">string_view</a> target)</td></tr>
<tr class="separator:a588d36ce6893e73e4e443c12902a89f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d521fdcd6d34bfddee162e5d59da606"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a4d521fdcd6d34bfddee162e5d59da606">handshake</a> (<a class="el" href="classboost_1_1basic__string__view.html">string_view</a> host, <a class="el" href="classboost_1_1basic__string__view.html">string_view</a> target, <a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;ec)</td></tr>
<tr class="separator:a4d521fdcd6d34bfddee162e5d59da606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4c54655ff83efc1404721ccd1025b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a1a4c54655ff83efc1404721ccd1025b5">handshake</a> (<a class="el" href="classboost_1_1beast_1_1http_1_1message.html">response_type</a> &amp;res, <a class="el" href="classboost_1_1basic__string__view.html">string_view</a> host, <a class="el" href="classboost_1_1basic__string__view.html">string_view</a> target, <a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;ec)</td></tr>
<tr class="separator:a1a4c54655ff83efc1404721ccd1025b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388b4d3398f25aa4551b4633253b3c9a"><td class="memTemplParams" colspan="2">template&lt;BOOST_BEAST_ASYNC_TPARAM1 HandshakeHandler = net::default_completion_token_t&lt;executor_type&gt;&gt; </td></tr>
<tr class="memitem:a388b4d3398f25aa4551b4633253b3c9a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a388b4d3398f25aa4551b4633253b3c9a">async_handshake</a> (<a class="el" href="classboost_1_1basic__string__view.html">string_view</a> host, <a class="el" href="classboost_1_1basic__string__view.html">string_view</a> target, HandshakeHandler &amp;&amp;handler=net::default_completion_token_t&lt; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a94d4fcaa810123a537bec2db4f34f571">executor_type</a> &gt;{})</td></tr>
<tr class="separator:a388b4d3398f25aa4551b4633253b3c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44ac91181b1ae869dd8a4db7d469a98"><td class="memTemplParams" colspan="2">template&lt;BOOST_BEAST_ASYNC_TPARAM1 HandshakeHandler = net::default_completion_token_t&lt;executor_type&gt;&gt; </td></tr>
<tr class="memitem:af44ac91181b1ae869dd8a4db7d469a98"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#af44ac91181b1ae869dd8a4db7d469a98">async_handshake</a> (<a class="el" href="classboost_1_1beast_1_1http_1_1message.html">response_type</a> &amp;res, <a class="el" href="classboost_1_1basic__string__view.html">string_view</a> host, <a class="el" href="classboost_1_1basic__string__view.html">string_view</a> target, HandshakeHandler &amp;&amp;handler=net::default_completion_token_t&lt; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a94d4fcaa810123a537bec2db4f34f571">executor_type</a> &gt;{})</td></tr>
<tr class="separator:af44ac91181b1ae869dd8a4db7d469a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96502e3f40d454b14a5cb97f4c06151c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a96502e3f40d454b14a5cb97f4c06151c">accept</a> ()</td></tr>
<tr class="separator:a96502e3f40d454b14a5cb97f4c06151c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3874db75d988678145b0de12934f19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a3c3874db75d988678145b0de12934f19">accept</a> (<a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;ec)</td></tr>
<tr class="separator:a3c3874db75d988678145b0de12934f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f30a512ebaafd3f71d1793436765d58"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence &gt; </td></tr>
<tr class="memitem:a4f30a512ebaafd3f71d1793436765d58"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;! http::detail::is_header&lt; ConstBufferSequence &gt;::value &gt;::<a class="el" href="structboost_1_1type.html">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a4f30a512ebaafd3f71d1793436765d58">accept</a> (ConstBufferSequence const &amp;buffers)</td></tr>
<tr class="separator:a4f30a512ebaafd3f71d1793436765d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0942072d34beecd9e12905b474e6512"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence &gt; </td></tr>
<tr class="memitem:ab0942072d34beecd9e12905b474e6512"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;! http::detail::is_header&lt; ConstBufferSequence &gt;::value &gt;::<a class="el" href="structboost_1_1type.html">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ab0942072d34beecd9e12905b474e6512">accept</a> (ConstBufferSequence const &amp;buffers, <a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;ec)</td></tr>
<tr class="separator:ab0942072d34beecd9e12905b474e6512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95c313da0f13648161387d3dbc8ca70"><td class="memTemplParams" colspan="2">template&lt;class Body , class Allocator &gt; </td></tr>
<tr class="memitem:af95c313da0f13648161387d3dbc8ca70"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#af95c313da0f13648161387d3dbc8ca70">accept</a> (<a class="el" href="classboost_1_1beast_1_1http_1_1message.html">http::request</a>&lt; Body, <a class="el" href="classboost_1_1beast_1_1http_1_1basic__fields.html">http::basic_fields</a>&lt; Allocator &gt;&gt; const &amp;req)</td></tr>
<tr class="separator:af95c313da0f13648161387d3dbc8ca70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b8d0e6d49f5b503895578e5700fad9"><td class="memTemplParams" colspan="2">template&lt;class Body , class Allocator &gt; </td></tr>
<tr class="memitem:ac8b8d0e6d49f5b503895578e5700fad9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ac8b8d0e6d49f5b503895578e5700fad9">accept</a> (<a class="el" href="classboost_1_1beast_1_1http_1_1message.html">http::request</a>&lt; Body, <a class="el" href="classboost_1_1beast_1_1http_1_1basic__fields.html">http::basic_fields</a>&lt; Allocator &gt;&gt; const &amp;req, <a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;ec)</td></tr>
<tr class="separator:ac8b8d0e6d49f5b503895578e5700fad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9da6f7155ea07858361d1ae6f7b92a"><td class="memTemplParams" colspan="2">template&lt;BOOST_BEAST_ASYNC_TPARAM1 AcceptHandler = net::default_completion_token_t&lt;executor_type&gt;&gt; </td></tr>
<tr class="memitem:a6e9da6f7155ea07858361d1ae6f7b92a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a6e9da6f7155ea07858361d1ae6f7b92a">async_accept</a> (AcceptHandler &amp;&amp;handler=net::default_completion_token_t&lt; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a94d4fcaa810123a537bec2db4f34f571">executor_type</a> &gt;{})</td></tr>
<tr class="separator:a6e9da6f7155ea07858361d1ae6f7b92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9c0cfdcd889b51e8a379c1a262e4e6"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence , BOOST_BEAST_ASYNC_TPARAM1 AcceptHandler = net::default_completion_token_t&lt;executor_type&gt;&gt; </td></tr>
<tr class="memitem:aea9c0cfdcd889b51e8a379c1a262e4e6"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aea9c0cfdcd889b51e8a379c1a262e4e6">async_accept</a> (ConstBufferSequence const &amp;buffers, AcceptHandler &amp;&amp;handler=net::default_completion_token_t&lt; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a94d4fcaa810123a537bec2db4f34f571">executor_type</a> &gt;{}, typename std::enable_if&lt; ! http::detail::is_header&lt; ConstBufferSequence &gt;::value &gt;::<a class="el" href="structboost_1_1type.html">type</a> *=0)</td></tr>
<tr class="separator:aea9c0cfdcd889b51e8a379c1a262e4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7dfdb5ee1cdbbbe2b097f0b3f7b32e"><td class="memTemplParams" colspan="2">template&lt;class Body , class Allocator , BOOST_BEAST_ASYNC_TPARAM1 AcceptHandler = net::default_completion_token_t&lt;executor_type&gt;&gt; </td></tr>
<tr class="memitem:a4d7dfdb5ee1cdbbbe2b097f0b3f7b32e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a4d7dfdb5ee1cdbbbe2b097f0b3f7b32e">async_accept</a> (<a class="el" href="classboost_1_1beast_1_1http_1_1message.html">http::request</a>&lt; Body, <a class="el" href="classboost_1_1beast_1_1http_1_1basic__fields.html">http::basic_fields</a>&lt; Allocator &gt;&gt; const &amp;req, AcceptHandler &amp;&amp;handler=net::default_completion_token_t&lt; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a94d4fcaa810123a537bec2db4f34f571">executor_type</a> &gt;{})</td></tr>
<tr class="separator:a4d7dfdb5ee1cdbbbe2b097f0b3f7b32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5fe1bfe3738755b3d803e14a34c441"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a5e5fe1bfe3738755b3d803e14a34c441">close</a> (<a class="el" href="structboost_1_1beast_1_1websocket_1_1close__reason.html">close_reason</a> const &amp;cr)</td></tr>
<tr class="separator:a5e5fe1bfe3738755b3d803e14a34c441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eaec0b88bb7740b1d15e24d0d380914"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a1eaec0b88bb7740b1d15e24d0d380914">close</a> (<a class="el" href="structboost_1_1beast_1_1websocket_1_1close__reason.html">close_reason</a> const &amp;cr, <a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;ec)</td></tr>
<tr class="separator:a1eaec0b88bb7740b1d15e24d0d380914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b8f649ccc95a39d9a4a90ba510bb25"><td class="memTemplParams" colspan="2">template&lt;BOOST_BEAST_ASYNC_TPARAM1 CloseHandler = net::default_completion_token_t&lt;executor_type&gt;&gt; </td></tr>
<tr class="memitem:ab1b8f649ccc95a39d9a4a90ba510bb25"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ab1b8f649ccc95a39d9a4a90ba510bb25">async_close</a> (<a class="el" href="structboost_1_1beast_1_1websocket_1_1close__reason.html">close_reason</a> const &amp;cr, CloseHandler &amp;&amp;handler=net::default_completion_token_t&lt; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a94d4fcaa810123a537bec2db4f34f571">executor_type</a> &gt;{})</td></tr>
<tr class="separator:ab1b8f649ccc95a39d9a4a90ba510bb25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1be27bcd0a633101b905cfa73e5572"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a4b1be27bcd0a633101b905cfa73e5572">ping</a> (<a class="el" href="classboost_1_1beast_1_1static__string.html">ping_data</a> const &amp;payload)</td></tr>
<tr class="separator:a4b1be27bcd0a633101b905cfa73e5572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c62d6f360f3c0a5ee94b7547cace8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a17c62d6f360f3c0a5ee94b7547cace8f">ping</a> (<a class="el" href="classboost_1_1beast_1_1static__string.html">ping_data</a> const &amp;payload, <a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;ec)</td></tr>
<tr class="separator:a17c62d6f360f3c0a5ee94b7547cace8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa6ad0bab1c6dcc9010a1e23825c488"><td class="memTemplParams" colspan="2">template&lt;BOOST_BEAST_ASYNC_TPARAM1 WriteHandler = net::default_completion_token_t&lt;executor_type&gt;&gt; </td></tr>
<tr class="memitem:abaa6ad0bab1c6dcc9010a1e23825c488"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#abaa6ad0bab1c6dcc9010a1e23825c488">async_ping</a> (<a class="el" href="classboost_1_1beast_1_1static__string.html">ping_data</a> const &amp;payload, WriteHandler &amp;&amp;handler=net::default_completion_token_t&lt; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a94d4fcaa810123a537bec2db4f34f571">executor_type</a> &gt;{})</td></tr>
<tr class="separator:abaa6ad0bab1c6dcc9010a1e23825c488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3755888fda2a3bec91a34ccfd47e83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aab3755888fda2a3bec91a34ccfd47e83">pong</a> (<a class="el" href="classboost_1_1beast_1_1static__string.html">ping_data</a> const &amp;payload)</td></tr>
<tr class="separator:aab3755888fda2a3bec91a34ccfd47e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4807fb7780222de88ede8103a97ffdcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a4807fb7780222de88ede8103a97ffdcc">pong</a> (<a class="el" href="classboost_1_1beast_1_1static__string.html">ping_data</a> const &amp;payload, <a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;ec)</td></tr>
<tr class="separator:a4807fb7780222de88ede8103a97ffdcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6bcb559711c00eaebcc48c747cc88ca"><td class="memTemplParams" colspan="2">template&lt;BOOST_BEAST_ASYNC_TPARAM1 WriteHandler = net::default_completion_token_t&lt;executor_type&gt;&gt; </td></tr>
<tr class="memitem:ac6bcb559711c00eaebcc48c747cc88ca"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ac6bcb559711c00eaebcc48c747cc88ca">async_pong</a> (<a class="el" href="classboost_1_1beast_1_1static__string.html">ping_data</a> const &amp;payload, WriteHandler &amp;&amp;handler=net::default_completion_token_t&lt; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a94d4fcaa810123a537bec2db4f34f571">executor_type</a> &gt;{})</td></tr>
<tr class="separator:ac6bcb559711c00eaebcc48c747cc88ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d980208560268fc6e2c6df616fd8ad"><td class="memTemplParams" colspan="2">template&lt;class DynamicBuffer &gt; </td></tr>
<tr class="memitem:a75d980208560268fc6e2c6df616fd8ad"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a75d980208560268fc6e2c6df616fd8ad">read</a> (DynamicBuffer &amp;buffer)</td></tr>
<tr class="separator:a75d980208560268fc6e2c6df616fd8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b9b73cf420c88e430129aad4edfda6"><td class="memTemplParams" colspan="2">template&lt;class DynamicBuffer &gt; </td></tr>
<tr class="memitem:af5b9b73cf420c88e430129aad4edfda6"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#af5b9b73cf420c88e430129aad4edfda6">read</a> (DynamicBuffer &amp;buffer, <a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;ec)</td></tr>
<tr class="separator:af5b9b73cf420c88e430129aad4edfda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa893761678723b6027335241fea5066a"><td class="memTemplParams" colspan="2">template&lt;class DynamicBuffer , BOOST_BEAST_ASYNC_TPARAM2 ReadHandler = net::default_completion_token_t&lt;                executor_type&gt;&gt; </td></tr>
<tr class="memitem:aa893761678723b6027335241fea5066a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aa893761678723b6027335241fea5066a">async_read</a> (DynamicBuffer &amp;buffer, ReadHandler &amp;&amp;handler=net::default_completion_token_t&lt; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a94d4fcaa810123a537bec2db4f34f571">executor_type</a> &gt;{})</td></tr>
<tr class="separator:aa893761678723b6027335241fea5066a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e720f4315b9633346b6c71bcb20a24"><td class="memTemplParams" colspan="2">template&lt;class DynamicBuffer &gt; </td></tr>
<tr class="memitem:a07e720f4315b9633346b6c71bcb20a24"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a07e720f4315b9633346b6c71bcb20a24">read_some</a> (DynamicBuffer &amp;buffer, std::size_t limit)</td></tr>
<tr class="separator:a07e720f4315b9633346b6c71bcb20a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54826115579bee3ae31588b70fdb1dbd"><td class="memTemplParams" colspan="2">template&lt;class DynamicBuffer &gt; </td></tr>
<tr class="memitem:a54826115579bee3ae31588b70fdb1dbd"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a54826115579bee3ae31588b70fdb1dbd">read_some</a> (DynamicBuffer &amp;buffer, std::size_t limit, <a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;ec)</td></tr>
<tr class="separator:a54826115579bee3ae31588b70fdb1dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95353ee5a3212cd4934bd09396c99ff4"><td class="memTemplParams" colspan="2">template&lt;class DynamicBuffer , BOOST_BEAST_ASYNC_TPARAM2 ReadHandler = net::default_completion_token_t&lt;                executor_type&gt;&gt; </td></tr>
<tr class="memitem:a95353ee5a3212cd4934bd09396c99ff4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a95353ee5a3212cd4934bd09396c99ff4">async_read_some</a> (DynamicBuffer &amp;buffer, std::size_t limit, ReadHandler &amp;&amp;handler=net::default_completion_token_t&lt; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a94d4fcaa810123a537bec2db4f34f571">executor_type</a> &gt;{})</td></tr>
<tr class="separator:a95353ee5a3212cd4934bd09396c99ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60eb9a8bab2d7ec1f36e78018a77e4bc"><td class="memTemplParams" colspan="2">template&lt;class MutableBufferSequence &gt; </td></tr>
<tr class="memitem:a60eb9a8bab2d7ec1f36e78018a77e4bc"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a60eb9a8bab2d7ec1f36e78018a77e4bc">read_some</a> (MutableBufferSequence const &amp;buffers)</td></tr>
<tr class="separator:a60eb9a8bab2d7ec1f36e78018a77e4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f1cde38b3c27e851438edadce48103"><td class="memTemplParams" colspan="2">template&lt;class MutableBufferSequence &gt; </td></tr>
<tr class="memitem:ae5f1cde38b3c27e851438edadce48103"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ae5f1cde38b3c27e851438edadce48103">read_some</a> (MutableBufferSequence const &amp;buffers, <a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;ec)</td></tr>
<tr class="separator:ae5f1cde38b3c27e851438edadce48103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5adf8821e718ebbf6e300ddc7f85f0a6"><td class="memTemplParams" colspan="2">template&lt;class MutableBufferSequence , BOOST_BEAST_ASYNC_TPARAM2 ReadHandler = net::default_completion_token_t&lt;                executor_type&gt;&gt; </td></tr>
<tr class="memitem:a5adf8821e718ebbf6e300ddc7f85f0a6"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a5adf8821e718ebbf6e300ddc7f85f0a6">async_read_some</a> (MutableBufferSequence const &amp;buffers, ReadHandler &amp;&amp;handler=net::default_completion_token_t&lt; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a94d4fcaa810123a537bec2db4f34f571">executor_type</a> &gt;{})</td></tr>
<tr class="separator:a5adf8821e718ebbf6e300ddc7f85f0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8566ba212251a0dafbc79a064edd8b5c"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence &gt; </td></tr>
<tr class="memitem:a8566ba212251a0dafbc79a064edd8b5c"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a8566ba212251a0dafbc79a064edd8b5c">write</a> (ConstBufferSequence const &amp;buffers)</td></tr>
<tr class="separator:a8566ba212251a0dafbc79a064edd8b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc50b5697f57374381d486c5f3ef3efd"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence &gt; </td></tr>
<tr class="memitem:adc50b5697f57374381d486c5f3ef3efd"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#adc50b5697f57374381d486c5f3ef3efd">write</a> (ConstBufferSequence const &amp;buffers, <a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;ec)</td></tr>
<tr class="separator:adc50b5697f57374381d486c5f3ef3efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a962763e4c65932898baf770569bdb1"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence , BOOST_BEAST_ASYNC_TPARAM2 WriteHandler = net::default_completion_token_t&lt;                executor_type&gt;&gt; </td></tr>
<tr class="memitem:a6a962763e4c65932898baf770569bdb1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a6a962763e4c65932898baf770569bdb1">async_write</a> (ConstBufferSequence const &amp;buffers, WriteHandler &amp;&amp;handler=net::default_completion_token_t&lt; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a94d4fcaa810123a537bec2db4f34f571">executor_type</a> &gt;{})</td></tr>
<tr class="separator:a6a962763e4c65932898baf770569bdb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89b2616d52318049135e78ecbb4b2f0"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence &gt; </td></tr>
<tr class="memitem:ab89b2616d52318049135e78ecbb4b2f0"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ab89b2616d52318049135e78ecbb4b2f0">write_some</a> (bool fin, ConstBufferSequence const &amp;buffers)</td></tr>
<tr class="separator:ab89b2616d52318049135e78ecbb4b2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475647c28dd13ee9414a3f53befcb417"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence &gt; </td></tr>
<tr class="memitem:a475647c28dd13ee9414a3f53befcb417"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a475647c28dd13ee9414a3f53befcb417">write_some</a> (bool fin, ConstBufferSequence const &amp;buffers, <a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;ec)</td></tr>
<tr class="separator:a475647c28dd13ee9414a3f53befcb417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ab9d05f08f7e7d83cc145db48865a4"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence , BOOST_BEAST_ASYNC_TPARAM2 WriteHandler = net::default_completion_token_t&lt;                executor_type&gt;&gt; </td></tr>
<tr class="memitem:af2ab9d05f08f7e7d83cc145db48865a4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#af2ab9d05f08f7e7d83cc145db48865a4">async_write_some</a> (bool fin, ConstBufferSequence const &amp;buffers, WriteHandler &amp;&amp;handler=net::default_completion_token_t&lt; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a94d4fcaa810123a537bec2db4f34f571">executor_type</a> &gt;{})</td></tr>
<tr class="separator:af2ab9d05f08f7e7d83cc145db48865a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
フレンド</h2></td></tr>
<tr class="memitem:ad5caf1a60ad298203711eedc002ebc19"><td class="memItemLeft" align="right" valign="top"><a id="ad5caf1a60ad298203711eedc002ebc19"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>close_test</b></td></tr>
<tr class="separator:ad5caf1a60ad298203711eedc002ebc19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70fd38b759202d7d18632bb8b6d8227"><td class="memItemLeft" align="right" valign="top"><a id="aa70fd38b759202d7d18632bb8b6d8227"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>frame_test</b></td></tr>
<tr class="separator:aa70fd38b759202d7d18632bb8b6d8227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72cfaba76b80cfb00ba0bcae616dc9d1"><td class="memItemLeft" align="right" valign="top"><a id="a72cfaba76b80cfb00ba0bcae616dc9d1"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ping_test</b></td></tr>
<tr class="separator:a72cfaba76b80cfb00ba0bcae616dc9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d2b54be1070f3b17c8ea648abd4fcf"><td class="memItemLeft" align="right" valign="top"><a id="a32d2b54be1070f3b17c8ea648abd4fcf"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>read2_test</b></td></tr>
<tr class="separator:a32d2b54be1070f3b17c8ea648abd4fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98ff85f916ff135249e99ecc03a97e7"><td class="memItemLeft" align="right" valign="top"><a id="aa98ff85f916ff135249e99ecc03a97e7"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>read3_test</b></td></tr>
<tr class="separator:aa98ff85f916ff135249e99ecc03a97e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa435e3810b5c6dc9008ee5fe2df01abd"><td class="memItemLeft" align="right" valign="top"><a id="aa435e3810b5c6dc9008ee5fe2df01abd"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>stream_test</b></td></tr>
<tr class="separator:aa435e3810b5c6dc9008ee5fe2df01abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc02be922bd83ae0b600f376165522db"><td class="memItemLeft" align="right" valign="top"><a id="adc02be922bd83ae0b600f376165522db"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>write_test</b></td></tr>
<tr class="separator:adc02be922bd83ae0b600f376165522db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">詳解</h2>
<div class="textblock"><h3>template&lt;class NextLayer, bool deflateSupported&gt;<br />
class boost::beast::websocket::stream&lt; NextLayer, deflateSupported &gt;</h3>

<p>Provides message-oriented functionality using WebSocket.</p>
<p>The <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">stream</a> class template provides asynchronous and blocking message-oriented functionality necessary for clients and servers to utilize the WebSocket protocol.</p>
<p>For asynchronous operations, the application must ensure that they are are all performed within the same implicit or explicit strand.</p>
<dl class="section user"><dt>Thread Safety</dt><dd><em>Distinct</em> <em>objects:</em> Safe.<br  />
<em>Shared</em> <em>objects:</em> Unsafe. The application must also ensure that all asynchronous operations are performed within the same implicit or explicit strand.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To declare the <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">stream</a> object with a tcp_stream in a multi-threaded asynchronous program using a strand, you may write: <div class="fragment"><div class="line">websocket::stream&lt;tcp_stream&gt; ws{net::make_strand(ioc)};</div>
</div><!-- fragment --> Alternatively, for a single-threaded or synchronous application you may write: <div class="fragment"><div class="line">websocket::stream&lt;tcp_stream&gt; ws(ioc);</div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NextLayer</td><td>The type representing the next layer, to which data will be read and written during operations. For synchronous operations, the type must support the <em>SyncStream</em> concept. For asynchronous operations, the type must support the <em>AsyncStream</em> concept.</td></tr>
    <tr><td class="paramname">deflateSupported</td><td>A <code>bool</code> indicating whether or not the stream will be capable of negotiating the permessage-deflate websocket extension. Note that even if this is set to <code>true</code>, the permessage deflate options (set by the caller at runtime) must still have the feature enabled for a successful negotiation to occur.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>A stream object must not be moved or destroyed while there are pending asynchronous operations associated with it.</dd></dl>
<dl class="section user"><dt>Concepts</dt><dd><ul>
<li><em>AsyncStream</em> </li>
<li><em>DynamicBuffer</em> </li>
<li><em>SyncStream</em></li>
</ul>
</dd></dl>
<dl class="section see"><dt>参照</dt><dd><ul>
<li><a href="https://tools.ietf.org/html/rfc6455#section-4.1">Websocket Opening Handshake Client Requirements (RFC6455)</a> </li>
<li><a href="https://tools.ietf.org/html/rfc6455#section-4.2">Websocket Opening Handshake Server Requirements (RFC6455)</a> </li>
<li><a href="https://tools.ietf.org/html/rfc6455#section-7.1.2">Websocket Closing Handshake (RFC6455)</a> </li>
<li><a href="https://tools.ietf.org/html/rfc6455#section-5.5.1">Websocket Close (RFC6455)</a> </li>
<li><a href="https://tools.ietf.org/html/rfc6455#section-5.5.2">WebSocket Ping (RFC6455)</a> </li>
<li><a href="https://tools.ietf.org/html/rfc6455#section-5.5.3">WebSocket Pong (RFC6455)</a> </li>
<li><a href="https://tools.ietf.org/html/rfc7230#section-5.4">Host field (RFC7230)</a> </li>
<li><a href="https://tools.ietf.org/html/rfc7230#section-3.1.1">request-target (RFC7230)</a> </li>
<li><a href="https://tools.ietf.org/html/rfc7230#section-5.3.1">origin-form (RFC7230)</a> </li>
</ul>
</dd></dl>
</div><h2 class="groupheader">構築子と解体子</h2>
<a id="a063c8449d4c3736c2de1ad579d9c6f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a063c8449d4c3736c2de1ad579d9c6f24">&#9670;&nbsp;</a></span>~stream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::~<a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">stream</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor</p>
<p>Destroys the stream and all associated resources.</p>
<dl class="section note"><dt>覚え書き</dt><dd>A stream object must not be destroyed while there are pending asynchronous operations associated with it. </dd></dl>

</div>
</div>
<a id="a6bc5b73b681c878a950b31395b384d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc5b73b681c878a950b31395b384d45">&#9670;&nbsp;</a></span>stream() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::<a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">stream</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">stream</a>&lt; NextLayer, deflateSupported &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor</p>
<p>If <code>NextLayer</code> is move constructible, this function will move-construct a new stream from the existing stream.</p>
<p>After the move, the only valid operation on the moved-from object is destruction. </p>

</div>
</div>
<a id="afbc2da4a8c4afa4b2f7d3bd0e7ae8e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc2da4a8c4afa4b2f7d3bd0e7ae8e25">&#9670;&nbsp;</a></span>stream() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::<a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">stream</a> </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor</p>
<p>This constructor creates a websocket stream and initializes the next layer object.</p>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Any</td><td>exceptions thrown by the NextLayer constructor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>The arguments to be passed to initialize the next layer object. The arguments are forwarded to the next layer's constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">関数詳解</h2>
<a id="a96502e3f40d454b14a5cb97f4c06151c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96502e3f40d454b14a5cb97f4c06151c">&#9670;&nbsp;</a></span>accept() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::accept</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform the WebSocket handshake in the server role.</p>
<p>This function is used to perform the <a href="https://en.wikipedia.org/wiki/WebSocket#Protocol_handshake">WebSocket handshake</a>, required before messages can be sent and received. During the handshake, the client sends the Websocket Upgrade HTTP request, and the server replies with an HTTP response indicating the result of the handshake.</p>
<p>The call blocks until one of the following conditions is true:</p>
<ul>
<li>The request is received and the response is sent.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed operation</em>, is implemented in terms of calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>If a valid upgrade request is received, an HTTP response with a <a href="https://tools.ietf.org/html/rfc7230#section-3.1.2">status-code</a> of beast::http::status::switching_protocols is sent to the peer, otherwise a non-successful error is associated with the operation.</p>
<p>If the request size exceeds the capacity of the stream's internal buffer, the error error::buffer_overflow will be indicated. To handle larger requests, an application should read the HTTP request directly using <a href="http::read">http::read</a> and then pass the request to the appropriate overload of <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a96502e3f40d454b14a5cb97f4c06151c">accept</a> or <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a6e9da6f7155ea07858361d1ae6f7b92a">async_accept</a></p>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>参照</dt><dd><ul>
<li><a href="https://tools.ietf.org/html/rfc6455#section-4.2">Websocket Opening Handshake Server Requirements (RFC6455)</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a4f30a512ebaafd3f71d1793436765d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f30a512ebaafd3f71d1793436765d58">&#9670;&nbsp;</a></span>accept() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;! http::detail::is_header&lt; ConstBufferSequence &gt;::value &gt;::<a class="el" href="structboost_1_1type.html">type</a> <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::accept </td>
          <td>(</td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read and respond to a WebSocket HTTP Upgrade request.</p>
<p>This function is used to perform the <a href="https://en.wikipedia.org/wiki/WebSocket#Protocol_handshake">WebSocket handshake</a>, required before messages can be sent and received. During the handshake, the client sends the Websocket Upgrade HTTP request, and the server replies with an HTTP response indicating the result of the handshake.</p>
<p>The call blocks until one of the following conditions is true:</p>
<ul>
<li>The request is received and the response is sent.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed operation</em>, is implemented in terms of calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>If a valid upgrade request is received, an HTTP response with a <a href="https://tools.ietf.org/html/rfc7230#section-3.1.2">status-code</a> of beast::http::status::switching_protocols is sent to the peer, otherwise a non-successful error is associated with the operation.</p>
<p>If the request size exceeds the capacity of the stream's internal buffer, the error error::buffer_overflow will be indicated. To handle larger requests, an application should read the HTTP request directly using <a href="http::read">http::read</a> and then pass the request to the appropriate overload of <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a96502e3f40d454b14a5cb97f4c06151c">accept</a> or <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a6e9da6f7155ea07858361d1ae6f7b92a">async_accept</a></p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>Caller provided data that has already been received on the stream. The implementation will copy the caller provided data before the function returns.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>参照</dt><dd><ul>
<li><a href="https://tools.ietf.org/html/rfc6455#section-4.2">Websocket Opening Handshake Server Requirements (RFC6455)</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ab0942072d34beecd9e12905b474e6512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0942072d34beecd9e12905b474e6512">&#9670;&nbsp;</a></span>accept() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;! http::detail::is_header&lt; ConstBufferSequence &gt;::value &gt;::<a class="el" href="structboost_1_1type.html">type</a> <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::accept </td>
          <td>(</td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read and respond to a WebSocket HTTP Upgrade request.</p>
<p>This function is used to perform the <a href="https://en.wikipedia.org/wiki/WebSocket#Protocol_handshake">WebSocket handshake</a>, required before messages can be sent and received. During the handshake, the client sends the Websocket Upgrade HTTP request, and the server replies with an HTTP response indicating the result of the handshake.</p>
<p>The call blocks until one of the following conditions is true:</p>
<ul>
<li>The request is received and the response is sent.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed operation</em>, is implemented in terms of calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>If a valid upgrade request is received, an HTTP response with a <a href="https://tools.ietf.org/html/rfc7230#section-3.1.2">status-code</a> of beast::http::status::switching_protocols is sent to the peer, otherwise a non-successful error is associated with the operation.</p>
<p>If the request size exceeds the capacity of the stream's internal buffer, the error error::buffer_overflow will be indicated. To handle larger requests, an application should read the HTTP request directly using <a href="http::read">http::read</a> and then pass the request to the appropriate overload of <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a96502e3f40d454b14a5cb97f4c06151c">accept</a> or <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a6e9da6f7155ea07858361d1ae6f7b92a">async_accept</a></p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>Caller provided data that has already been received on the stream. The implementation will copy the caller provided data before the function returns.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>参照</dt><dd><ul>
<li><a href="https://tools.ietf.org/html/rfc6455#section-4.2">Websocket Opening Handshake Server Requirements (RFC6455)</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a3c3874db75d988678145b0de12934f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c3874db75d988678145b0de12934f19">&#9670;&nbsp;</a></span>accept() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read and respond to a WebSocket HTTP Upgrade request.</p>
<p>This function is used to perform the <a href="https://en.wikipedia.org/wiki/WebSocket#Protocol_handshake">WebSocket handshake</a>, required before messages can be sent and received. During the handshake, the client sends the Websocket Upgrade HTTP request, and the server replies with an HTTP response indicating the result of the handshake.</p>
<p>The call blocks until one of the following conditions is true:</p>
<ul>
<li>The request is received and the response is sent.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed operation</em>, is implemented in terms of calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>If a valid upgrade request is received, an HTTP response with a <a href="https://tools.ietf.org/html/rfc7230#section-3.1.2">status-code</a> of beast::http::status::switching_protocols is sent to the peer, otherwise a non-successful error is associated with the operation.</p>
<p>If the request size exceeds the capacity of the stream's internal buffer, the error error::buffer_overflow will be indicated. To handle larger requests, an application should read the HTTP request directly using <a href="http::read">http::read</a> and then pass the request to the appropriate overload of <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a96502e3f40d454b14a5cb97f4c06151c">accept</a> or <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a6e9da6f7155ea07858361d1ae6f7b92a">async_accept</a></p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>参照</dt><dd><ul>
<li><a href="https://tools.ietf.org/html/rfc6455#section-4.2">Websocket Opening Handshake Server Requirements (RFC6455)</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af95c313da0f13648161387d3dbc8ca70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95c313da0f13648161387d3dbc8ca70">&#9670;&nbsp;</a></span>accept() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
<div class="memtemplate">
template&lt;class Body , class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1http_1_1message.html">http::request</a>&lt; Body, <a class="el" href="classboost_1_1beast_1_1http_1_1basic__fields.html">http::basic_fields</a>&lt; Allocator &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Respond to a WebSocket HTTP Upgrade request</p>
<p>This function is used to perform the <a href="https://en.wikipedia.org/wiki/WebSocket#Protocol_handshake">WebSocket handshake</a>, required before messages can be sent and received. During the handshake, the client sends the Websocket Upgrade HTTP request, and the server replies with an HTTP response indicating the result of the handshake.</p>
<p>The call blocks until one of the following conditions is true:</p>
<ul>
<li>The response is sent.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed operation</em>, is implemented in terms of calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>If a valid upgrade request is received, an HTTP response with a <a href="https://tools.ietf.org/html/rfc7230#section-3.1.2">status-code</a> of beast::http::status::switching_protocols is sent to the peer, otherwise a non-successful error is associated with the operation.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>An object containing the HTTP Upgrade request. Ownership is not transferred, the implementation will not access this object from other threads.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>参照</dt><dd><ul>
<li><a href="https://tools.ietf.org/html/rfc6455#section-4.2">Websocket Opening Handshake Server Requirements (RFC6455)</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac8b8d0e6d49f5b503895578e5700fad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b8d0e6d49f5b503895578e5700fad9">&#9670;&nbsp;</a></span>accept() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
<div class="memtemplate">
template&lt;class Body , class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1http_1_1message.html">http::request</a>&lt; Body, <a class="el" href="classboost_1_1beast_1_1http_1_1basic__fields.html">http::basic_fields</a>&lt; Allocator &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Respond to a WebSocket HTTP Upgrade request</p>
<p>This function is used to perform the <a href="https://en.wikipedia.org/wiki/WebSocket#Protocol_handshake">WebSocket handshake</a>, required before messages can be sent and received. During the handshake, the client sends the Websocket Upgrade HTTP request, and the server replies with an HTTP response indicating the result of the handshake.</p>
<p>The call blocks until one of the following conditions is true:</p>
<ul>
<li>The response is sent.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed operation</em>, is implemented in terms of calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>If a valid upgrade request is received, an HTTP response with a <a href="https://tools.ietf.org/html/rfc7230#section-3.1.2">status-code</a> of beast::http::status::switching_protocols is sent to the peer, otherwise a non-successful error is associated with the operation.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>An object containing the HTTP Upgrade request. Ownership is not transferred, the implementation will not access this object from other threads.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>参照</dt><dd><ul>
<li><a href="https://tools.ietf.org/html/rfc6455#section-4.2">Websocket Opening Handshake Server Requirements (RFC6455)</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a6e9da6f7155ea07858361d1ae6f7b92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e9da6f7155ea07858361d1ae6f7b92a">&#9670;&nbsp;</a></span>async_accept() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
<div class="memtemplate">
template&lt;BOOST_BEAST_ASYNC_TPARAM1 AcceptHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::async_accept </td>
          <td>(</td>
          <td class="paramtype">AcceptHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em> = <code>net::default_completion_token_t&lt;&#160;<a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a94d4fcaa810123a537bec2db4f34f571">executor_type</a>&gt;{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform the WebSocket handshake asynchronously in the server role.</p>
<p>This initiating function is used to asynchronously begin performing the <a href="https://en.wikipedia.org/wiki/WebSocket#Protocol_handshake">WebSocket handshake</a>, required before messages can be sent and received. During the handshake, the client sends the Websocket Upgrade HTTP request, and the server replies with an HTTP response indicating the result of the handshake.</p>
<p>This call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The request is received and the response is sent.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed asynchronous operation</em>, is implemented in terms of calls to the next layer's <code>async_read_some</code> and <code>async_write_some</code> functions. No other operation may be performed on the stream until this operation completes.</p>
<p>If a valid upgrade request is received, an HTTP response with a <a href="https://tools.ietf.org/html/rfc7230#section-3.1.2">status-code</a> of beast::http::status::switching_protocols is sent to the peer, otherwise a non-successful error is associated with the operation.</p>
<p>If the request size exceeds the capacity of the stream's internal buffer, the error error::buffer_overflow will be indicated. To handle larger requests, an application should read the HTTP request directly using <a href="http::async_read">http::async_read</a> and then pass the request to the appropriate overload of <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a96502e3f40d454b14a5cb97f4c06151c">accept</a> or <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a6e9da6f7155ea07858361d1ae6f7b92a">async_accept</a></p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(</div>
<div class="line">    error_code <span class="keyword">const</span>&amp; ec    <span class="comment">// Result of operation</span></div>
<div class="line">);</div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>net::post</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>参照</dt><dd><ul>
<li><a href="https://tools.ietf.org/html/rfc6455#section-4.2">Websocket Opening Handshake Server Requirements (RFC6455)</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aea9c0cfdcd889b51e8a379c1a262e4e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9c0cfdcd889b51e8a379c1a262e4e6">&#9670;&nbsp;</a></span>async_accept() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence , BOOST_BEAST_ASYNC_TPARAM1 AcceptHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::async_accept </td>
          <td>(</td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AcceptHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em> = <code>net::default_completion_token_t&lt;&#160;<a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a94d4fcaa810123a537bec2db4f34f571">executor_type</a>&gt;{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; ! http::detail::is_header&lt; ConstBufferSequence &gt;::value &gt;::<a class="el" href="structboost_1_1type.html">type</a> *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform the WebSocket handshake asynchronously in the server role.</p>
<p>This initiating function is used to asynchronously begin performing the <a href="https://en.wikipedia.org/wiki/WebSocket#Protocol_handshake">WebSocket handshake</a>, required before messages can be sent and received. During the handshake, the client sends the Websocket Upgrade HTTP request, and the server replies with an HTTP response indicating the result of the handshake.</p>
<p>This call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The request is received and the response is sent.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed asynchronous operation</em>, is implemented in terms of calls to the next layer's <code>async_read_some</code> and <code>async_write_some</code> functions. No other operation may be performed on the stream until this operation completes.</p>
<p>If a valid upgrade request is received, an HTTP response with a <a href="https://tools.ietf.org/html/rfc7230#section-3.1.2">status-code</a> of beast::http::status::switching_protocols is sent to the peer, otherwise a non-successful error is associated with the operation.</p>
<p>If the request size exceeds the capacity of the stream's internal buffer, the error error::buffer_overflow will be indicated. To handle larger requests, an application should read the HTTP request directly using <a href="http::async_read">http::async_read</a> and then pass the request to the appropriate overload of <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a96502e3f40d454b14a5cb97f4c06151c">accept</a> or <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a6e9da6f7155ea07858361d1ae6f7b92a">async_accept</a></p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>Caller provided data that has already been received on the stream. This may be used for implementations allowing multiple protocols on the same stream. The buffered data will first be applied to the handshake, and then to received WebSocket frames. The implementation will copy the caller provided data before the function returns.</td></tr>
    <tr><td class="paramname">handler</td><td>The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(</div>
<div class="line">    error_code <span class="keyword">const</span>&amp; ec    <span class="comment">// Result of operation</span></div>
<div class="line">);</div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>net::post</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>参照</dt><dd><ul>
<li><a href="https://tools.ietf.org/html/rfc6455#section-4.2">Websocket Opening Handshake Server Requirements (RFC6455)</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a4d7dfdb5ee1cdbbbe2b097f0b3f7b32e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d7dfdb5ee1cdbbbe2b097f0b3f7b32e">&#9670;&nbsp;</a></span>async_accept() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
<div class="memtemplate">
template&lt;class Body , class Allocator , BOOST_BEAST_ASYNC_TPARAM1 AcceptHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::async_accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1http_1_1message.html">http::request</a>&lt; Body, <a class="el" href="classboost_1_1beast_1_1http_1_1basic__fields.html">http::basic_fields</a>&lt; Allocator &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AcceptHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em> = <code>net::default_completion_token_t&lt;&#160;<a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a94d4fcaa810123a537bec2db4f34f571">executor_type</a>&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform the WebSocket handshake asynchronously in the server role.</p>
<p>This initiating function is used to asynchronously begin performing the <a href="https://en.wikipedia.org/wiki/WebSocket#Protocol_handshake">WebSocket handshake</a>, required before messages can be sent and received. During the handshake, the client sends the Websocket Upgrade HTTP request, and the server replies with an HTTP response indicating the result of the handshake.</p>
<p>This call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The request is received and the response is sent.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed asynchronous operation</em>, is implemented in terms of calls to the next layer's <code>async_read_some</code> and <code>async_write_some</code> functions. No other operation may be performed on the stream until this operation completes.</p>
<p>If a valid upgrade request is received, an HTTP response with a <a href="https://tools.ietf.org/html/rfc7230#section-3.1.2">status-code</a> of beast::http::status::switching_protocols is sent to the peer, otherwise a non-successful error is associated with the operation.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>An object containing the HTTP Upgrade request. Ownership is not transferred, the implementation will not access this object from other threads.</td></tr>
    <tr><td class="paramname">handler</td><td>The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(</div>
<div class="line">    error_code <span class="keyword">const</span>&amp; ec    <span class="comment">// Result of operation</span></div>
<div class="line">);</div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>net::post</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>参照</dt><dd><ul>
<li><a href="https://tools.ietf.org/html/rfc6455#section-4.2">Websocket Opening Handshake Server Requirements (RFC6455)</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ab1b8f649ccc95a39d9a4a90ba510bb25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1b8f649ccc95a39d9a4a90ba510bb25">&#9670;&nbsp;</a></span>async_close()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
<div class="memtemplate">
template&lt;BOOST_BEAST_ASYNC_TPARAM1 CloseHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::async_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structboost_1_1beast_1_1websocket_1_1close__reason.html">close_reason</a> const &amp;&#160;</td>
          <td class="paramname"><em>cr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CloseHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em> = <code>net::default_completion_token_t&lt;&#160;<a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a94d4fcaa810123a537bec2db4f34f571">executor_type</a>&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a websocket close control frame asynchronously.</p>
<p>This function is used to asynchronously send a <a href="https://tools.ietf.org/html/rfc6455#section-5.5.1">close frame</a>, which begins the websocket closing handshake. The session ends when both ends of the connection have sent and received a close frame.</p>
<p>This call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The close frame finishes sending.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed asynchronous operation</em>, is implemented in terms of calls to the next layer's <code>async_write_some</code> function. No other operations except for message reading operations should be initiated on the stream after a close operation is started.</p>
<p>After beginning the closing handshake, the program should not write further message data, pings, or pongs. Instead, the program should continue reading message data until an error occurs. A read returning error::closed indicates a successful connection closure.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cr</td><td>The reason for the close. If the close reason specifies a close code other than beast::websocket::close_code::none, the close frame is sent with the close code and optional reason string. Otherwise, the close frame is sent with no payload.</td></tr>
    <tr><td class="paramname">handler</td><td>The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(</div>
<div class="line">    error_code <span class="keyword">const</span>&amp; ec     <span class="comment">// Result of operation</span></div>
<div class="line">);</div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>net::post</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>参照</dt><dd><ul>
<li><a href="https://tools.ietf.org/html/rfc6455#section-7.1.2">Websocket Closing Handshake (RFC6455)</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af44ac91181b1ae869dd8a4db7d469a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af44ac91181b1ae869dd8a4db7d469a98">&#9670;&nbsp;</a></span>async_handshake() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
<div class="memtemplate">
template&lt;BOOST_BEAST_ASYNC_TPARAM1 HandshakeHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::async_handshake </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1http_1_1message.html">response_type</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1basic__string__view.html">string_view</a>&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1basic__string__view.html">string_view</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HandshakeHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em> = <code>net::default_completion_token_t&lt;&#160;<a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a94d4fcaa810123a537bec2db4f34f571">executor_type</a>&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform the WebSocket handshake asynchronously in the client role.</p>
<p>This initiating function is used to asynchronously begin performing the <a href="https://en.wikipedia.org/wiki/WebSocket#Protocol_handshake">WebSocket handshake</a>, required before messages can be sent and received. During the handshake, the client sends the Websocket Upgrade HTTP request, and the server replies with an HTTP response indicating the result of the handshake.</p>
<p>This call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The request is sent and the response is received.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed asynchronous operation</em>, is implemented in terms of calls to the next layer's <code>async_read_some</code> and <code>async_write_some</code> functions. No other operation may be performed on the stream until this operation completes.</p>
<p>The handshake is successful if the received HTTP response indicates the upgrade was accepted by the server, represented by a <a href="https://tools.ietf.org/html/rfc7230#section-3.1.2">status-code</a> of beast::http::status::switching_protocols.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>The HTTP Upgrade response returned by the remote endpoint. The caller may use the response to access any additional information sent by the server. This object will be assigned before the completion handler is invoked.</td></tr>
    <tr><td class="paramname">host</td><td>The name of the remote host. This is required by the HTTP protocol to set the "Host" header field. The implementation will not access the string data after the initiating function returns.</td></tr>
    <tr><td class="paramname">target</td><td>The request-target, in origin-form. The server may use the target to distinguish different services on the same listening port. The implementation will not access the string data after the initiating function returns.</td></tr>
    <tr><td class="paramname">handler</td><td>The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(</div>
<div class="line">    error_code <span class="keyword">const</span>&amp; ec    <span class="comment">// Result of operation</span></div>
<div class="line">);</div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>net::post</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">response_type res;</div>
<div class="line">ws.async_handshake(res, <span class="stringliteral">&quot;localhost&quot;</span>, <span class="stringliteral">&quot;/&quot;</span>,</div>
<div class="line">    [&amp;res](error_code ec)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span>(ec)</div>
<div class="line">            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ec.message() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">            std::cout &lt;&lt; res;</div>
<div class="line"> </div>
<div class="line">    });</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>参照</dt><dd><ul>
<li><a href="https://tools.ietf.org/html/rfc6455#section-4.1">Websocket Opening Handshake Client Requirements (RFC6455)</a> </li>
<li><a href="https://tools.ietf.org/html/rfc7230#section-5.4">Host field (RFC7230)</a> </li>
<li><a href="https://tools.ietf.org/html/rfc7230#section-3.1.1">request-target (RFC7230)</a> </li>
<li><a href="https://tools.ietf.org/html/rfc7230#section-5.3.1">origin-form (RFC7230)</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a388b4d3398f25aa4551b4633253b3c9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a388b4d3398f25aa4551b4633253b3c9a">&#9670;&nbsp;</a></span>async_handshake() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
<div class="memtemplate">
template&lt;BOOST_BEAST_ASYNC_TPARAM1 HandshakeHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::async_handshake </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1basic__string__view.html">string_view</a>&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1basic__string__view.html">string_view</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HandshakeHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em> = <code>net::default_completion_token_t&lt;&#160;<a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a94d4fcaa810123a537bec2db4f34f571">executor_type</a>&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform the WebSocket handshake asynchronously in the client role.</p>
<p>This initiating function is used to asynchronously begin performing the <a href="https://en.wikipedia.org/wiki/WebSocket#Protocol_handshake">WebSocket handshake</a>, required before messages can be sent and received. During the handshake, the client sends the Websocket Upgrade HTTP request, and the server replies with an HTTP response indicating the result of the handshake.</p>
<p>This call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The request is sent and the response is received.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed asynchronous operation</em>, is implemented in terms of calls to the next layer's <code>async_read_some</code> and <code>async_write_some</code> functions. No other operation may be performed on the stream until this operation completes.</p>
<p>The handshake is successful if the received HTTP response indicates the upgrade was accepted by the server, represented by a <a href="https://tools.ietf.org/html/rfc7230#section-3.1.2">status-code</a> of beast::http::status::switching_protocols.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>The name of the remote host. This is required by the HTTP protocol to set the "Host" header field. The implementation will not access the string data after the initiating function returns.</td></tr>
    <tr><td class="paramname">target</td><td>The request-target, in origin-form. The server may use the target to distinguish different services on the same listening port. The implementation will not access the string data after the initiating function returns.</td></tr>
    <tr><td class="paramname">handler</td><td>The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(</div>
<div class="line">    error_code <span class="keyword">const</span>&amp; ec    <span class="comment">// Result of operation</span></div>
<div class="line">);</div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>net::post</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">ws.async_handshake(<span class="stringliteral">&quot;localhost&quot;</span>, <span class="stringliteral">&quot;/&quot;</span>,</div>
<div class="line">    [](error_code ec)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span>(ec)</div>
<div class="line">            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ec.message() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    });</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>参照</dt><dd><ul>
<li><a href="https://tools.ietf.org/html/rfc6455#section-4.1">Websocket Opening Handshake Client Requirements (RFC6455)</a> </li>
<li><a href="https://tools.ietf.org/html/rfc7230#section-5.4">Host field (RFC7230)</a> </li>
<li><a href="https://tools.ietf.org/html/rfc7230#section-3.1.1">request-target (RFC7230)</a> </li>
<li><a href="https://tools.ietf.org/html/rfc7230#section-5.3.1">origin-form (RFC7230)</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="abaa6ad0bab1c6dcc9010a1e23825c488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa6ad0bab1c6dcc9010a1e23825c488">&#9670;&nbsp;</a></span>async_ping()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
<div class="memtemplate">
template&lt;BOOST_BEAST_ASYNC_TPARAM1 WriteHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::async_ping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1static__string.html">ping_data</a> const &amp;&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em> = <code>net::default_completion_token_t&lt;&#160;<a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a94d4fcaa810123a537bec2db4f34f571">executor_type</a>&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a websocket ping control frame asynchronously.</p>
<p>This function is used to asynchronously send a <a href="https://tools.ietf.org/html/rfc6455#section-5.5.2">ping frame</a>, which usually elicits an automatic pong control frame response from the peer.</p>
<ul>
<li>The ping frame is written.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed asynchronous operation</em>, is implemented in terms of calls to the next layer's <code>async_write_some</code> function. The program must ensure that no other calls to <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a4b1be27bcd0a633101b905cfa73e5572">ping</a>, <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aab3755888fda2a3bec91a34ccfd47e83">pong</a>, <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#abaa6ad0bab1c6dcc9010a1e23825c488">async_ping</a>, or <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ac6bcb559711c00eaebcc48c747cc88ca">async_pong</a> are performed until this operation completes.</p>
<p>If a close frame is sent or received before the ping frame is sent, the error received by this completion handler will be <code>net::error::operation_aborted</code>.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">payload</td><td>The payload of the ping message, which may be empty. The implementation will not access the contents of this object after the initiating function returns.</td></tr>
    <tr><td class="paramname">handler</td><td>The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(</div>
<div class="line">    error_code <span class="keyword">const</span>&amp; ec     <span class="comment">// Result of operation</span></div>
<div class="line">);</div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>net::post</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6bcb559711c00eaebcc48c747cc88ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6bcb559711c00eaebcc48c747cc88ca">&#9670;&nbsp;</a></span>async_pong()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
<div class="memtemplate">
template&lt;BOOST_BEAST_ASYNC_TPARAM1 WriteHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::async_pong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1static__string.html">ping_data</a> const &amp;&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em> = <code>net::default_completion_token_t&lt;&#160;<a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a94d4fcaa810123a537bec2db4f34f571">executor_type</a>&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a websocket pong control frame asynchronously.</p>
<p>This function is used to asynchronously send a <a href="https://tools.ietf.org/html/rfc6455#section-5.5.3">pong frame</a>, which is usually sent automatically in response to a ping frame from the remote peer.</p>
<ul>
<li>The pong frame is written.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed asynchronous operation</em>, is implemented in terms of calls to the next layer's <code>async_write_some</code> function. The program must ensure that no other calls to <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a4b1be27bcd0a633101b905cfa73e5572">ping</a>, <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aab3755888fda2a3bec91a34ccfd47e83">pong</a>, <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#abaa6ad0bab1c6dcc9010a1e23825c488">async_ping</a>, or <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ac6bcb559711c00eaebcc48c747cc88ca">async_pong</a> are performed until this operation completes.</p>
<p>If a close frame is sent or received before the pong frame is sent, the error received by this completion handler will be <code>net::error::operation_aborted</code>.</p>
<p>WebSocket allows pong frames to be sent at any time, without first receiving a ping. An unsolicited pong sent in this fashion may indicate to the remote peer that the connection is still active.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">payload</td><td>The payload of the pong message, which may be empty. The implementation will not access the contents of this object after the initiating function returns.</td></tr>
    <tr><td class="paramname">handler</td><td>The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(</div>
<div class="line">    error_code <span class="keyword">const</span>&amp; ec     <span class="comment">// Result of operation</span></div>
<div class="line">);</div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>net::post</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa893761678723b6027335241fea5066a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa893761678723b6027335241fea5066a">&#9670;&nbsp;</a></span>async_read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
<div class="memtemplate">
template&lt;class DynamicBuffer , BOOST_BEAST_ASYNC_TPARAM2 ReadHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::async_read </td>
          <td>(</td>
          <td class="paramtype">DynamicBuffer &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em> = <code>net::default_completion_token_t&lt;&#160;<a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a94d4fcaa810123a537bec2db4f34f571">executor_type</a>&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a complete message asynchronously.</p>
<p>This function is used to asynchronously read a complete message.</p>
<p>This call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>A complete message is received.</li>
</ul>
<ul>
<li>A close frame is received. In this case the error indicated by the function will be error::closed.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed asynchronous operation</em>, is implemented in terms of calls to the next layer's <code>async_read_some</code> and <code>async_write_some</code> functions. The program must ensure that no other calls to <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a75d980208560268fc6e2c6df616fd8ad">read</a>, <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a07e720f4315b9633346b6c71bcb20a24">read_some</a>, <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aa893761678723b6027335241fea5066a">async_read</a>, or <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a95353ee5a3212cd4934bd09396c99ff4">async_read_some</a> are performed until this operation completes.</p>
<p>Received message data is appended to the buffer. The functions <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#af2403f32e02459ff0ce44e1e2f17c46e">got_binary</a> and <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a666609a7cc058832e89bdbf60758674e">got_text</a> may be used to query the stream and determine the type of the last received message.</p>
<p>Until the operation completes, the implementation will read incoming control frames and handle them automatically as follows:</p>
<ul>
<li>The <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a6bfb1d3554e748cb0feb364626c15e73">control_callback</a> will be invoked for each control frame.</li>
</ul>
<ul>
<li>For each received ping frame, a pong frame will be automatically sent.</li>
</ul>
<ul>
<li>If a close frame is received, the WebSocket close procedure is performed. In this case, when the function returns, the error error::closed will be indicated.</li>
</ul>
<p>Pong frames and close frames sent by the implementation while the read operation is outstanding do not prevent the application from also writing message data, sending pings, sending pongs, or sending close frames.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A dynamic buffer to append message data to.</td></tr>
    <tr><td class="paramname">handler</td><td>The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(</div>
<div class="line">    error_code <span class="keyword">const</span>&amp; ec,       <span class="comment">// Result of operation</span></div>
<div class="line">    std::size_t bytes_written   <span class="comment">// Number of bytes appended to buffer</span></div>
<div class="line">);</div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>net::post</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95353ee5a3212cd4934bd09396c99ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95353ee5a3212cd4934bd09396c99ff4">&#9670;&nbsp;</a></span>async_read_some() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
<div class="memtemplate">
template&lt;class DynamicBuffer , BOOST_BEAST_ASYNC_TPARAM2 ReadHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::async_read_some </td>
          <td>(</td>
          <td class="paramtype">DynamicBuffer &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em> = <code>net::default_completion_token_t&lt;&#160;<a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a94d4fcaa810123a537bec2db4f34f571">executor_type</a>&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read some message data asynchronously.</p>
<p>This function is used to asynchronously read some message data.</p>
<p>This call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>Some message data is received.</li>
</ul>
<ul>
<li>A close frame is received. In this case the error indicated by the function will be error::closed.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed asynchronous operation</em>, is implemented in terms of calls to the next layer's <code>async_read_some</code> and <code>async_write_some</code> functions. The program must ensure that no other calls to <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a75d980208560268fc6e2c6df616fd8ad">read</a>, <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a07e720f4315b9633346b6c71bcb20a24">read_some</a>, <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aa893761678723b6027335241fea5066a">async_read</a>, or <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a95353ee5a3212cd4934bd09396c99ff4">async_read_some</a> are performed until this operation completes.</p>
<p>Received message data is appended to the buffer. The functions <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#af2403f32e02459ff0ce44e1e2f17c46e">got_binary</a> and <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a666609a7cc058832e89bdbf60758674e">got_text</a> may be used to query the stream and determine the type of the last received message.</p>
<p>Until the operation completes, the implementation will read incoming control frames and handle them automatically as follows:</p>
<ul>
<li>The <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a6bfb1d3554e748cb0feb364626c15e73">control_callback</a> will be invoked for each control frame.</li>
</ul>
<ul>
<li>For each received ping frame, a pong frame will be automatically sent.</li>
</ul>
<ul>
<li>If a close frame is received, the WebSocket close procedure is performed. In this case, when the function returns, the error error::closed will be indicated.</li>
</ul>
<p>Pong frames and close frames sent by the implementation while the read operation is outstanding do not prevent the application from also writing message data, sending pings, sending pongs, or sending close frames.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A dynamic buffer to append message data to.</td></tr>
    <tr><td class="paramname">limit</td><td>An upper limit on the number of bytes this function will append into the buffer. If this value is zero, then a reasonable size will be chosen automatically.</td></tr>
    <tr><td class="paramname">handler</td><td>The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(</div>
<div class="line">    error_code <span class="keyword">const</span>&amp; ec,       <span class="comment">// Result of operation</span></div>
<div class="line">    std::size_t bytes_written   <span class="comment">// Number of bytes appended to buffer</span></div>
<div class="line">);</div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>net::post</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5adf8821e718ebbf6e300ddc7f85f0a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5adf8821e718ebbf6e300ddc7f85f0a6">&#9670;&nbsp;</a></span>async_read_some() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
<div class="memtemplate">
template&lt;class MutableBufferSequence , BOOST_BEAST_ASYNC_TPARAM2 ReadHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::async_read_some </td>
          <td>(</td>
          <td class="paramtype">MutableBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em> = <code>net::default_completion_token_t&lt;&#160;<a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a94d4fcaa810123a537bec2db4f34f571">executor_type</a>&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read some message data asynchronously.</p>
<p>This function is used to asynchronously read some message data.</p>
<p>This call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>Some message data is received.</li>
</ul>
<ul>
<li>A close frame is received. In this case the error indicated by the function will be error::closed.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed asynchronous operation</em>, is implemented in terms of calls to the next layer's <code>async_read_some</code> and <code>async_write_some</code> functions. The program must ensure that no other calls to <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a75d980208560268fc6e2c6df616fd8ad">read</a>, <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a07e720f4315b9633346b6c71bcb20a24">read_some</a>, <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aa893761678723b6027335241fea5066a">async_read</a>, or <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a95353ee5a3212cd4934bd09396c99ff4">async_read_some</a> are performed until this operation completes.</p>
<p>Received message data is appended to the buffer. The functions <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#af2403f32e02459ff0ce44e1e2f17c46e">got_binary</a> and <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a666609a7cc058832e89bdbf60758674e">got_text</a> may be used to query the stream and determine the type of the last received message.</p>
<p>Until the operation completes, the implementation will read incoming control frames and handle them automatically as follows:</p>
<ul>
<li>The <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a6bfb1d3554e748cb0feb364626c15e73">control_callback</a> will be invoked for each control frame.</li>
</ul>
<ul>
<li>For each received ping frame, a pong frame will be automatically sent.</li>
</ul>
<ul>
<li>If a close frame is received, the WebSocket close procedure is performed. In this case, when the function returns, the error error::closed will be indicated.</li>
</ul>
<p>Pong frames and close frames sent by the implementation while the read operation is outstanding do not prevent the application from also writing message data, sending pings, sending pongs, or sending close frames.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>A buffer sequence to write message data into. The previous contents of the buffers will be overwritten, starting from the beginning. The implementation will make copies of this object as needed, but but ownership of the underlying memory is not transferred. The caller is responsible for ensuring that the memory locations pointed to by the buffer sequence remain valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(</div>
<div class="line">    error_code <span class="keyword">const</span>&amp; ec,       <span class="comment">// Result of operation</span></div>
<div class="line">    std::size_t bytes_written   <span class="comment">// Number of bytes written to the buffers</span></div>
<div class="line">);</div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>net::post</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a962763e4c65932898baf770569bdb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a962763e4c65932898baf770569bdb1">&#9670;&nbsp;</a></span>async_write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence , BOOST_BEAST_ASYNC_TPARAM2 WriteHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::async_write </td>
          <td>(</td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em> = <code>net::default_completion_token_t&lt;&#160;<a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a94d4fcaa810123a537bec2db4f34f571">executor_type</a>&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a complete message asynchronously.</p>
<p>This function is used to asynchronously write a complete message.</p>
<p>This call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The complete message is written.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed asynchronous operation</em>, is implemented in terms of calls to the next layer's <code>async_write_some</code> function. The program must ensure that no other calls to <a class="el" href="group__write.html">boost::asio::write</a>, <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ab89b2616d52318049135e78ecbb4b2f0">write_some</a>, <a class="el" href="group__async__write.html">boost::asio::async_write</a>, or <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#af2ab9d05f08f7e7d83cc145db48865a4">async_write_some</a> are performed until this operation completes.</p>
<p>The current setting of the <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#acc58448ca669614fd60c6c1d22ba7a41">binary</a> option controls whether the message opcode is set to text or binary. If the <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ad916dc41cffddf485355ef749ebdb6c1">auto_fragment</a> option is set, the message will be split into one or more frames as necessary. The actual payload contents sent may be transformed as per the WebSocket protocol settings.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>A buffer sequence containing the entire message payload. The implementation will make copies of this object as needed, but ownership of the underlying memory is not transferred. The caller is responsible for ensuring that the memory locations pointed to by buffers remains valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(</div>
<div class="line">    error_code <span class="keyword">const</span>&amp; ec,           <span class="comment">// Result of operation</span></div>
<div class="line">    std::size_t bytes_transferred   <span class="comment">// Number of bytes sent from the</span></div>
<div class="line">                                    <span class="comment">// buffers. If an error occurred,</span></div>
<div class="line">                                    <span class="comment">// this will be less than the buffer_size.</span></div>
<div class="line">);</div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>net::post</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2ab9d05f08f7e7d83cc145db48865a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2ab9d05f08f7e7d83cc145db48865a4">&#9670;&nbsp;</a></span>async_write_some()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence , BOOST_BEAST_ASYNC_TPARAM2 WriteHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::async_write_some </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em> = <code>net::default_completion_token_t&lt;&#160;<a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a94d4fcaa810123a537bec2db4f34f571">executor_type</a>&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write some message data asynchronously.</p>
<p>This function is used to asynchronously write part of a message.</p>
<p>This call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The message data is written.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed asynchronous operation</em>, is implemented in terms of calls to the next layer's <code>async_write_some</code> function. The program must ensure that no other calls to <a class="el" href="group__write.html">boost::asio::write</a>, <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ab89b2616d52318049135e78ecbb4b2f0">write_some</a>, <a class="el" href="group__async__write.html">boost::asio::async_write</a>, or <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#af2ab9d05f08f7e7d83cc145db48865a4">async_write_some</a> are performed until this operation completes.</p>
<p>If this is the beginning of a new message, the message opcode will be set to text or binary based on the current setting of the <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#acc58448ca669614fd60c6c1d22ba7a41">binary</a> (or <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a90e77bd4c9cf9d84f936439a14d88d6a">text</a>) option. The actual payload sent may be transformed as per the WebSocket protocol settings.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">fin</td><td><code>true</code> if this is the last part of the message.</td></tr>
    <tr><td class="paramname">buffers</td><td>The buffers containing the message part to send. The implementation will make copies of this object as needed, but ownership of the underlying memory is not transferred. The caller is responsible for ensuring that the memory locations pointed to by buffers remains valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(</div>
<div class="line">    error_code <span class="keyword">const</span>&amp; ec,           <span class="comment">// Result of operation</span></div>
<div class="line">    std::size_t bytes_transferred   <span class="comment">// Number of bytes sent from the</span></div>
<div class="line">                                    <span class="comment">// buffers. If an error occurred,</span></div>
<div class="line">                                    <span class="comment">// this will be less than the buffer_size.</span></div>
<div class="line">);</div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>net::post</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad916dc41cffddf485355ef749ebdb6c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad916dc41cffddf485355ef749ebdb6c1">&#9670;&nbsp;</a></span>auto_fragment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::auto_fragment </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the automatic fragmentation option.</p>
<p>Determines if outgoing message payloads are broken up into multiple pieces.</p>
<p>When the automatic fragmentation size is turned on, outgoing message payloads are broken up into multiple frames no larger than the write buffer size.</p>
<p>The default setting is to fragment messages.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A <code>bool</code> indicating if auto fragmentation should be on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>Setting the automatic fragmentation option: <div class="fragment"><div class="line">ws.auto_fragment(<span class="keyword">true</span>);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="acc58448ca669614fd60c6c1d22ba7a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc58448ca669614fd60c6c1d22ba7a41">&#9670;&nbsp;</a></span>binary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::binary </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the binary message write option.</p>
<p>This controls whether or not outgoing message opcodes are set to binary or text. The setting is only applied at the start when a caller begins a new message. Changing the opcode after a message is started will only take effect after the current message being sent is complete.</p>
<p>The default setting is to send text messages.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td><code>true</code> if outgoing messages should indicate binary, or <code>false</code> if they should indicate text.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>Setting the message type to binary. <div class="fragment"><div class="line">ws.binary(<span class="keyword">true</span>);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a5e5fe1bfe3738755b3d803e14a34c441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e5fe1bfe3738755b3d803e14a34c441">&#9670;&nbsp;</a></span>close() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structboost_1_1beast_1_1websocket_1_1close__reason.html">close_reason</a> const &amp;&#160;</td>
          <td class="paramname"><em>cr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a websocket close control frame.</p>
<p>This function is used to send a <a href="https://tools.ietf.org/html/rfc6455#section-5.5.1">close frame</a>, which begins the websocket closing handshake. The session ends when both ends of the connection have sent and received a close frame.</p>
<p>The call blocks until one of the following conditions is true:</p>
<ul>
<li>The close frame is written.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed operation</em>, is implemented in terms of calls to the next layer's <code>write_some</code> function.</p>
<p>After beginning the closing handshake, the program should not write further message data, pings, or pongs. Instead, the program should continue reading message data until an error occurs. A read returning error::closed indicates a successful connection closure.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cr</td><td>The reason for the close. If the close reason specifies a close code other than beast::websocket::close_code::none, the close frame is sent with the close code and optional reason string. Otherwise, the close frame is sent with no payload.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>参照</dt><dd><ul>
<li><a href="https://tools.ietf.org/html/rfc6455#section-7.1.2">Websocket Closing Handshake (RFC6455)</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a1eaec0b88bb7740b1d15e24d0d380914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eaec0b88bb7740b1d15e24d0d380914">&#9670;&nbsp;</a></span>close() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structboost_1_1beast_1_1websocket_1_1close__reason.html">close_reason</a> const &amp;&#160;</td>
          <td class="paramname"><em>cr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a websocket close control frame.</p>
<p>This function is used to send a <a href="https://tools.ietf.org/html/rfc6455#section-5.5.1">close frame</a>, which begins the websocket closing handshake. The session ends when both ends of the connection have sent and received a close frame.</p>
<p>The call blocks until one of the following conditions is true:</p>
<ul>
<li>The close frame is written.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed operation</em>, is implemented in terms of calls to the next layer's <code>write_some</code> function.</p>
<p>After beginning the closing handshake, the program should not write further message data, pings, or pongs. Instead, the program should continue reading message data until an error occurs. A read returning error::closed indicates a successful connection closure.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cr</td><td>The reason for the close. If the close reason specifies a close code other than beast::websocket::close_code::none, the close frame is sent with the close code and optional reason string. Otherwise, the close frame is sent with no payload.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>参照</dt><dd><ul>
<li><a href="https://tools.ietf.org/html/rfc6455#section-7.1.2">Websocket Closing Handshake (RFC6455)</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ab965b22b5b347ce06ee7b43b153008a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab965b22b5b347ce06ee7b43b153008a2">&#9670;&nbsp;</a></span>control_callback() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::control_callback</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset the control frame callback.</p>
<p>This function removes any previously set control frame callback. </p>

</div>
</div>
<a id="a6bfb1d3554e748cb0feb364626c15e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bfb1d3554e748cb0feb364626c15e73">&#9670;&nbsp;</a></span>control_callback() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::control_callback </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(frame_type, <a class="el" href="classboost_1_1basic__string__view.html">string_view</a>)&gt;&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a callback to be invoked on each incoming control frame.</p>
<p>Sets the callback to be invoked whenever a ping, pong, or close control frame is received during a call to one of the following functions:</p>
<ul>
<li><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a75d980208560268fc6e2c6df616fd8ad">beast::websocket::stream::read</a> </li>
<li><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a07e720f4315b9633346b6c71bcb20a24">beast::websocket::stream::read_some</a> </li>
<li><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aa893761678723b6027335241fea5066a">beast::websocket::stream::async_read</a> </li>
<li><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a95353ee5a3212cd4934bd09396c99ff4">beast::websocket::stream::async_read_some</a></li>
</ul>
<p>Unlike completion handlers, the callback will be invoked for each control frame during a call to any synchronous or asynchronous read function. The operation is passive, with no associated error code, and triggered by reads.</p>
<p>For close frames, the close reason code may be obtained by calling the function <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a4d416ef4de71bb5693ab3262c799b7ff">reason</a>.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>The function object to call, which must be invocable with this equivalent signature: <div class="fragment"><div class="line"><span class="keywordtype">void</span></div>
<div class="line">callback(</div>
<div class="line">    frame_type kind,       <span class="comment">// The type of frame</span></div>
<div class="line">    string_view payload    <span class="comment">// The payload in the frame</span></div>
<div class="line">);</div>
</div><!-- fragment --> The implementation type-erases the callback which may require a dynamic allocation. To prevent the possibility of a dynamic allocation, use <code>std::ref</code> to wrap the callback. If the read operation which receives the control frame is an asynchronous operation, the callback will be invoked using the same method as that used to invoke the final handler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>Incoming ping and close frames are automatically handled. Pings are responded to with pongs, and a close frame is responded to with a close frame leading to the closure of the stream. It is not necessary to manually send pings, pongs, or close frames from inside the control callback. Attempting to manually send a close frame from inside the control callback after receiving a close frame will result in undefined behavior. </dd></dl>

</div>
</div>
<a id="a4b23fc090a9f22fd28fb8d0d6827e109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b23fc090a9f22fd28fb8d0d6827e109">&#9670;&nbsp;</a></span>get_executor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::get_executor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the executor associated with the object.</p>
<p>This function may be used to obtain the executor object that the stream uses to dispatch handlers for asynchronous operations.</p>
<dl class="section return"><dt>戻り値</dt><dd>A copy of the executor that stream will use to dispatch handlers. </dd></dl>

</div>
</div>
<a id="af2403f32e02459ff0ce44e1e2f17c46e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2403f32e02459ff0ce44e1e2f17c46e">&#9670;&nbsp;</a></span>got_binary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::got_binary</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the latest message data indicates binary.</p>
<p>This function informs the caller of whether the last received message frame represents a message with the binary opcode.</p>
<p>If there is no last message frame, the return value is undefined. </p>

</div>
</div>
<a id="a666609a7cc058832e89bdbf60758674e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a666609a7cc058832e89bdbf60758674e">&#9670;&nbsp;</a></span>got_text()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::got_text </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the latest message data indicates text.</p>
<p>This function informs the caller of whether the last received message frame represents a message with the text opcode.</p>
<p>If there is no last message frame, the return value is undefined. </p>

</div>
</div>
<a id="a588d36ce6893e73e4e443c12902a89f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a588d36ce6893e73e4e443c12902a89f8">&#9670;&nbsp;</a></span>handshake() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::handshake </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1http_1_1message.html">response_type</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1basic__string__view.html">string_view</a>&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1basic__string__view.html">string_view</a>&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform the WebSocket handshake in the client role.</p>
<p>This function is used to perform the <a href="https://en.wikipedia.org/wiki/WebSocket#Protocol_handshake">WebSocket handshake</a>, required before messages can be sent and received. During the handshake, the client sends the Websocket Upgrade HTTP request, and the server replies with an HTTP response indicating the result of the handshake.</p>
<p>The call blocks until one of the following conditions is true:</p>
<ul>
<li>The request is sent and the response is received.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed operation</em>, is implemented in terms of calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>The handshake is successful if the received HTTP response indicates the upgrade was accepted by the server, represented by a <a href="https://tools.ietf.org/html/rfc7230#section-3.1.2">status-code</a> of beast::http::status::switching_protocols.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>The HTTP Upgrade response returned by the remote endpoint. The caller may use the response to access any additional information sent by the server.</td></tr>
    <tr><td class="paramname">host</td><td>The name of the remote host. This is required by the HTTP protocol to set the "Host" header field.</td></tr>
    <tr><td class="paramname">target</td><td>The request-target, in origin-form. The server may use the target to distinguish different services on the same listening port.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">response_type res;</div>
<div class="line">ws.handshake(res, <span class="stringliteral">&quot;localhost&quot;</span>, <span class="stringliteral">&quot;/&quot;</span>);</div>
<div class="line">std::cout &lt;&lt; res;</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>参照</dt><dd><ul>
<li><a href="https://tools.ietf.org/html/rfc6455#section-4.1">Websocket Opening Handshake Client Requirements (RFC6455)</a> </li>
<li><a href="https://tools.ietf.org/html/rfc7230#section-5.4">Host field (RFC7230)</a> </li>
<li><a href="https://tools.ietf.org/html/rfc7230#section-3.1.1">request-target (RFC7230)</a> </li>
<li><a href="https://tools.ietf.org/html/rfc7230#section-5.3.1">origin-form (RFC7230)</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a1a4c54655ff83efc1404721ccd1025b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a4c54655ff83efc1404721ccd1025b5">&#9670;&nbsp;</a></span>handshake() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::handshake </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1http_1_1message.html">response_type</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1basic__string__view.html">string_view</a>&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1basic__string__view.html">string_view</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform the WebSocket handshake in the client role.</p>
<p>This function is used to perform the <a href="https://en.wikipedia.org/wiki/WebSocket#Protocol_handshake">WebSocket handshake</a>, required before messages can be sent and received. During the handshake, the client sends the Websocket Upgrade HTTP request, and the server replies with an HTTP response indicating the result of the handshake.</p>
<p>The call blocks until one of the following conditions is true:</p>
<ul>
<li>The request is sent and the response is received.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed operation</em>, is implemented in terms of calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>The handshake is successful if the received HTTP response indicates the upgrade was accepted by the server, represented by a <a href="https://tools.ietf.org/html/rfc7230#section-3.1.2">status-code</a> of beast::http::status::switching_protocols.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>The HTTP Upgrade response returned by the remote endpoint. The caller may use the response to access any additional information sent by the server.</td></tr>
    <tr><td class="paramname">host</td><td>The name of the remote host. This is required by the HTTP protocol to set the "Host" header field.</td></tr>
    <tr><td class="paramname">target</td><td>The request-target, in origin-form. The server may use the target to distinguish different services on the same listening port.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">error_code ec;</div>
<div class="line">response_type res;</div>
<div class="line">ws.handshake(res, <span class="stringliteral">&quot;localhost&quot;</span>, <span class="stringliteral">&quot;/&quot;</span>, ec);</div>
<div class="line"><span class="keywordflow">if</span>(! ec)</div>
<div class="line">    std::cout &lt;&lt; res;</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>参照</dt><dd><ul>
<li><a href="https://tools.ietf.org/html/rfc6455#section-4.1">Websocket Opening Handshake Client Requirements (RFC6455)</a> </li>
<li><a href="https://tools.ietf.org/html/rfc7230#section-5.4">Host field (RFC7230)</a> </li>
<li><a href="https://tools.ietf.org/html/rfc7230#section-3.1.1">request-target (RFC7230)</a> </li>
<li><a href="https://tools.ietf.org/html/rfc7230#section-5.3.1">origin-form (RFC7230)</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aa1986d6a1ae4a37100c00cb8ead32f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1986d6a1ae4a37100c00cb8ead32f97">&#9670;&nbsp;</a></span>handshake() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::handshake </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1basic__string__view.html">string_view</a>&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1basic__string__view.html">string_view</a>&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform the WebSocket handshake in the client role.</p>
<p>This function is used to perform the <a href="https://en.wikipedia.org/wiki/WebSocket#Protocol_handshake">WebSocket handshake</a>, required before messages can be sent and received. During the handshake, the client sends the Websocket Upgrade HTTP request, and the server replies with an HTTP response indicating the result of the handshake.</p>
<p>The call blocks until one of the following conditions is true:</p>
<ul>
<li>The request is sent and the response is received.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed operation</em>, is implemented in terms of calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>The handshake is successful if the received HTTP response indicates the upgrade was accepted by the server, represented by a <a href="https://tools.ietf.org/html/rfc7230#section-3.1.2">status-code</a> of beast::http::status::switching_protocols.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>The name of the remote host. This is required by the HTTP protocol to set the "Host" header field.</td></tr>
    <tr><td class="paramname">target</td><td>The request-target, in origin-form. The server may use the target to distinguish different services on the same listening port.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">ws.handshake(<span class="stringliteral">&quot;localhost&quot;</span>, <span class="stringliteral">&quot;/&quot;</span>);</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>参照</dt><dd><ul>
<li><a href="https://tools.ietf.org/html/rfc6455#section-4.1">Websocket Opening Handshake Client Requirements (RFC6455)</a> </li>
<li><a href="https://tools.ietf.org/html/rfc7230#section-5.4">Host field (RFC7230)</a> </li>
<li><a href="https://tools.ietf.org/html/rfc7230#section-3.1.1">request-target (RFC7230)</a> </li>
<li><a href="https://tools.ietf.org/html/rfc7230#section-5.3.1">origin-form (RFC7230)</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a4d521fdcd6d34bfddee162e5d59da606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d521fdcd6d34bfddee162e5d59da606">&#9670;&nbsp;</a></span>handshake() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::handshake </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1basic__string__view.html">string_view</a>&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1basic__string__view.html">string_view</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform the WebSocket handshake in the client role.</p>
<p>This function is used to perform the <a href="https://en.wikipedia.org/wiki/WebSocket#Protocol_handshake">WebSocket handshake</a>, required before messages can be sent and received. During the handshake, the client sends the Websocket Upgrade HTTP request, and the server replies with an HTTP response indicating the result of the handshake.</p>
<p>The call blocks until one of the following conditions is true:</p>
<ul>
<li>The request is sent and the response is received.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed operation</em>, is implemented in terms of calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>The handshake is successful if the received HTTP response indicates the upgrade was accepted by the server, represented by a <a href="https://tools.ietf.org/html/rfc7230#section-3.1.2">status-code</a> of beast::http::status::switching_protocols.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>The name of the remote host. This is required by the HTTP protocol to set the "Host" header field.</td></tr>
    <tr><td class="paramname">target</td><td>The request-target, in origin-form. The server may use the target to distinguish different services on the same listening port.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">error_code ec;</div>
<div class="line">ws.handshake(<span class="stringliteral">&quot;localhost&quot;</span>, <span class="stringliteral">&quot;/&quot;</span>, ec);</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>参照</dt><dd><ul>
<li><a href="https://tools.ietf.org/html/rfc6455#section-4.1">Websocket Opening Handshake Client Requirements (RFC6455)</a> </li>
<li><a href="https://tools.ietf.org/html/rfc7230#section-5.4">Host field (RFC7230)</a> </li>
<li><a href="https://tools.ietf.org/html/rfc7230#section-3.1.1">request-target (RFC7230)</a> </li>
<li><a href="https://tools.ietf.org/html/rfc7230#section-5.3.1">origin-form (RFC7230)</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac1f50dcdd7701086aef084796a5ea57e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f50dcdd7701086aef084796a5ea57e">&#9670;&nbsp;</a></span>is_open()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::is_open</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the stream is open.</p>
<p>The stream is open after a successful handshake, and when no error has occurred. </p>

</div>
</div>
<a id="a2f41c025fa7eefbb1c2fbe3e315bf102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f41c025fa7eefbb1c2fbe3e315bf102">&#9670;&nbsp;</a></span>next_layer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a1f4e593b1b583bfd6089f71e28df94a8">next_layer_type</a> const&amp; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::next_layer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a reference to the next layer</p>
<p>This function returns a reference to the next layer in a stack of stream layers.</p>
<dl class="section return"><dt>戻り値</dt><dd>A reference to the next layer in the stack of stream layers. </dd></dl>

</div>
</div>
<a id="ae4823a02a93e831ad06e15056adb8209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4823a02a93e831ad06e15056adb8209">&#9670;&nbsp;</a></span>next_layer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::next_layer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a reference to the next layer</p>
<p>This function returns a reference to the next layer in a stack of stream layers.</p>
<dl class="section return"><dt>戻り値</dt><dd>A reference to the next layer in the stack of stream layers. </dd></dl>

</div>
</div>
<a id="a4b1be27bcd0a633101b905cfa73e5572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b1be27bcd0a633101b905cfa73e5572">&#9670;&nbsp;</a></span>ping() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::ping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1static__string.html">ping_data</a> const &amp;&#160;</td>
          <td class="paramname"><em>payload</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a websocket ping control frame.</p>
<p>This function is used to send a <a href="https://tools.ietf.org/html/rfc6455#section-5.5.2">ping frame</a>, which usually elicits an automatic pong control frame response from the peer.</p>
<p>The call blocks until one of the following conditions is true:</p>
<ul>
<li>The ping frame is written.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed operation</em>, is implemented in terms of calls to the next layer's <code>write_some</code> function.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">payload</td><td>The payload of the ping message, which may be empty.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17c62d6f360f3c0a5ee94b7547cace8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c62d6f360f3c0a5ee94b7547cace8f">&#9670;&nbsp;</a></span>ping() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::ping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1static__string.html">ping_data</a> const &amp;&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a websocket ping control frame.</p>
<p>This function is used to send a <a href="https://tools.ietf.org/html/rfc6455#section-5.5.2">ping frame</a>, which usually elicits an automatic pong control frame response from the peer.</p>
<p>The call blocks until one of the following conditions is true:</p>
<ul>
<li>The ping frame is written.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed operation</em>, is implemented in terms of calls to the next layer's <code>write_some</code> function.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">payload</td><td>The payload of the ping message, which may be empty.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab3755888fda2a3bec91a34ccfd47e83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab3755888fda2a3bec91a34ccfd47e83">&#9670;&nbsp;</a></span>pong() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::pong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1static__string.html">ping_data</a> const &amp;&#160;</td>
          <td class="paramname"><em>payload</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a websocket pong control frame.</p>
<p>This function is used to send a <a href="https://tools.ietf.org/html/rfc6455#section-5.5.3">pong frame</a>, which is usually sent automatically in response to a ping frame from the remote peer.</p>
<p>The call blocks until one of the following conditions is true:</p>
<ul>
<li>The pong frame is written.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed operation</em>, is implemented in terms of calls to the next layer's <code>write_some</code> function.</p>
<p>WebSocket allows pong frames to be sent at any time, without first receiving a ping. An unsolicited pong sent in this fashion may indicate to the remote peer that the connection is still active.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">payload</td><td>The payload of the pong message, which may be empty.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4807fb7780222de88ede8103a97ffdcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4807fb7780222de88ede8103a97ffdcc">&#9670;&nbsp;</a></span>pong() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::pong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1static__string.html">ping_data</a> const &amp;&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a websocket pong control frame.</p>
<p>This function is used to send a <a href="https://tools.ietf.org/html/rfc6455#section-5.5.3">pong frame</a>, which is usually sent automatically in response to a ping frame from the remote peer.</p>
<p>The call blocks until one of the following conditions is true:</p>
<ul>
<li>The pong frame is written.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed operation</em>, is implemented in terms of calls to the next layer's <code>write_some</code> function.</p>
<p>WebSocket allows pong frames to be sent at any time, without first receiving a ping. An unsolicited pong sent in this fashion may indicate to the remote peer that the connection is still active.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">payload</td><td>The payload of the pong message, which may be empty.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75d980208560268fc6e2c6df616fd8ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d980208560268fc6e2c6df616fd8ad">&#9670;&nbsp;</a></span>read() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
<div class="memtemplate">
template&lt;class DynamicBuffer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::read </td>
          <td>(</td>
          <td class="paramtype">DynamicBuffer &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a complete message.</p>
<p>This function is used to read a complete message.</p>
<p>The call blocks until one of the following is true:</p>
<ul>
<li>A complete message is received.</li>
</ul>
<ul>
<li>A close frame is received. In this case the error indicated by the function will be error::closed.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed operation</em>, is implemented in terms of calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>Received message data is appended to the buffer. The functions <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#af2403f32e02459ff0ce44e1e2f17c46e">got_binary</a> and <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a666609a7cc058832e89bdbf60758674e">got_text</a> may be used to query the stream and determine the type of the last received message.</p>
<p>Until the call returns, the implementation will read incoming control frames and handle them automatically as follows:</p>
<ul>
<li>The <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a6bfb1d3554e748cb0feb364626c15e73">control_callback</a> will be invoked for each control frame.</li>
</ul>
<ul>
<li>For each received ping frame, a pong frame will be automatically sent.</li>
</ul>
<ul>
<li>If a close frame is received, the WebSocket closing handshake is performed. In this case, when the function returns, the error error::closed will be indicated.</li>
</ul>
<dl class="section return"><dt>戻り値</dt><dd>The number of message payload bytes appended to the buffer.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A dynamic buffer to append message data to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5b9b73cf420c88e430129aad4edfda6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5b9b73cf420c88e430129aad4edfda6">&#9670;&nbsp;</a></span>read() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
<div class="memtemplate">
template&lt;class DynamicBuffer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::read </td>
          <td>(</td>
          <td class="paramtype">DynamicBuffer &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a complete message.</p>
<p>This function is used to read a complete message.</p>
<p>The call blocks until one of the following is true:</p>
<ul>
<li>A complete message is received.</li>
</ul>
<ul>
<li>A close frame is received. In this case the error indicated by the function will be error::closed.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed operation</em>, is implemented in terms of calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>Received message data is appended to the buffer. The functions <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#af2403f32e02459ff0ce44e1e2f17c46e">got_binary</a> and <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a666609a7cc058832e89bdbf60758674e">got_text</a> may be used to query the stream and determine the type of the last received message.</p>
<p>Until the call returns, the implementation will read incoming control frames and handle them automatically as follows:</p>
<ul>
<li>The <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a6bfb1d3554e748cb0feb364626c15e73">control_callback</a> will be invoked for each control frame.</li>
</ul>
<ul>
<li>For each received ping frame, a pong frame will be automatically sent.</li>
</ul>
<ul>
<li>If a close frame is received, the WebSocket closing handshake is performed. In this case, when the function returns, the error error::closed will be indicated.</li>
</ul>
<dl class="section return"><dt>戻り値</dt><dd>The number of message payload bytes appended to the buffer.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A dynamic buffer to append message data to.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75ee32a8c28369a70ada79ec0ddfb384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75ee32a8c28369a70ada79ec0ddfb384">&#9670;&nbsp;</a></span>read_message_max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::read_message_max </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>amount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the maximum incoming message size option.</p>
<p>Sets the largest permissible incoming message size. Message frame fields indicating a size that would bring the total message size over this limit will cause a protocol failure.</p>
<p>The default setting is 16 megabytes. A value of zero indicates a limit of the maximum value of a <code>std::uint64_t</code>.</p>
<dl class="section user"><dt>Example</dt><dd>Setting the maximum read message size. <div class="fragment"><div class="line">ws.read_message_max(65536);</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">amount</td><td>The limit on the size of incoming messages. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d77597e4be21a42cc89df7f69407119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d77597e4be21a42cc89df7f69407119">&#9670;&nbsp;</a></span>read_size_hint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
<div class="memtemplate">
template&lt;class DynamicBuffer , class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::read_size_hint </td>
          <td>(</td>
          <td class="paramtype">DynamicBuffer &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a suggested maximum buffer size for the next call to read.</p>
<p>This function returns a reasonable upper limit on the number of bytes for the size of the buffer passed in the next call to read. The number is determined by the state of the current frame and whether or not the permessage-deflate extension is enabled.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer which will be used for reading. The implementation will query the buffer to obtain the optimum size of a subsequent call to <code>buffer.prepare</code> based on the state of the current frame, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6708109e68191a15ed63c3fdcd32aede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6708109e68191a15ed63c3fdcd32aede">&#9670;&nbsp;</a></span>read_size_hint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::read_size_hint </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>initial_size</em> = <code>+tcp_frame_size</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a suggested maximum buffer size for the next call to read.</p>
<p>This function returns a reasonable upper limit on the number of bytes for the size of the buffer passed in the next call to read. The number is determined by the state of the current frame and whether or not the permessage-deflate extension is enabled.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">initial_size</td><td>A non-zero size representing the caller's desired buffer size for when there is no information which may be used to calculate a more specific value. For example, when reading the first frame header of a message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07e720f4315b9633346b6c71bcb20a24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e720f4315b9633346b6c71bcb20a24">&#9670;&nbsp;</a></span>read_some() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
<div class="memtemplate">
template&lt;class DynamicBuffer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::read_some </td>
          <td>(</td>
          <td class="paramtype">DynamicBuffer &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read some message data.</p>
<p>This function is used to read some message data.</p>
<p>The call blocks until one of the following is true:</p>
<ul>
<li>Some message data is received.</li>
</ul>
<ul>
<li>A close frame is received. In this case the error indicated by the function will be error::closed.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed operation</em>, is implemented in terms of calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>Received message data is appended to the buffer. The functions <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#af2403f32e02459ff0ce44e1e2f17c46e">got_binary</a> and <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a666609a7cc058832e89bdbf60758674e">got_text</a> may be used to query the stream and determine the type of the last received message. The function <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a91a60357667041e297498915a2313205">is_message_done</a> may be called to determine if the message received by the last read operation is complete.</p>
<p>Until the call returns, the implementation will read incoming control frames and handle them automatically as follows:</p>
<ul>
<li>The <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a6bfb1d3554e748cb0feb364626c15e73">control_callback</a> will be invoked for each control frame.</li>
</ul>
<ul>
<li>For each received ping frame, a pong frame will be automatically sent.</li>
</ul>
<ul>
<li>If a close frame is received, the WebSocket closing handshake is performed. In this case, when the function returns, the error error::closed will be indicated.</li>
</ul>
<dl class="section return"><dt>戻り値</dt><dd>The number of message payload bytes appended to the buffer.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A dynamic buffer to append message data to.</td></tr>
    <tr><td class="paramname">limit</td><td>An upper limit on the number of bytes this function will append into the buffer. If this value is zero, then a reasonable size will be chosen automatically.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54826115579bee3ae31588b70fdb1dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54826115579bee3ae31588b70fdb1dbd">&#9670;&nbsp;</a></span>read_some() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
<div class="memtemplate">
template&lt;class DynamicBuffer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::read_some </td>
          <td>(</td>
          <td class="paramtype">DynamicBuffer &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read some message data.</p>
<p>This function is used to read some message data.</p>
<p>The call blocks until one of the following is true:</p>
<ul>
<li>Some message data is received.</li>
</ul>
<ul>
<li>A close frame is received. In this case the error indicated by the function will be error::closed.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed operation</em>, is implemented in terms of calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>Received message data is appended to the buffer. The functions <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#af2403f32e02459ff0ce44e1e2f17c46e">got_binary</a> and <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a666609a7cc058832e89bdbf60758674e">got_text</a> may be used to query the stream and determine the type of the last received message. The function <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a91a60357667041e297498915a2313205">is_message_done</a> may be called to determine if the message received by the last read operation is complete.</p>
<p>Until the call returns, the implementation will read incoming control frames and handle them automatically as follows:</p>
<ul>
<li>The <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a6bfb1d3554e748cb0feb364626c15e73">control_callback</a> will be invoked for each control frame.</li>
</ul>
<ul>
<li>For each received ping frame, a pong frame will be automatically sent.</li>
</ul>
<ul>
<li>If a close frame is received, the WebSocket closing handshake is performed. In this case, when the function returns, the error error::closed will be indicated.</li>
</ul>
<dl class="section return"><dt>戻り値</dt><dd>The number of message payload bytes appended to the buffer.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A dynamic buffer to append message data to.</td></tr>
    <tr><td class="paramname">limit</td><td>An upper limit on the number of bytes this function will append into the buffer. If this value is zero, then a reasonable size will be chosen automatically.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60eb9a8bab2d7ec1f36e78018a77e4bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60eb9a8bab2d7ec1f36e78018a77e4bc">&#9670;&nbsp;</a></span>read_some() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
<div class="memtemplate">
template&lt;class MutableBufferSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::read_some </td>
          <td>(</td>
          <td class="paramtype">MutableBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read some message data.</p>
<p>This function is used to read some message data.</p>
<p>The call blocks until one of the following is true:</p>
<ul>
<li>Some message data is received.</li>
</ul>
<ul>
<li>A close frame is received. In this case the error indicated by the function will be error::closed.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed operation</em>, is implemented in terms of calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>The functions <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#af2403f32e02459ff0ce44e1e2f17c46e">got_binary</a> and <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a666609a7cc058832e89bdbf60758674e">got_text</a> may be used to query the stream and determine the type of the last received message. The function <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a91a60357667041e297498915a2313205">is_message_done</a> may be called to determine if the message received by the last read operation is complete.</p>
<p>Until the call returns, the implementation will read incoming control frames and handle them automatically as follows:</p>
<ul>
<li>The <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a6bfb1d3554e748cb0feb364626c15e73">control_callback</a> will be invoked for each control frame.</li>
</ul>
<ul>
<li>For each received ping frame, a pong frame will be automatically sent.</li>
</ul>
<ul>
<li>If a close frame is received, the WebSocket closing handshake is performed. In this case, when the function returns, the error error::closed will be indicated.</li>
</ul>
<dl class="section return"><dt>戻り値</dt><dd>The number of message payload bytes appended to the buffer.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>A buffer sequence to write message data into. The previous contents of the buffers will be overwritten, starting from the beginning.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5f1cde38b3c27e851438edadce48103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5f1cde38b3c27e851438edadce48103">&#9670;&nbsp;</a></span>read_some() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
<div class="memtemplate">
template&lt;class MutableBufferSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::read_some </td>
          <td>(</td>
          <td class="paramtype">MutableBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read some message data.</p>
<p>This function is used to read some message data.</p>
<p>The call blocks until one of the following is true:</p>
<ul>
<li>Some message data is received.</li>
</ul>
<ul>
<li>A close frame is received. In this case the error indicated by the function will be error::closed.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed operation</em>, is implemented in terms of calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>The functions <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#af2403f32e02459ff0ce44e1e2f17c46e">got_binary</a> and <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a666609a7cc058832e89bdbf60758674e">got_text</a> may be used to query the stream and determine the type of the last received message. The function <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a91a60357667041e297498915a2313205">is_message_done</a> may be called to determine if the message received by the last read operation is complete.</p>
<p>Until the call returns, the implementation will read incoming control frames and handle them automatically as follows:</p>
<ul>
<li>The <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a6bfb1d3554e748cb0feb364626c15e73">control_callback</a> will be invoked for each control frame.</li>
</ul>
<ul>
<li>For each received ping frame, a pong frame will be automatically sent.</li>
</ul>
<ul>
<li>If a close frame is received, the WebSocket closing handshake is performed. In this case, when the function returns, the error error::closed will be indicated.</li>
</ul>
<dl class="section return"><dt>戻り値</dt><dd>The number of message payload bytes appended to the buffer.</dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>A buffer sequence to write message data into. The previous contents of the buffers will be overwritten, starting from the beginning.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d416ef4de71bb5693ab3262c799b7ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d416ef4de71bb5693ab3262c799b7ff">&#9670;&nbsp;</a></span>reason()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structboost_1_1beast_1_1websocket_1_1close__reason.html">close_reason</a> const  &amp; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::reason</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the close reason received from the remote peer.</p>
<p>This is only valid after a read completes with error::closed. </p>

</div>
</div>
<a id="a2ea44d6b84f054bff2dcf52915070435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ea44d6b84f054bff2dcf52915070435">&#9670;&nbsp;</a></span>secure_prng()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::secure_prng </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set whether the PRNG is cryptographically secure</p>
<p>This controls whether or not the source of pseudo-random numbers used to produce the masks required by the WebSocket protocol are of cryptographic quality. When the setting is <code>true</code>, a strong algorithm is used which cannot be guessed by observing outputs. When the setting is <code>false</code>, a much faster algorithm is used. Masking is only performed by streams operating in the client mode. For streams operating in the server mode, this setting has no effect. By default, newly constructed streams use a secure PRNG.</p>
<p>If the WebSocket stream is used with an encrypted SSL or TLS next layer, if it is known to the application that intermediate proxies are not vulnerable to cache poisoning, or if the application is designed such that an attacker cannot send arbitrary inputs to the stream interface, then the faster algorithm may be used.</p>
<p>For more information please consult the WebSocket protocol RFC.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td><code>true</code> if the PRNG algorithm should be cryptographically secure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abba6e0873d5a4c25bc3bfa6b9b07bea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abba6e0873d5a4c25bc3bfa6b9b07bea1">&#9670;&nbsp;</a></span>set_option()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::set_option </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structboost_1_1beast_1_1websocket_1_1permessage__deflate.html">permessage_deflate</a> const &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the permessage-deflate extension options</p>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">invalid_argument</td><td>if <code>deflateSupported == false</code>, and either <code>client_enable</code> or <code>server_enable</code> is <code>true</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90e77bd4c9cf9d84f936439a14d88d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90e77bd4c9cf9d84f936439a14d88d6a">&#9670;&nbsp;</a></span>text()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::text </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the text message write option.</p>
<p>This controls whether or not outgoing message opcodes are set to binary or text. The setting is only applied at the start when a caller begins a new message. Changing the opcode after a message is started will only take effect after the current message being sent is complete.</p>
<p>The default setting is to send text messages.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td><code>true</code> if outgoing messages should indicate text, or <code>false</code> if they should indicate binary.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>Setting the message type to text. <div class="fragment"><div class="line">ws.text(<span class="keyword">true</span>);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a8566ba212251a0dafbc79a064edd8b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8566ba212251a0dafbc79a064edd8b5c">&#9670;&nbsp;</a></span>write() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::write </td>
          <td>(</td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a complete message.</p>
<p>This function is used to write a complete message.</p>
<p>The call blocks until one of the following is true:</p>
<ul>
<li>The message is written.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed operation</em>, is implemented in terms of calls to the next layer's <code>write_some</code> function.</p>
<p>The current setting of the <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#acc58448ca669614fd60c6c1d22ba7a41">binary</a> option controls whether the message opcode is set to text or binary. If the <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ad916dc41cffddf485355ef749ebdb6c1">auto_fragment</a> option is set, the message will be split into one or more frames as necessary. The actual payload contents sent may be transformed as per the WebSocket protocol settings.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The buffers containing the message to send.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The number of bytes sent from the buffers.</dd></dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc50b5697f57374381d486c5f3ef3efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc50b5697f57374381d486c5f3ef3efd">&#9670;&nbsp;</a></span>write() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::write </td>
          <td>(</td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a complete message.</p>
<p>This function is used to write a complete message.</p>
<p>The call blocks until one of the following is true:</p>
<ul>
<li>The complete message is written.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed operation</em>, is implemented in terms of calls to the next layer's <code>write_some</code> function.</p>
<p>The current setting of the <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#acc58448ca669614fd60c6c1d22ba7a41">binary</a> option controls whether the message opcode is set to text or binary. If the <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ad916dc41cffddf485355ef749ebdb6c1">auto_fragment</a> option is set, the message will be split into one or more frames as necessary. The actual payload contents sent may be transformed as per the WebSocket protocol settings.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The buffers containing the message to send.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The number of bytes sent from the buffers. </dd></dl>

</div>
</div>
<a id="a2e864693b45a726dac0bccacbcb94049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e864693b45a726dac0bccacbcb94049">&#9670;&nbsp;</a></span>write_buffer_bytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::write_buffer_bytes </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>amount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the write buffer size option.</p>
<p>Sets the size of the write buffer used by the implementation to send frames. The write buffer is needed when masking payload data in the client role, compressing frames, or auto-fragmenting message data.</p>
<p>Lowering the size of the buffer can decrease the memory requirements for each connection, while increasing the size of the buffer can reduce the number of calls made to the next layer to write data.</p>
<p>The default setting is 4096. The minimum value is 8.</p>
<p>The write buffer size can only be changed when the stream is not open. Undefined behavior results if the option is modified after a successful WebSocket handshake.</p>
<dl class="section user"><dt>Example</dt><dd>Setting the write buffer size. <div class="fragment"><div class="line">ws.write_buffer_bytes(8192);</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">amount</td><td>The size of the write buffer in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab89b2616d52318049135e78ecbb4b2f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab89b2616d52318049135e78ecbb4b2f0">&#9670;&nbsp;</a></span>write_some() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::write_some </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write some message data.</p>
<p>This function is used to send part of a message.</p>
<p>The call blocks until one of the following is true:</p>
<ul>
<li>The message data is written.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed operation</em>, is implemented in terms of calls to the next layer's <code>write_some</code> function.</p>
<p>If this is the beginning of a new message, the message opcode will be set to text or binary based on the current setting of the <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#acc58448ca669614fd60c6c1d22ba7a41">binary</a> (or <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a90e77bd4c9cf9d84f936439a14d88d6a">text</a>) option. The actual payload sent may be transformed as per the WebSocket protocol settings.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">fin</td><td><code>true</code> if this is the last part of the message.</td></tr>
    <tr><td class="paramname">buffers</td><td>The buffers containing the message part to send.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The number of bytes sent from the buffers.</dd></dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a475647c28dd13ee9414a3f53befcb417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a475647c28dd13ee9414a3f53befcb417">&#9670;&nbsp;</a></span>write_some() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer , bool deflateSupported&gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer, deflateSupported &gt;::write_some </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write some message data.</p>
<p>This function is used to send part of a message.</p>
<p>The call blocks until one of the following is true:</p>
<ul>
<li>The message data is written.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed operation</em>, is implemented in terms of calls to the next layer's <code>write_some</code> function.</p>
<p>If this is the beginning of a new message, the message opcode will be set to text or binary based on the current setting of the <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#acc58448ca669614fd60c6c1d22ba7a41">binary</a> (or <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a90e77bd4c9cf9d84f936439a14d88d6a">text</a>) option. The actual payload sent may be transformed as per the WebSocket protocol settings.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">fin</td><td><code>true</code> if this is the last part of the message.</td></tr>
    <tr><td class="paramname">buffers</td><td>The buffers containing the message part to send.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The number of bytes sent from the buffers.</dd>
<dd>
The number of bytes consumed in the input buffers. </dd></dl>

</div>
</div>
<hr/>このクラス詳解は次のファイルから抽出されました:<ul>
<li>include/external/boost/boost/beast/websocket/<a class="el" href="external_2boost_2boost_2beast_2websocket_2stream_8hpp_source.html">stream.hpp</a></li>
<li>include/external/boost/boost/beast/websocket/impl/<a class="el" href="accept_8hpp_source.html">accept.hpp</a></li>
<li>include/external/boost/boost/beast/websocket/impl/<a class="el" href="close_8hpp_source.html">close.hpp</a></li>
<li>include/external/boost/boost/beast/websocket/impl/<a class="el" href="handshake_8hpp_source.html">handshake.hpp</a></li>
<li>include/external/boost/boost/beast/websocket/impl/<a class="el" href="ping_8hpp_source.html">ping.hpp</a></li>
<li>include/external/boost/boost/beast/websocket/impl/<a class="el" href="websocket_2impl_2read_8hpp_source.html">read.hpp</a></li>
<li>include/external/boost/boost/beast/websocket/impl/<a class="el" href="beast_2websocket_2impl_2write_8hpp_source.html">write.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceboost.html">boost</a></li><li class="navelem"><b>beast</b></li><li class="navelem"><b>websocket</b></li><li class="navelem"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">stream</a></li>
    <li class="footer">構築:
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
