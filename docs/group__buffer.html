<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
<head>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
        'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
        })(window,document,'script','dataLayer','GTM-NN5JX4B');</script>
    <!-- End Google Tag Manager -->
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=11"/>
    <meta name="generator" content="Doxygen 1.9.8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>SkyWay Linux SDK</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="resize.js"></script>
    <script type="text/javascript" src="navtreedata.js"></script>
    <script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="search/searchdata.js"></script>
    <script type="text/javascript" src="search/search.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NN5JX4B"
        height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
            <tbody>
                <tr id="projectrow">
                    <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
                    <td id="projectalign">
                        <div id="projectname">SkyWay Linux SDK
                        </div>
                    </td>
                </tr>
            </tbody>
        </table>
    </div><!-- 構築: Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'検索');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','検索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__buffer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">boost::asio::buffer</div>  </div>
</div><!--header-->
<div class="contents">

<p>The boost::asio::buffer function is used to create a buffer object to represent raw memory, an array of POD elements, a vector of POD elements, or a std::string.  
<a href="#details">[詳解]</a></p>
<p>The boost::asio::buffer function is used to create a buffer object to represent raw memory, an array of POD elements, a vector of POD elements, or a std::string. </p>
<p>A buffer object represents a contiguous region of memory as a 2-tuple consisting of a pointer and size in bytes. A tuple of the form <code>{void*, size_t}</code> specifies a mutable (modifiable) region of memory. Similarly, a tuple of the form <code>{const void*, size_t}</code> specifies a const (non-modifiable) region of memory. These two forms correspond to the classes <a class="el" href="classboost_1_1asio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a> and <a class="el" href="classboost_1_1asio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a>, respectively. To mirror C++'s conversion rules, a <a class="el" href="classboost_1_1asio_1_1mutable__buffer.html" title="Holds a buffer that can be modified.">mutable_buffer</a> is implicitly convertible to a <a class="el" href="classboost_1_1asio_1_1const__buffer.html" title="Holds a buffer that cannot be modified.">const_buffer</a>, and the opposite conversion is not permitted.</p>
<p>The simplest use case involves reading or writing a single buffer of a specified size:</p>
<div class="fragment"><div class="line">sock.send(boost::asio::buffer(data, size)); </div>
</div><!-- fragment --><p>In the above example, the return value of boost::asio::buffer meets the requirements of the ConstBufferSequence concept so that it may be directly passed to the socket's write function. A buffer created for modifiable memory also meets the requirements of the MutableBufferSequence concept.</p>
<p>An individual buffer may be created from a builtin array, std::vector, std::array or <a class="el" href="classboost_1_1array.html">boost::array</a> of POD elements. This helps prevent buffer overruns by automatically determining the size of the buffer:</p>
<div class="fragment"><div class="line"> <span class="keywordtype">char</span> d1[128];</div>
<div class="line"><span class="keywordtype">size_t</span> bytes_transferred = sock.receive(boost::asio::buffer(d1));</div>
<div class="line"> </div>
<div class="line">std::vector&lt;char&gt; d2(128);</div>
<div class="line">bytes_transferred = sock.receive(boost::asio::buffer(d2));</div>
<div class="line"> </div>
<div class="line">std::array&lt;char, 128&gt; d3;</div>
<div class="line">bytes_transferred = sock.receive(boost::asio::buffer(d3));</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classboost_1_1array.html">boost::array&lt;char, 128&gt;</a> d4;</div>
<div class="line">bytes_transferred = sock.receive(boost::asio::buffer(d4)); </div>
</div><!-- fragment --><p>In all three cases above, the buffers created are exactly 128 bytes long. Note that a vector is <em>never</em> automatically resized when creating or using a buffer. The buffer size is determined using the vector's <code>size()</code> member function, and not its capacity.</p>
<dl class="section user"><dt>Accessing Buffer Contents</dt><dd></dd></dl>
<p>The contents of a buffer may be accessed using the <code>data()</code> and <code>size()</code> member functions:</p>
<div class="fragment"><div class="line"> <a class="code" href="classboost_1_1asio_1_1mutable__buffer.html">boost::asio::mutable_buffer</a> b1 = ...;</div>
<div class="line">std::size_t s1 = b1.<a class="code" href="classboost_1_1asio_1_1mutable__buffer.html#ac321b2d629c31a6cad8d5524053d7456">size</a>();</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* p1 = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(b1.<a class="code" href="classboost_1_1asio_1_1mutable__buffer.html#ad0426d6680c8e77185557c22c4ef2570">data</a>());</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classboost_1_1asio_1_1const__buffer.html">boost::asio::const_buffer</a> b2 = ...;</div>
<div class="line">std::size_t s2 = b2.<a class="code" href="classboost_1_1asio_1_1const__buffer.html#a6c190d85046b96a0bfba75f744bb17a6">size</a>();</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">void</span>* p2 = b2.<a class="code" href="classboost_1_1asio_1_1const__buffer.html#abe3ef3a8f86f87a783584491aac2c793">data</a>(); </div>
</div><!-- fragment --><p>The <code>data()</code> member function permits violations of type safety, so uses of it in application code should be carefully considered.</p>
<p>For convenience, a buffer_size function is provided that works with both buffers and buffer sequences (that is, types meeting the ConstBufferSequence or MutableBufferSequence type requirements). In this case, the function returns the total size of all buffers in the sequence.</p>
<dl class="section user"><dt>Buffer Copying</dt><dd></dd></dl>
<p>The <a class="el" href="group__buffer__copy.html">boost::asio::buffer_copy</a> function may be used to copy raw bytes between individual buffers and buffer sequences.</p>
<p>In particular, when used with the buffer_size function, the <a class="el" href="group__buffer__copy.html">boost::asio::buffer_copy</a> function can be used to linearise a sequence of buffers. For example:</p>
<div class="fragment"><div class="line"> vector&lt;const_buffer&gt; buffers = ...;</div>
<div class="line"> </div>
<div class="line">vector&lt;unsigned char&gt; data(boost::asio::buffer_size(buffers));</div>
<div class="line">boost::asio::buffer_copy(boost::asio::buffer(data), buffers); </div>
</div><!-- fragment --><p>Note that <a class="el" href="group__buffer__copy.html">boost::asio::buffer_copy</a> is implemented in terms of <code>memcpy</code>, and consequently it cannot be used to copy between overlapping memory regions.</p>
<dl class="section user"><dt>Buffer Invalidation</dt><dd></dd></dl>
<p>A buffer object does not have any ownership of the memory it refers to. It is the responsibility of the application to ensure the memory region remains valid until it is no longer required for an I/O operation. When the memory is no longer available, the buffer is said to have been invalidated.</p>
<p>For the boost::asio::buffer overloads that accept an argument of type std::vector, the buffer objects returned are invalidated by any vector operation that also invalidates all references, pointers and iterators referring to the elements in the sequence (C++ Std, 23.2.4)</p>
<p>For the boost::asio::buffer overloads that accept an argument of type std::basic_string, the buffer objects returned are invalidated according to the rules defined for invalidation of references, pointers and iterators referring to elements of the sequence (C++ Std, 21.3).</p>
<dl class="section user"><dt>Buffer Arithmetic</dt><dd></dd></dl>
<p>Buffer objects may be manipulated using simple arithmetic in a safe way which helps prevent buffer overruns. Consider an array initialised as follows:</p>
<div class="fragment"><div class="line"><a class="code" href="classboost_1_1array.html">boost::array&lt;char, 6&gt;</a> a = { <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span> }; </div>
</div><!-- fragment --><p>A buffer object <code>b1</code> created using:</p>
<div class="fragment"><div class="line">b1 = boost::asio::buffer(a); </div>
</div><!-- fragment --><p>represents the entire array, <code>{ 'a', 'b', 'c', 'd', 'e' }</code>. An optional second argument to the boost::asio::buffer function may be used to limit the size, in bytes, of the buffer:</p>
<div class="fragment"><div class="line">b2 = boost::asio::buffer(a, 3); </div>
</div><!-- fragment --><p>such that <code>b2</code> represents the data <code>{ 'a', 'b', 'c' }</code>. Even if the size argument exceeds the actual size of the array, the size of the buffer object created will be limited to the array size.</p>
<p>An offset may be applied to an existing buffer to create a new one:</p>
<div class="fragment"><div class="line">b3 = b1 + 2; </div>
</div><!-- fragment --><p>where <code>b3</code> will set to represent <code>{ 'c', 'd', 'e' }</code>. If the offset exceeds the size of the existing buffer, the newly created buffer will be empty.</p>
<p>Both an offset and size may be specified to create a buffer that corresponds to a specific range of bytes within an existing buffer:</p>
<div class="fragment"><div class="line">b4 = boost::asio::buffer(b1 + 1, 3); </div>
</div><!-- fragment --><p>so that <code>b4</code> will refer to the bytes <code>{ 'b', 'c', 'd' }</code>.</p>
<dl class="section user"><dt>Buffers and Scatter-Gather I/O</dt><dd></dd></dl>
<p>To read or write using multiple buffers (i.e. scatter-gather I/O), multiple buffer objects may be assigned into a container that supports the MutableBufferSequence (for read) or ConstBufferSequence (for write) concepts:</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> d1[128];</div>
<div class="line">std::vector&lt;char&gt; d2(128);</div>
<div class="line"><a class="code" href="classboost_1_1array.html">boost::array&lt;char, 128&gt;</a> d3;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classboost_1_1array.html">boost::array&lt;mutable_buffer, 3&gt;</a> bufs1 = {</div>
<div class="line">  boost::asio::buffer(d1),</div>
<div class="line">  boost::asio::buffer(d2),</div>
<div class="line">  boost::asio::buffer(d3) };</div>
<div class="line">bytes_transferred = sock.receive(bufs1);</div>
<div class="line"> </div>
<div class="line">std::vector&lt;const_buffer&gt; bufs2;</div>
<div class="line">bufs2.push_back(boost::asio::buffer(d1));</div>
<div class="line">bufs2.push_back(boost::asio::buffer(d2));</div>
<div class="line">bufs2.push_back(boost::asio::buffer(d3));</div>
<div class="line">bytes_transferred = sock.send(bufs2); </div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="aclassboost_1_1asio_1_1mutable__buffer_html"><div class="ttname"><a href="classboost_1_1asio_1_1mutable__buffer.html">boost::asio::mutable_buffer</a></div><div class="ttdoc">Holds a buffer that can be modified.</div><div class="ttdef"><b>Definition:</b> buffer.hpp:93</div></div>
<div class="ttc" id="aclassboost_1_1asio_1_1const__buffer_html_a6c190d85046b96a0bfba75f744bb17a6"><div class="ttname"><a href="classboost_1_1asio_1_1const__buffer.html#a6c190d85046b96a0bfba75f744bb17a6">boost::asio::const_buffer::size</a></div><div class="ttdeci">std::size_t size() const BOOST_ASIO_NOEXCEPT</div><div class="ttdoc">Get the size of the memory range.</div><div class="ttdef"><b>Definition:</b> buffer.hpp:280</div></div>
<div class="ttc" id="aclassboost_1_1asio_1_1const__buffer_html"><div class="ttname"><a href="classboost_1_1asio_1_1const__buffer.html">boost::asio::const_buffer</a></div><div class="ttdoc">Holds a buffer that cannot be modified.</div><div class="ttdef"><b>Definition:</b> buffer.hpp:227</div></div>
<div class="ttc" id="aclassboost_1_1asio_1_1mutable__buffer_html_ad0426d6680c8e77185557c22c4ef2570"><div class="ttname"><a href="classboost_1_1asio_1_1mutable__buffer.html#ad0426d6680c8e77185557c22c4ef2570">boost::asio::mutable_buffer::data</a></div><div class="ttdeci">void * data() const BOOST_ASIO_NOEXCEPT</div><div class="ttdoc">Get a pointer to the beginning of the memory range.</div><div class="ttdef"><b>Definition:</b> buffer.hpp:126</div></div>
<div class="ttc" id="aclassboost_1_1array_html"><div class="ttname"><a href="classboost_1_1array.html">boost::array</a></div><div class="ttdef"><b>Definition:</b> array.hpp:60</div></div>
<div class="ttc" id="aclassboost_1_1asio_1_1const__buffer_html_abe3ef3a8f86f87a783584491aac2c793"><div class="ttname"><a href="classboost_1_1asio_1_1const__buffer.html#abe3ef3a8f86f87a783584491aac2c793">boost::asio::const_buffer::data</a></div><div class="ttdeci">const void * data() const BOOST_ASIO_NOEXCEPT</div><div class="ttdoc">Get a pointer to the beginning of the memory range.</div><div class="ttdef"><b>Definition:</b> buffer.hpp:270</div></div>
<div class="ttc" id="aclassboost_1_1asio_1_1mutable__buffer_html_ac321b2d629c31a6cad8d5524053d7456"><div class="ttname"><a href="classboost_1_1asio_1_1mutable__buffer.html#ac321b2d629c31a6cad8d5524053d7456">boost::asio::mutable_buffer::size</a></div><div class="ttdeci">std::size_t size() const BOOST_ASIO_NOEXCEPT</div><div class="ttdoc">Get the size of the memory range.</div><div class="ttdef"><b>Definition:</b> buffer.hpp:136</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">構築:
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
