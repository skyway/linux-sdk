<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
<head>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
        'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
        })(window,document,'script','dataLayer','GTM-NN5JX4B');</script>
    <!-- End Google Tag Manager -->
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=11"/>
    <meta name="generator" content="Doxygen 1.9.8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>SkyWay Linux SDK</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="resize.js"></script>
    <script type="text/javascript" src="navtreedata.js"></script>
    <script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="search/searchdata.js"></script>
    <script type="text/javascript" src="search/search.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NN5JX4B"
        height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
            <tbody>
                <tr id="projectrow">
                    <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
                    <td id="projectalign">
                        <div id="projectname">SkyWay Linux SDK
                        </div>
                    </td>
                </tr>
            </tbody>
        </table>
    </div><!-- 構築: Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'検索');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','検索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classboost_1_1beast_1_1async__base.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">公開型</a> &#124;
<a href="#pub-methods">公開メンバ関数</a> &#124;
<a href="classboost_1_1beast_1_1async__base-members.html">全メンバ一覧</a>  </div>
  <div class="headertitle">
<div class="title">boost::beast::async_base&lt; Handler, Executor1, Allocator &gt; クラステンプレート</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="async__base_8hpp_source.html">async_base.hpp</a>&gt;</code></p>
<div class="dynheader">
boost::beast::async_base&lt; Handler, Executor1, Allocator &gt; の継承関係図</div>
<div class="dyncontent">
 <div class="center">
  <img src="classboost_1_1beast_1_1async__base.png" usemap="#boost::beast::async_5Fbase_3C_20Handler_2C_20Executor1_2C_20Allocator_20_3E_map" alt=""/>
  <map id="boost::beast::async_5Fbase_3C_20Handler_2C_20Executor1_2C_20Allocator_20_3E_map" name="boost::beast::async_5Fbase_3C_20Handler_2C_20Executor1_2C_20Allocator_20_3E_map">
<area href="classboost_1_1empty___1_1empty__value.html" alt="boost::empty_::empty_value&lt; T, N, E &gt;" shape="rect" coords="0,0,347,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
公開型</h2></td></tr>
<tr class="memitem:a34bf423eb7bb284dd1e740ed0e009b42"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1async__base.html#a34bf423eb7bb284dd1e740ed0e009b42">executor_type</a> = typename <a class="el" href="structboost_1_1asio_1_1associated__executor.html">net::associated_executor</a>&lt; Handler, typename detail::select_work_guard_t&lt; Executor1 &gt;::<a class="el" href="classboost_1_1beast_1_1async__base.html#a34bf423eb7bb284dd1e740ed0e009b42">executor_type</a> &gt;::type</td></tr>
<tr class="separator:a34bf423eb7bb284dd1e740ed0e009b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc29d21f36269207b3117e227c468c0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1async__base.html#aadc29d21f36269207b3117e227c468c0">allocator_type</a> = net::associated_allocator_t&lt; Handler, Allocator &gt;</td></tr>
<tr class="separator:aadc29d21f36269207b3117e227c468c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
公開メンバ関数</h2></td></tr>
<tr class="memitem:a99299e04284c1195525a4d63f33f0cf4"><td class="memTemplParams" colspan="2">template&lt;class Handler_ , class  = typename std::enable_if&lt;            ! std::is_same&lt;typename                std::decay&lt;Handler_&gt;::type,                async_base            &gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a99299e04284c1195525a4d63f33f0cf4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1async__base.html#a99299e04284c1195525a4d63f33f0cf4">async_base</a> (Handler_ &amp;&amp;<a class="el" href="classboost_1_1beast_1_1async__base.html#abe01a96330049c65f0de233617661813">handler</a>, Executor1 const &amp;ex1)</td></tr>
<tr class="separator:a99299e04284c1195525a4d63f33f0cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49de0bbb8649957481b70d13bb9b6d40"><td class="memTemplParams" colspan="2"><a id="a49de0bbb8649957481b70d13bb9b6d40"></a>
template&lt;class Handler_ &gt; </td></tr>
<tr class="memitem:a49de0bbb8649957481b70d13bb9b6d40"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>async_base</b> (Handler_ &amp;&amp;<a class="el" href="classboost_1_1beast_1_1async__base.html#abe01a96330049c65f0de233617661813">handler</a>, Executor1 const &amp;ex1, Allocator const &amp;alloc)</td></tr>
<tr class="separator:a49de0bbb8649957481b70d13bb9b6d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c48dd74e75ce95a07ec8d2f762436e"><td class="memItemLeft" align="right" valign="top"><a id="ab7c48dd74e75ce95a07ec8d2f762436e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1async__base.html#ab7c48dd74e75ce95a07ec8d2f762436e">async_base</a> (<a class="el" href="classboost_1_1beast_1_1async__base.html">async_base</a> &amp;&amp;other)=default</td></tr>
<tr class="memdesc:ab7c48dd74e75ce95a07ec8d2f762436e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move Constructor <br /></td></tr>
<tr class="separator:ab7c48dd74e75ce95a07ec8d2f762436e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a7017977b8555f42fa535c27ebdb34"><td class="memItemLeft" align="right" valign="top"><a id="a74a7017977b8555f42fa535c27ebdb34"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>async_base</b> (<a class="el" href="classboost_1_1beast_1_1async__base.html">async_base</a> const &amp;)=delete</td></tr>
<tr class="separator:a74a7017977b8555f42fa535c27ebdb34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a371c96cef7840f5768175e590d70620b"><td class="memItemLeft" align="right" valign="top"><a id="a371c96cef7840f5768175e590d70620b"></a>
<a class="el" href="classboost_1_1beast_1_1async__base.html">async_base</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classboost_1_1beast_1_1async__base.html">async_base</a> const &amp;)=delete</td></tr>
<tr class="separator:a371c96cef7840f5768175e590d70620b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2015267035930ff804df6cabbd1f78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1async__base.html#aadc29d21f36269207b3117e227c468c0">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1async__base.html#a6e2015267035930ff804df6cabbd1f78">get_allocator</a> () const noexcept</td></tr>
<tr class="separator:a6e2015267035930ff804df6cabbd1f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb531dd62c0c2d4b0a0846b9ab2ff8be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1async__base.html#a34bf423eb7bb284dd1e740ed0e009b42">executor_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1async__base.html#abb531dd62c0c2d4b0a0846b9ab2ff8be">get_executor</a> () const noexcept</td></tr>
<tr class="separator:abb531dd62c0c2d4b0a0846b9ab2ff8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe01a96330049c65f0de233617661813"><td class="memItemLeft" align="right" valign="top"><a id="abe01a96330049c65f0de233617661813"></a>
Handler const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1async__base.html#abe01a96330049c65f0de233617661813">handler</a> () const noexcept</td></tr>
<tr class="memdesc:abe01a96330049c65f0de233617661813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the handler associated with this object <br /></td></tr>
<tr class="separator:abe01a96330049c65f0de233617661813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20d783ce163443781f97dfa20c99376"><td class="memItemLeft" align="right" valign="top">Handler&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1async__base.html#ad20d783ce163443781f97dfa20c99376">release_handler</a> ()</td></tr>
<tr class="separator:ad20d783ce163443781f97dfa20c99376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29215ff56ff262e4703ec56dd973166"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ad29215ff56ff262e4703ec56dd973166"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1async__base.html#ad29215ff56ff262e4703ec56dd973166">complete</a> (bool is_continuation, Args &amp;&amp;... args)</td></tr>
<tr class="separator:ad29215ff56ff262e4703ec56dd973166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264c45bc7c0def00869cc0984ac2bee8"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a264c45bc7c0def00869cc0984ac2bee8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1async__base.html#a264c45bc7c0def00869cc0984ac2bee8">complete_now</a> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:a264c45bc7c0def00869cc0984ac2bee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3de34b0ed0a41e868873946abe7fd3"><td class="memItemLeft" align="right" valign="top"><a id="a3c3de34b0ed0a41e868873946abe7fd3"></a>
Handler *&#160;</td><td class="memItemRight" valign="bottom"><b>get_legacy_handler_pointer</b> () noexcept</td></tr>
<tr class="separator:a3c3de34b0ed0a41e868873946abe7fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">詳解</h2>
<div class="textblock"><h3>template&lt;class Handler, class Executor1, class Allocator = std::allocator&lt;void&gt;&gt;<br />
class boost::beast::async_base&lt; Handler, Executor1, Allocator &gt;</h3>

<p>Base class to assist writing composed operations.</p>
<p>A function object submitted to intermediate initiating functions during a composed operation may derive from this type to inherit all of the boilerplate to forward the executor, allocator, and legacy customization points associated with the completion handler invoked at the end of the composed operation.</p>
<p>The composed operation must be typical; that is, associated with one executor of an I/O object, and invoking a caller-provided completion handler when the operation is finished. Classes derived from <a class="el" href="classboost_1_1beast_1_1async__base.html">async_base</a> will acquire these properties:</p>
<ul>
<li>Ownership of the final completion handler provided upon construction.</li>
</ul>
<ul>
<li>If the final handler has an associated allocator, this allocator will be propagated to the composed operation subclass. Otherwise, the associated allocator will be the type specified in the allocator template parameter, or the default of <code>std::allocator&lt;void&gt;</code> if the parameter is omitted.</li>
</ul>
<ul>
<li>If the final handler has an associated executor, then it will be used as the executor associated with the composed operation. Otherwise, the specified <code>Executor1</code> will be the type of executor associated with the composed operation.</li>
</ul>
<ul>
<li>An instance of <code>net::executor_work_guard</code> for the instance of <code>Executor1</code> shall be maintained until either the final handler is invoked, or the operation base is destroyed, whichever comes first.</li>
</ul>
<ul>
<li>Calls to the legacy customization points <code>asio_handler_invoke</code>, <code>asio_handler_allocate</code>, <code>asio_handler_deallocate</code>, and <code>asio_handler_is_continuation</code>, which use argument-dependent lookup, will be forwarded to the legacy customization points associated with the handler.</li>
</ul>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<p>The following code demonstrates how <a class="el" href="classboost_1_1beast_1_1async__base.html">async_base</a> may be be used to assist authoring an asynchronous initiating function, by providing all of the boilerplate to manage the final completion handler in a way that maintains the allocator and executor associations:</p>
<div class="fragment"><div class="line"><span class="comment">// Asynchronously read into a buffer until the buffer is full, or an error occurs</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> AsyncReadStream, <span class="keyword">class</span> ReadHandler&gt;</div>
<div class="line"><span class="keyword">typename</span> <a class="code" href="classboost_1_1asio_1_1async__result.html">net::async_result</a>&lt;ReadHandler, void(error_code, std::size_t)&gt;::return_type</div>
<div class="line">async_read(AsyncReadStream&amp; stream, <a class="code" href="classboost_1_1asio_1_1mutable__buffer.html">net::mutable_buffer</a> buffer, ReadHandler&amp;&amp; <a class="code" href="classboost_1_1beast_1_1async__base.html#abe01a96330049c65f0de233617661813">handler</a>)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> handler_type = BOOST_ASIO_HANDLER_TYPE(ReadHandler, <span class="keywordtype">void</span>(error_code, std::size_t));</div>
<div class="line">    <span class="keyword">using</span> base_type = async_base&lt;handler_type, typename AsyncReadStream::executor_type&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">struct </span>op : base_type</div>
<div class="line">    {</div>
<div class="line">        AsyncReadStream&amp; stream_;</div>
<div class="line">        <a class="code" href="classboost_1_1asio_1_1mutable__buffer.html">net::mutable_buffer</a> buffer_;</div>
<div class="line">        std::size_t total_bytes_transferred_;</div>
<div class="line"> </div>
<div class="line">        op(</div>
<div class="line">            AsyncReadStream&amp; stream,</div>
<div class="line">            <a class="code" href="classboost_1_1asio_1_1mutable__buffer.html">net::mutable_buffer</a> buffer,</div>
<div class="line">            handler_type&amp; <a class="code" href="classboost_1_1beast_1_1async__base.html#abe01a96330049c65f0de233617661813">handler</a>)</div>
<div class="line">            : base_type(std::move(<a class="code" href="classboost_1_1beast_1_1async__base.html#abe01a96330049c65f0de233617661813">handler</a>), stream.<a class="code" href="classboost_1_1beast_1_1async__base.html#abb531dd62c0c2d4b0a0846b9ab2ff8be">get_executor</a>())</div>
<div class="line">            , stream_(stream)</div>
<div class="line">            , buffer_(buffer)</div>
<div class="line">            , total_bytes_transferred_(0)</div>
<div class="line">        {</div>
<div class="line">            (*this)({}, 0, <span class="keyword">false</span>); <span class="comment">// start the operation</span></div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">void</span> operator()(error_code ec, std::size_t bytes_transferred, <span class="keywordtype">bool</span> is_continuation = <span class="keyword">true</span>)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Adjust the count of bytes and advance our buffer</span></div>
<div class="line">            total_bytes_transferred_ += bytes_transferred;</div>
<div class="line">            buffer_ = buffer_ + bytes_transferred;</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Keep reading until buffer is full or an error occurs</span></div>
<div class="line">            <span class="keywordflow">if</span>(! ec &amp;&amp; buffer_.<a class="code" href="classboost_1_1asio_1_1mutable__buffer.html#ac321b2d629c31a6cad8d5524053d7456">size</a>() &gt; 0)</div>
<div class="line">                <span class="keywordflow">return</span> stream_.async_read_some(buffer_, std::move(*<span class="keyword">this</span>));</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Call the completion handler with the result. If `is_continuation` is</span></div>
<div class="line">            <span class="comment">// false, which happens on the first time through this function, then</span></div>
<div class="line">            <span class="comment">// `net::post` will be used to call the completion handler, otherwise</span></div>
<div class="line">            <span class="comment">// the completion handler will be invoked directly.</span></div>
<div class="line"> </div>
<div class="line">            this-&gt;<a class="code" href="classboost_1_1beast_1_1async__base.html#ad29215ff56ff262e4703ec56dd973166">complete</a>(is_continuation, ec, total_bytes_transferred_);</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="structboost_1_1asio_1_1async__completion.html">net::async_completion</a>&lt;ReadHandler, void(error_code, std::size_t)&gt; init{<a class="code" href="classboost_1_1beast_1_1async__base.html#abe01a96330049c65f0de233617661813">handler</a>};</div>
<div class="line">    op(stream, buffer, init.completion_handler);</div>
<div class="line">    <span class="keywordflow">return</span> init.result.get();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Data members of composed operations implemented as completion handlers do not have stable addresses, as the composed operation object is move constructed upon each call to an initiating function. For most operations this is not a problem. For complex operations requiring stable temporary storage, the class <a class="el" href="classboost_1_1beast_1_1stable__async__base.html">stable_async_base</a> is provided which offers additional functionality:</p>
<ul>
<li>The free function allocate_stable may be used to allocate one or more temporary objects associated with the composed operation.</li>
</ul>
<ul>
<li>Memory for stable temporary objects is allocated using the allocator associated with the composed operation.</li>
</ul>
<ul>
<li>Stable temporary objects are automatically destroyed, and the memory freed using the associated allocator, either before the final completion handler is invoked (a Networking requirement) or when the composed operation is destroyed, whichever occurs first.</li>
</ul>
<dl class="section user"><dt>Temporary Storage Example</dt><dd></dd></dl>
<p>The following example demonstrates how a composed operation may store a temporary object.</p>
<div class="fragment"></div><!-- fragment --><dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Handler</td><td>The type of the completion handler to store. This type must meet the requirements of <em>CompletionHandler</em>.</td></tr>
    <tr><td class="paramname">Executor1</td><td>The type of the executor used when the handler has no associated executor. An instance of this type must be provided upon construction. The implementation will maintain an executor work guard and a copy of this instance.</td></tr>
    <tr><td class="paramname">Allocator</td><td>The allocator type to use if the handler does not have an associated allocator. If this parameter is omitted, then <code>std::allocator&lt;void&gt;</code> will be used. If the specified allocator is not default constructible, an instance of the type must be provided upon construction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="classboost_1_1beast_1_1stable__async__base.html">stable_async_base</a> </dd></dl>
</div><h2 class="groupheader">型定義メンバ詳解</h2>
<a id="aadc29d21f36269207b3117e227c468c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadc29d21f36269207b3117e227c468c0">&#9670;&nbsp;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Handler , class Executor1 , class Allocator  = std::allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classboost_1_1beast_1_1async__base.html">boost::beast::async_base</a>&lt; Handler, Executor1, Allocator &gt;::<a class="el" href="classboost_1_1beast_1_1async__base.html#aadc29d21f36269207b3117e227c468c0">allocator_type</a> =  net::associated_allocator_t&lt;Handler, Allocator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of allocator associated with this object.</p>
<p>If a class derived from <a class="el" href="classboost_1_1beast_1_1async__base.html">async_base</a> is a completion handler, then the associated allocator of the derived class will be this type. </p>

</div>
</div>
<a id="a34bf423eb7bb284dd1e740ed0e009b42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34bf423eb7bb284dd1e740ed0e009b42">&#9670;&nbsp;</a></span>executor_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Handler , class Executor1 , class Allocator  = std::allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classboost_1_1beast_1_1async__base.html">boost::beast::async_base</a>&lt; Handler, Executor1, Allocator &gt;::<a class="el" href="classboost_1_1beast_1_1async__base.html#a34bf423eb7bb284dd1e740ed0e009b42">executor_type</a> =  typename <a class="el" href="structboost_1_1asio_1_1associated__executor.html">net::associated_executor</a>&lt; Handler, typename detail::select_work_guard_t&lt;Executor1&gt;::<a class="el" href="classboost_1_1beast_1_1async__base.html#a34bf423eb7bb284dd1e740ed0e009b42">executor_type</a> &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of executor associated with this object.</p>
<p>If a class derived from <a class="el" href="classboost_1_1beast_1_1async__base.html">async_base</a> is a completion handler, then the associated executor of the derived class will be this type. </p>

</div>
</div>
<h2 class="groupheader">構築子と解体子</h2>
<a id="a99299e04284c1195525a4d63f33f0cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99299e04284c1195525a4d63f33f0cf4">&#9670;&nbsp;</a></span>async_base()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Handler , class Executor1 , class Allocator  = std::allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Handler_ , class  = typename std::enable_if&lt;            ! std::is_same&lt;typename                std::decay&lt;Handler_&gt;::type,                async_base            &gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1async__base.html">boost::beast::async_base</a>&lt; Handler, Executor1, Allocator &gt;::<a class="el" href="classboost_1_1beast_1_1async__base.html">async_base</a> </td>
          <td>(</td>
          <td class="paramtype">Handler_ &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Executor1 const &amp;&#160;</td>
          <td class="paramname"><em>ex1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>The final completion handler. The type of this object must meet the requirements of <em>CompletionHandler</em>. The implementation takes ownership of the handler by performing a decay-copy.</td></tr>
    <tr><td class="paramname">ex1</td><td>The executor associated with the implied I/O object target of the operation. The implementation shall maintain an executor work guard for the lifetime of the operation, or until the final completion handler is invoked, whichever is shorter.</td></tr>
    <tr><td class="paramname">alloc</td><td>The allocator to be associated with objects derived from this class. If <code>Allocator</code> is default-constructible, this parameter is optional and may be omitted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">関数詳解</h2>
<a id="ad29215ff56ff262e4703ec56dd973166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad29215ff56ff262e4703ec56dd973166">&#9670;&nbsp;</a></span>complete()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Handler , class Executor1 , class Allocator  = std::allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1async__base.html">boost::beast::async_base</a>&lt; Handler, Executor1, Allocator &gt;::complete </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_continuation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Invoke the final completion handler, maybe using post.</p>
<p>This invokes the final completion handler with the specified arguments forwarded. It is undefined to call either of <a class="el" href="classboost_1_1beast_1_1async__base.html#ad29215ff56ff262e4703ec56dd973166">complete</a> or <a class="el" href="classboost_1_1beast_1_1async__base.html#a264c45bc7c0def00869cc0984ac2bee8">complete_now</a> more than once.</p>
<p>Any temporary objects allocated with beast::allocate_stable will be automatically destroyed before the final completion handler is invoked.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">is_continuation</td><td>If this value is <code>false</code>, then the handler will be submitted to the executor using <code>net::post</code>. Otherwise the handler will be invoked as if by calling <a class="el" href="classboost_1_1beast_1_1async__base.html#a264c45bc7c0def00869cc0984ac2bee8">complete_now</a>.</td></tr>
    <tr><td class="paramname">args</td><td>A list of optional parameters to invoke the handler with. The completion handler must be invocable with the parameter list, or else a compilation error will result. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a264c45bc7c0def00869cc0984ac2bee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a264c45bc7c0def00869cc0984ac2bee8">&#9670;&nbsp;</a></span>complete_now()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Handler , class Executor1 , class Allocator  = std::allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1async__base.html">boost::beast::async_base</a>&lt; Handler, Executor1, Allocator &gt;::complete_now </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Invoke the final completion handler.</p>
<p>This invokes the final completion handler with the specified arguments forwarded. It is undefined to call either of <a class="el" href="classboost_1_1beast_1_1async__base.html#ad29215ff56ff262e4703ec56dd973166">complete</a> or <a class="el" href="classboost_1_1beast_1_1async__base.html#a264c45bc7c0def00869cc0984ac2bee8">complete_now</a> more than once.</p>
<p>Any temporary objects allocated with beast::allocate_stable will be automatically destroyed before the final completion handler is invoked.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>A list of optional parameters to invoke the handler with. The completion handler must be invocable with the parameter list, or else a compilation error will result. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e2015267035930ff804df6cabbd1f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e2015267035930ff804df6cabbd1f78">&#9670;&nbsp;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Handler , class Executor1 , class Allocator  = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1async__base.html#aadc29d21f36269207b3117e227c468c0">allocator_type</a> <a class="el" href="classboost_1_1beast_1_1async__base.html">boost::beast::async_base</a>&lt; Handler, Executor1, Allocator &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the allocator associated with this object.</p>
<p>If a class derived from <a class="el" href="classboost_1_1beast_1_1async__base.html">async_base</a> is a completion handler, then the object returned from this function will be used as the associated allocator of the derived class. </p>

</div>
</div>
<a id="abb531dd62c0c2d4b0a0846b9ab2ff8be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb531dd62c0c2d4b0a0846b9ab2ff8be">&#9670;&nbsp;</a></span>get_executor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Handler , class Executor1 , class Allocator  = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1async__base.html#a34bf423eb7bb284dd1e740ed0e009b42">executor_type</a> <a class="el" href="classboost_1_1beast_1_1async__base.html">boost::beast::async_base</a>&lt; Handler, Executor1, Allocator &gt;::get_executor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the executor associated with this object.</p>
<p>If a class derived from <a class="el" href="classboost_1_1beast_1_1async__base.html">async_base</a> is a completion handler, then the object returned from this function will be used as the associated executor of the derived class. </p>

</div>
</div>
<a id="ad20d783ce163443781f97dfa20c99376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad20d783ce163443781f97dfa20c99376">&#9670;&nbsp;</a></span>release_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Handler , class Executor1 , class Allocator  = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Handler <a class="el" href="classboost_1_1beast_1_1async__base.html">boost::beast::async_base</a>&lt; Handler, Executor1, Allocator &gt;::release_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns ownership of the handler associated with this object</p>
<p>This function is used to transfer ownership of the handler to the caller, by move-construction. After the move, the only valid operations on the base object are move construction and destruction. </p>

</div>
</div>
<hr/>このクラス詳解は次のファイルから抽出されました:<ul>
<li>include/external/boost/boost/beast/core/<a class="el" href="async__base_8hpp_source.html">async_base.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="aclassboost_1_1asio_1_1mutable__buffer_html"><div class="ttname"><a href="classboost_1_1asio_1_1mutable__buffer.html">boost::asio::mutable_buffer</a></div><div class="ttdoc">Holds a buffer that can be modified.</div><div class="ttdef"><b>Definition:</b> buffer.hpp:93</div></div>
<div class="ttc" id="aclassboost_1_1beast_1_1async__base_html_abb531dd62c0c2d4b0a0846b9ab2ff8be"><div class="ttname"><a href="classboost_1_1beast_1_1async__base.html#abb531dd62c0c2d4b0a0846b9ab2ff8be">boost::beast::async_base::get_executor</a></div><div class="ttdeci">executor_type get_executor() const noexcept</div><div class="ttdef"><b>Definition:</b> async_base.hpp:305</div></div>
<div class="ttc" id="aclassboost_1_1beast_1_1async__base_html_abe01a96330049c65f0de233617661813"><div class="ttname"><a href="classboost_1_1beast_1_1async__base.html#abe01a96330049c65f0de233617661813">boost::beast::async_base::handler</a></div><div class="ttdeci">Handler const  &amp; handler() const noexcept</div><div class="ttdoc">Returns the handler associated with this object</div><div class="ttdef"><b>Definition:</b> async_base.hpp:313</div></div>
<div class="ttc" id="aclassboost_1_1asio_1_1async__result_html"><div class="ttname"><a href="classboost_1_1asio_1_1async__result.html">boost::asio::async_result</a></div><div class="ttdoc">An interface for customising the behaviour of an initiating function.</div><div class="ttdef"><b>Definition:</b> async_result.hpp:107</div></div>
<div class="ttc" id="aclassboost_1_1asio_1_1mutable__buffer_html_ac321b2d629c31a6cad8d5524053d7456"><div class="ttname"><a href="classboost_1_1asio_1_1mutable__buffer.html#ac321b2d629c31a6cad8d5524053d7456">boost::asio::mutable_buffer::size</a></div><div class="ttdeci">std::size_t size() const BOOST_ASIO_NOEXCEPT</div><div class="ttdoc">Get the size of the memory range.</div><div class="ttdef"><b>Definition:</b> buffer.hpp:136</div></div>
<div class="ttc" id="aclassboost_1_1beast_1_1async__base_html_ad29215ff56ff262e4703ec56dd973166"><div class="ttname"><a href="classboost_1_1beast_1_1async__base.html#ad29215ff56ff262e4703ec56dd973166">boost::beast::async_base::complete</a></div><div class="ttdeci">void complete(bool is_continuation, Args &amp;&amp;... args)</div><div class="ttdef"><b>Definition:</b> async_base.hpp:352</div></div>
<div class="ttc" id="astructboost_1_1asio_1_1async__completion_html"><div class="ttname"><a href="structboost_1_1asio_1_1async__completion.html">boost::asio::async_completion</a></div><div class="ttdef"><b>Definition:</b> async_result.hpp:207</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceboost.html">boost</a></li><li class="navelem"><b>beast</b></li><li class="navelem"><a class="el" href="classboost_1_1beast_1_1async__base.html">async_base</a></li>
    <li class="footer">構築:
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
