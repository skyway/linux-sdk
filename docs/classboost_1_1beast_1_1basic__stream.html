<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
<head>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
        'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
        })(window,document,'script','dataLayer','GTM-NN5JX4B');</script>
    <!-- End Google Tag Manager -->
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=11"/>
    <meta name="generator" content="Doxygen 1.9.8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>SkyWay Linux SDK</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="resize.js"></script>
    <script type="text/javascript" src="navtreedata.js"></script>
    <script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="search/searchdata.js"></script>
    <script type="text/javascript" src="search/search.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NN5JX4B"
        height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
            <tbody>
                <tr id="projectrow">
                    <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
                    <td id="projectalign">
                        <div id="projectname">SkyWay Linux SDK
                        </div>
                    </td>
                </tr>
            </tbody>
        </table>
    </div><!-- 構築: Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'検索');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','検索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classboost_1_1beast_1_1basic__stream.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">クラス</a> &#124;
<a href="#pub-types">公開型</a> &#124;
<a href="#pub-methods">公開メンバ関数</a> &#124;
<a href="#pub-attribs">公開変数類</a> &#124;
<a href="#friends">フレンド</a> &#124;
<a href="classboost_1_1beast_1_1basic__stream-members.html">全メンバ一覧</a>  </div>
  <div class="headertitle">
<div class="title">boost::beast::basic_stream&lt; Protocol, Executor, RatePolicy &gt; クラステンプレート</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="basic__stream_8hpp_source.html">basic_stream.hpp</a>&gt;</code></p>
<div class="dynheader">
boost::beast::basic_stream&lt; Protocol, Executor, RatePolicy &gt; の継承関係図</div>
<div class="dyncontent">
 <div class="center">
  <img src="classboost_1_1beast_1_1basic__stream.png" usemap="#boost::beast::basic_5Fstream_3C_20Protocol_2C_20Executor_2C_20RatePolicy_20_3E_map" alt=""/>
  <map id="boost::beast::basic_5Fstream_3C_20Protocol_2C_20Executor_2C_20RatePolicy_20_3E_map" name="boost::beast::basic_5Fstream_3C_20Protocol_2C_20Executor_2C_20RatePolicy_20_3E_map">
<area href="structboost_1_1beast_1_1detail_1_1stream__base.html" alt="boost::beast::detail::stream_base" shape="rect" coords="0,0,357,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
クラス</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1beast_1_1basic__stream_1_1ops.html">ops</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1beast_1_1basic__stream_1_1rebind__executor.html">rebind_executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebinds the stream type to another executor.  <a href="structboost_1_1beast_1_1basic__stream_1_1rebind__executor.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
公開型</h2></td></tr>
<tr class="memitem:ae6d0d00dfc12e1caa34d216380c1c43e"><td class="memItemLeft" align="right" valign="top"><a id="ae6d0d00dfc12e1caa34d216380c1c43e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#ae6d0d00dfc12e1caa34d216380c1c43e">socket_type</a> = <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html">net::basic_stream_socket</a>&lt; Protocol, Executor &gt;</td></tr>
<tr class="memdesc:ae6d0d00dfc12e1caa34d216380c1c43e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the underlying socket. <br /></td></tr>
<tr class="separator:ae6d0d00dfc12e1caa34d216380c1c43e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8123de0d5f298d1cd39cd9c38e8720bc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#a8123de0d5f298d1cd39cd9c38e8720bc">executor_type</a> = beast::executor_type&lt; <a class="el" href="classboost_1_1beast_1_1basic__stream.html#ae6d0d00dfc12e1caa34d216380c1c43e">socket_type</a> &gt;</td></tr>
<tr class="separator:a8123de0d5f298d1cd39cd9c38e8720bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b66936fa3711bf4d568798b25811a84"><td class="memItemLeft" align="right" valign="top"><a id="a6b66936fa3711bf4d568798b25811a84"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#a6b66936fa3711bf4d568798b25811a84">protocol_type</a> = Protocol</td></tr>
<tr class="memdesc:a6b66936fa3711bf4d568798b25811a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">The protocol type. <br /></td></tr>
<tr class="separator:a6b66936fa3711bf4d568798b25811a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8b4b53a1a8c757057185e88d55502f"><td class="memItemLeft" align="right" valign="top"><a id="acf8b4b53a1a8c757057185e88d55502f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#acf8b4b53a1a8c757057185e88d55502f">endpoint_type</a> = typename Protocol::endpoint</td></tr>
<tr class="memdesc:acf8b4b53a1a8c757057185e88d55502f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The endpoint type. <br /></td></tr>
<tr class="separator:acf8b4b53a1a8c757057185e88d55502f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
公開メンバ関数</h2></td></tr>
<tr class="memitem:af0eb5f82a3347e83746f754d72b77743"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#af0eb5f82a3347e83746f754d72b77743">~basic_stream</a> ()</td></tr>
<tr class="separator:af0eb5f82a3347e83746f754d72b77743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3218f690f613d430f8776e7c63bb57"><td class="memTemplParams" colspan="2">template&lt;class Arg0 , class... Args, class  = typename std::enable_if&lt;        ! std::is_constructible&lt;RatePolicy, Arg0&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aac3218f690f613d430f8776e7c63bb57"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#aac3218f690f613d430f8776e7c63bb57">basic_stream</a> (Arg0 &amp;&amp;argo, Args &amp;&amp;... args)</td></tr>
<tr class="separator:aac3218f690f613d430f8776e7c63bb57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51233e8e2240575d2e2458ca50107c48"><td class="memTemplParams" colspan="2">template&lt;class RatePolicy_ , class Arg0 , class... Args, class  = typename std::enable_if&lt;            std::is_constructible&lt;                RatePolicy, RatePolicy_&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a51233e8e2240575d2e2458ca50107c48"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#a51233e8e2240575d2e2458ca50107c48">basic_stream</a> (RatePolicy_ &amp;&amp;policy, Arg0 &amp;&amp;<a class="el" href="structarg.html">arg</a>, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a51233e8e2240575d2e2458ca50107c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e32b7ae4ef8693b154837655860244"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#a79e32b7ae4ef8693b154837655860244">basic_stream</a> (<a class="el" href="classboost_1_1beast_1_1basic__stream.html">basic_stream</a> &amp;&amp;other)</td></tr>
<tr class="separator:a79e32b7ae4ef8693b154837655860244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb8e7b1395767d55a5ac3142dfaaa11"><td class="memItemLeft" align="right" valign="top"><a id="a9cb8e7b1395767d55a5ac3142dfaaa11"></a>
<a class="el" href="classboost_1_1beast_1_1basic__stream.html">basic_stream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#a9cb8e7b1395767d55a5ac3142dfaaa11">operator=</a> (<a class="el" href="classboost_1_1beast_1_1basic__stream.html">basic_stream</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:a9cb8e7b1395767d55a5ac3142dfaaa11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment (deleted). <br /></td></tr>
<tr class="separator:a9cb8e7b1395767d55a5ac3142dfaaa11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4867e1dc163e3a46d32a5b066dc1973"><td class="memItemLeft" align="right" valign="top"><a id="ae4867e1dc163e3a46d32a5b066dc1973"></a>
<a class="el" href="classboost_1_1beast_1_1basic__stream.html#ae6d0d00dfc12e1caa34d216380c1c43e">socket_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#ae4867e1dc163e3a46d32a5b066dc1973">socket</a> () noexcept</td></tr>
<tr class="memdesc:ae4867e1dc163e3a46d32a5b066dc1973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the underlying socket <br /></td></tr>
<tr class="separator:ae4867e1dc163e3a46d32a5b066dc1973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5933f8d24c5a781b8fd486e6849e6722"><td class="memItemLeft" align="right" valign="top"><a id="a5933f8d24c5a781b8fd486e6849e6722"></a>
<a class="el" href="classboost_1_1beast_1_1basic__stream.html#ae6d0d00dfc12e1caa34d216380c1c43e">socket_type</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#a5933f8d24c5a781b8fd486e6849e6722">socket</a> () const noexcept</td></tr>
<tr class="memdesc:a5933f8d24c5a781b8fd486e6849e6722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the underlying socket <br /></td></tr>
<tr class="separator:a5933f8d24c5a781b8fd486e6849e6722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f4285655f95aa4ef1fc66a9bc42b7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#ae6d0d00dfc12e1caa34d216380c1c43e">socket_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#af8f4285655f95aa4ef1fc66a9bc42b7a">release_socket</a> ()</td></tr>
<tr class="separator:af8f4285655f95aa4ef1fc66a9bc42b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54259318a487894a42f04ccae5d0357f"><td class="memItemLeft" align="right" valign="top"><a id="a54259318a487894a42f04ccae5d0357f"></a>
RatePolicy &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#a54259318a487894a42f04ccae5d0357f">rate_policy</a> () noexcept</td></tr>
<tr class="memdesc:a54259318a487894a42f04ccae5d0357f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rate policy associated with the object <br /></td></tr>
<tr class="separator:a54259318a487894a42f04ccae5d0357f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af347c0ea74beca2da7564904e6db5c3d"><td class="memItemLeft" align="right" valign="top"><a id="af347c0ea74beca2da7564904e6db5c3d"></a>
RatePolicy const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#af347c0ea74beca2da7564904e6db5c3d">rate_policy</a> () const noexcept</td></tr>
<tr class="memdesc:af347c0ea74beca2da7564904e6db5c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rate policy associated with the object <br /></td></tr>
<tr class="separator:af347c0ea74beca2da7564904e6db5c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9aaa1478d079e7729121fbcdc32b52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#aaf9aaa1478d079e7729121fbcdc32b52">expires_after</a> (net::steady_timer::duration expiry_time)</td></tr>
<tr class="separator:aaf9aaa1478d079e7729121fbcdc32b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277a177873e5fed1ba606c03387f9a57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#a277a177873e5fed1ba606c03387f9a57">expires_at</a> (net::steady_timer::time_point expiry_time)</td></tr>
<tr class="separator:a277a177873e5fed1ba606c03387f9a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123246bad8b50ad143da9895e90a869e"><td class="memItemLeft" align="right" valign="top"><a id="a123246bad8b50ad143da9895e90a869e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#a123246bad8b50ad143da9895e90a869e">expires_never</a> ()</td></tr>
<tr class="memdesc:a123246bad8b50ad143da9895e90a869e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the timeout for the next logical operation. <br /></td></tr>
<tr class="separator:a123246bad8b50ad143da9895e90a869e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88493d0b533c4d055d9f91793c0aa3c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#a88493d0b533c4d055d9f91793c0aa3c6">cancel</a> ()</td></tr>
<tr class="separator:a88493d0b533c4d055d9f91793c0aa3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cfbc568c55fdef3c5cd60b2071d221a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#a8cfbc568c55fdef3c5cd60b2071d221a">close</a> ()</td></tr>
<tr class="separator:a8cfbc568c55fdef3c5cd60b2071d221a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c696889183176ae7fc7a141af4e37d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#a8123de0d5f298d1cd39cd9c38e8720bc">executor_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#af3c696889183176ae7fc7a141af4e37d">get_executor</a> () noexcept</td></tr>
<tr class="separator:af3c696889183176ae7fc7a141af4e37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6155abe5ec0abcbc7aa8a82510915e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#aba6155abe5ec0abcbc7aa8a82510915e">connect</a> (<a class="el" href="classboost_1_1beast_1_1basic__stream.html#acf8b4b53a1a8c757057185e88d55502f">endpoint_type</a> const &amp;ep)</td></tr>
<tr class="separator:aba6155abe5ec0abcbc7aa8a82510915e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac01f120038810dac9cae9ac2b49a0454"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#ac01f120038810dac9cae9ac2b49a0454">connect</a> (<a class="el" href="classboost_1_1beast_1_1basic__stream.html#acf8b4b53a1a8c757057185e88d55502f">endpoint_type</a> const &amp;ep, <a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;ec)</td></tr>
<tr class="separator:ac01f120038810dac9cae9ac2b49a0454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42259670d8f33fa6287adaed8a0fa932"><td class="memTemplParams" colspan="2">template&lt;class EndpointSequence , class  = typename std::enable_if&lt;            net::is_endpoint_sequence&lt;                EndpointSequence&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a42259670d8f33fa6287adaed8a0fa932"><td class="memTemplItemLeft" align="right" valign="top">Protocol::endpoint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#a42259670d8f33fa6287adaed8a0fa932">connect</a> (EndpointSequence const &amp;endpoints)</td></tr>
<tr class="separator:a42259670d8f33fa6287adaed8a0fa932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3fee8d5692e2aedd0d0fa29a41ebac6"><td class="memTemplParams" colspan="2">template&lt;class EndpointSequence , class  = typename std::enable_if&lt;            net::is_endpoint_sequence&lt;                EndpointSequence&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:af3fee8d5692e2aedd0d0fa29a41ebac6"><td class="memTemplItemLeft" align="right" valign="top">Protocol::endpoint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#af3fee8d5692e2aedd0d0fa29a41ebac6">connect</a> (EndpointSequence const &amp;endpoints, <a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;ec)</td></tr>
<tr class="separator:af3fee8d5692e2aedd0d0fa29a41ebac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c939e17a39c009e3eaa8c5fbd2fa4d"><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr class="memitem:a93c939e17a39c009e3eaa8c5fbd2fa4d"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#a93c939e17a39c009e3eaa8c5fbd2fa4d">connect</a> (Iterator begin, Iterator end)</td></tr>
<tr class="separator:a93c939e17a39c009e3eaa8c5fbd2fa4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ccbe7bc568008337bd388406dc1056d"><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr class="memitem:a9ccbe7bc568008337bd388406dc1056d"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#a9ccbe7bc568008337bd388406dc1056d">connect</a> (Iterator begin, Iterator end, <a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;ec)</td></tr>
<tr class="separator:a9ccbe7bc568008337bd388406dc1056d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad51494c0febc4c9c66b88b2653f114"><td class="memTemplParams" colspan="2">template&lt;class EndpointSequence , class ConnectCondition , class  = typename std::enable_if&lt;            net::is_endpoint_sequence&lt;                EndpointSequence&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a3ad51494c0febc4c9c66b88b2653f114"><td class="memTemplItemLeft" align="right" valign="top">Protocol::endpoint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#a3ad51494c0febc4c9c66b88b2653f114">connect</a> (EndpointSequence const &amp;endpoints, ConnectCondition connect_condition)</td></tr>
<tr class="separator:a3ad51494c0febc4c9c66b88b2653f114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a38f0f54bb51107d7b2ea034f1902d"><td class="memTemplParams" colspan="2">template&lt;class EndpointSequence , class ConnectCondition , class  = typename std::enable_if&lt;            net::is_endpoint_sequence&lt;                EndpointSequence&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ab6a38f0f54bb51107d7b2ea034f1902d"><td class="memTemplItemLeft" align="right" valign="top">Protocol::endpoint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#ab6a38f0f54bb51107d7b2ea034f1902d">connect</a> (EndpointSequence const &amp;endpoints, ConnectCondition connect_condition, <a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;ec)</td></tr>
<tr class="separator:ab6a38f0f54bb51107d7b2ea034f1902d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579142799c27ab5be6864dfa5c91c3c5"><td class="memTemplParams" colspan="2">template&lt;class Iterator , class ConnectCondition &gt; </td></tr>
<tr class="memitem:a579142799c27ab5be6864dfa5c91c3c5"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#a579142799c27ab5be6864dfa5c91c3c5">connect</a> (Iterator begin, Iterator end, ConnectCondition connect_condition)</td></tr>
<tr class="separator:a579142799c27ab5be6864dfa5c91c3c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7adfe59fefada2b6edeab8870d3ad723"><td class="memTemplParams" colspan="2">template&lt;class Iterator , class ConnectCondition &gt; </td></tr>
<tr class="memitem:a7adfe59fefada2b6edeab8870d3ad723"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#a7adfe59fefada2b6edeab8870d3ad723">connect</a> (Iterator begin, Iterator end, ConnectCondition connect_condition, <a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;ec)</td></tr>
<tr class="separator:a7adfe59fefada2b6edeab8870d3ad723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8097b6371c49d7394118ee2d6cc697"><td class="memTemplParams" colspan="2">template&lt;BOOST_BEAST_ASYNC_TPARAM1 ConnectHandler = net::default_completion_token_t&lt;executor_type&gt;&gt; </td></tr>
<tr class="memitem:afa8097b6371c49d7394118ee2d6cc697"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#afa8097b6371c49d7394118ee2d6cc697">async_connect</a> (<a class="el" href="classboost_1_1beast_1_1basic__stream.html#acf8b4b53a1a8c757057185e88d55502f">endpoint_type</a> const &amp;ep, ConnectHandler &amp;&amp;handler=net::default_completion_token_t&lt; <a class="el" href="classboost_1_1beast_1_1basic__stream.html#a8123de0d5f298d1cd39cd9c38e8720bc">executor_type</a> &gt;{})</td></tr>
<tr class="separator:afa8097b6371c49d7394118ee2d6cc697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0741faf6729cbd1358a155a50e11899f"><td class="memTemplParams" colspan="2">template&lt;class EndpointSequence , BOOST_ASIO_COMPLETION_TOKEN_FOR(void(error_code, typename Protocol::endpoint)) RangeConnectHandler = net::default_completion_token_t&lt;executor_type&gt;, class  = typename std::enable_if&lt;            net::is_endpoint_sequence&lt;                EndpointSequence&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a0741faf6729cbd1358a155a50e11899f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#a0741faf6729cbd1358a155a50e11899f">BOOST_ASIO_INITFN_RESULT_TYPE</a> (RangeConnectHandler, void(<a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a>, typename Protocol::endpoint)) <a class="el" href="classboost_1_1beast_1_1basic__stream.html#afa8097b6371c49d7394118ee2d6cc697">async_connect</a>(EndpointSequence const &amp;endpoints</td></tr>
<tr class="separator:a0741faf6729cbd1358a155a50e11899f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd66a7b49a480e297f0f7ad8a427cec0"><td class="memTemplParams" colspan="2">template&lt;class EndpointSequence , class ConnectCondition , BOOST_ASIO_COMPLETION_TOKEN_FOR(void(error_code, typename Protocol::endpoint)) RangeConnectHandler = net::default_completion_token_t&lt;executor_type&gt;, class  = typename std::enable_if&lt;            net::is_endpoint_sequence&lt;                EndpointSequence&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:afd66a7b49a480e297f0f7ad8a427cec0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#afd66a7b49a480e297f0f7ad8a427cec0">BOOST_ASIO_INITFN_RESULT_TYPE</a> (RangeConnectHandler, void(<a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a>, typename Protocol::endpoint)) <a class="el" href="classboost_1_1beast_1_1basic__stream.html#afa8097b6371c49d7394118ee2d6cc697">async_connect</a>(EndpointSequence const &amp;endpoints</td></tr>
<tr class="separator:afd66a7b49a480e297f0f7ad8a427cec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cdb467c632b047431c7bb5b12d6b021"><td class="memTemplParams" colspan="2">template&lt;class Iterator , BOOST_ASIO_COMPLETION_TOKEN_FOR(void(error_code, Iterator)) IteratorConnectHandler = net::default_completion_token_t&lt;executor_type&gt;&gt; </td></tr>
<tr class="memitem:a1cdb467c632b047431c7bb5b12d6b021"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#a1cdb467c632b047431c7bb5b12d6b021">BOOST_ASIO_INITFN_RESULT_TYPE</a> (IteratorConnectHandler, void(<a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a>, Iterator)) <a class="el" href="classboost_1_1beast_1_1basic__stream.html#afa8097b6371c49d7394118ee2d6cc697">async_connect</a>(Iterator begin</td></tr>
<tr class="separator:a1cdb467c632b047431c7bb5b12d6b021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672d2833f70c2b8bb13fa78048a03268"><td class="memTemplParams" colspan="2">template&lt;class Iterator , class ConnectCondition , BOOST_ASIO_COMPLETION_TOKEN_FOR(void(error_code, Iterator)) IteratorConnectHandler = net::default_completion_token_t&lt;executor_type&gt;&gt; </td></tr>
<tr class="memitem:a672d2833f70c2b8bb13fa78048a03268"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#a672d2833f70c2b8bb13fa78048a03268">BOOST_ASIO_INITFN_RESULT_TYPE</a> (IteratorConnectHandler, void(<a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a>, Iterator)) <a class="el" href="classboost_1_1beast_1_1basic__stream.html#afa8097b6371c49d7394118ee2d6cc697">async_connect</a>(Iterator begin</td></tr>
<tr class="separator:a672d2833f70c2b8bb13fa78048a03268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac807d7b85c0e7df88a193935ce785901"><td class="memTemplParams" colspan="2">template&lt;class MutableBufferSequence &gt; </td></tr>
<tr class="memitem:ac807d7b85c0e7df88a193935ce785901"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#ac807d7b85c0e7df88a193935ce785901">read_some</a> (MutableBufferSequence const &amp;buffers)</td></tr>
<tr class="separator:ac807d7b85c0e7df88a193935ce785901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6b24c1917384bfd12b7d3726a3a7ec"><td class="memTemplParams" colspan="2">template&lt;class MutableBufferSequence &gt; </td></tr>
<tr class="memitem:aed6b24c1917384bfd12b7d3726a3a7ec"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#aed6b24c1917384bfd12b7d3726a3a7ec">read_some</a> (MutableBufferSequence const &amp;buffers, <a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;ec)</td></tr>
<tr class="separator:aed6b24c1917384bfd12b7d3726a3a7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f9d3ae2925de7e14f77fc0e186bb42"><td class="memTemplParams" colspan="2">template&lt;class MutableBufferSequence , BOOST_BEAST_ASYNC_TPARAM2 ReadHandler = net::default_completion_token_t&lt;executor_type&gt;&gt; </td></tr>
<tr class="memitem:a90f9d3ae2925de7e14f77fc0e186bb42"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#a90f9d3ae2925de7e14f77fc0e186bb42">async_read_some</a> (MutableBufferSequence const &amp;buffers, ReadHandler &amp;&amp;handler=net::default_completion_token_t&lt; <a class="el" href="classboost_1_1beast_1_1basic__stream.html#a8123de0d5f298d1cd39cd9c38e8720bc">executor_type</a> &gt;{})</td></tr>
<tr class="separator:a90f9d3ae2925de7e14f77fc0e186bb42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31bf9178f4c85b8204341af9507b3a10"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence &gt; </td></tr>
<tr class="memitem:a31bf9178f4c85b8204341af9507b3a10"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#a31bf9178f4c85b8204341af9507b3a10">write_some</a> (ConstBufferSequence const &amp;buffers)</td></tr>
<tr class="separator:a31bf9178f4c85b8204341af9507b3a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65eebd2ee90f118ee592c8f742631ec3"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence &gt; </td></tr>
<tr class="memitem:a65eebd2ee90f118ee592c8f742631ec3"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#a65eebd2ee90f118ee592c8f742631ec3">write_some</a> (ConstBufferSequence const &amp;buffers, <a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;ec)</td></tr>
<tr class="separator:a65eebd2ee90f118ee592c8f742631ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d52db851f0644e75ac6bc665da42ea"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence , BOOST_BEAST_ASYNC_TPARAM2 WriteHandler = net::default_completion_token_t&lt;Executor&gt;&gt; </td></tr>
<tr class="memitem:af1d52db851f0644e75ac6bc665da42ea"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#af1d52db851f0644e75ac6bc665da42ea">async_write_some</a> (ConstBufferSequence const &amp;buffers, WriteHandler &amp;&amp;handler=net::default_completion_token_t&lt; Executor &gt;{})</td></tr>
<tr class="separator:af1d52db851f0644e75ac6bc665da42ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
公開変数類</h2></td></tr>
<tr class="memitem:a3144b25287ce039361de1675270ff77a"><td class="memItemLeft" align="right" valign="top">RangeConnectHandler &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><b>handler</b></td></tr>
<tr class="separator:a3144b25287ce039361de1675270ff77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a341d47cfacafaeb9b044a0e876541c"><td class="memItemLeft" align="right" valign="top"><a id="a2a341d47cfacafaeb9b044a0e876541c"></a>
ConnectCondition&#160;</td><td class="memItemRight" valign="bottom"><b>connect_condition</b></td></tr>
<tr class="separator:a2a341d47cfacafaeb9b044a0e876541c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca72bc76b5678c1ab6367cc09ba0f54"><td class="memItemLeft" align="right" valign="top">ConnectCondition RangeConnectHandler &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><b>handler</b></td></tr>
<tr class="separator:a8ca72bc76b5678c1ab6367cc09ba0f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac68109ea5c40f30dac5a9a80ed1773a"><td class="memItemLeft" align="right" valign="top"><a id="aac68109ea5c40f30dac5a9a80ed1773a"></a>
Iterator&#160;</td><td class="memItemRight" valign="bottom"><b>end</b></td></tr>
<tr class="separator:aac68109ea5c40f30dac5a9a80ed1773a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a091b5d9a15e4b38a400dcc062e06ac45"><td class="memItemLeft" align="right" valign="top">Iterator IteratorConnectHandler &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><b>handler</b></td></tr>
<tr class="separator:a091b5d9a15e4b38a400dcc062e06ac45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0b164d33bdd73759bb4c82bce65ef2"><td class="memItemLeft" align="right" valign="top"><a id="a8d0b164d33bdd73759bb4c82bce65ef2"></a>
Iterator ConnectCondition&#160;</td><td class="memItemRight" valign="bottom"><b>connect_condition</b></td></tr>
<tr class="separator:a8d0b164d33bdd73759bb4c82bce65ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0de762f9bcc052a1c49805bd3ca2a4a"><td class="memItemLeft" align="right" valign="top">Iterator ConnectCondition IteratorConnectHandler &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><b>handler</b></td></tr>
<tr class="separator:ad0de762f9bcc052a1c49805bd3ca2a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
フレンド</h2></td></tr>
<tr class="memitem:a655dd84d0176864ff71bcdee41e23b7c"><td class="memTemplParams" colspan="2"><a id="a655dd84d0176864ff71bcdee41e23b7c"></a>
template&lt;class &gt; </td></tr>
<tr class="memitem:a655dd84d0176864ff71bcdee41e23b7c"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>boost::asio::ssl::stream</b></td></tr>
<tr class="separator:a655dd84d0176864ff71bcdee41e23b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">詳解</h2>
<div class="textblock"><h3>template&lt;class Protocol, class Executor = net::any_io_executor, class RatePolicy = unlimited_rate_policy&gt;<br />
class boost::beast::basic_stream&lt; Protocol, Executor, RatePolicy &gt;</h3>

<p>A stream socket wrapper with timeouts, an executor, and a rate limit policy.</p>
<p>This stream wraps a <code>net::basic_stream_socket</code> to provide the following features:</p>
<ul>
<li>An <em>Executor</em> may be associated with the stream, which will be used to invoke any completion handlers which do not already have an associated executor. This achieves support for <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1322r0.html">[P1322R0] Networking TS enhancement to enable custom I/O executors</a>.</li>
</ul>
<ul>
<li>Timeouts may be specified for each logical asynchronous operation performing any reading, writing, or connecting.</li>
</ul>
<ul>
<li>A <em>RatePolicy</em> may be associated with the stream, to implement rate limiting through the policy's interface.</li>
</ul>
<p>Although the stream supports multiple concurrent outstanding asynchronous operations, the stream object is not thread-safe. The caller is responsible for ensuring that the stream is accessed from only one thread at a time. This includes the times when the stream, and its underlying socket, are accessed by the networking implementation. To meet this thread safety requirement, all asynchronous operations must be performed by the stream within the same implicit strand (only one thread <code><a class="el" href="classboost_1_1asio_1_1io__context.html#a50121dac53a47ef8c803ea2f435958c2" title="Run the io_context object&#39;s event processing loop.">net::io_context::run</a></code>) or within the same explicit strand, such as an instance of <code>net::strand</code>.</p>
<p>Completion handlers with explicit associated executors (such as those arising from use of <code>net::bind_executor</code>) will be invoked by the stream using the associated executor. Otherwise, the completion handler will be invoked by the executor associated with the stream upon construction. The type of executor used with this stream must meet the following requirements:</p>
<ul>
<li>Function objects submitted to the executor shall never run concurrently with each other.</li>
</ul>
<p>The executor type <code>net::strand</code> meets these requirements. Use of a strand as the executor in the stream class template offers an additional notational convenience: the strand does not need to be specified in each individual initiating function call.</p>
<p>Unlike other stream wrappers, the underlying socket is accessed through the <a class="el" href="classboost_1_1beast_1_1basic__stream.html#ae4867e1dc163e3a46d32a5b066dc1973">socket</a> member function instead of <code>next_layer</code>. This causes the <a class="el" href="classboost_1_1beast_1_1basic__stream.html">basic_stream</a> to be returned in calls to get_lowest_layer.</p>
<dl class="section user"><dt>Usage</dt><dd></dd></dl>
<p>To use this stream declare an instance of the class. Then, before each logical operation for which a timeout is desired, call <a class="el" href="classboost_1_1beast_1_1basic__stream.html#aaf9aaa1478d079e7729121fbcdc32b52">expires_after</a> with a duration, or call <a class="el" href="classboost_1_1beast_1_1basic__stream.html#a277a177873e5fed1ba606c03387f9a57">expires_at</a> with a time point. Alternatively, call <a class="el" href="classboost_1_1beast_1_1basic__stream.html#a123246bad8b50ad143da9895e90a869e">expires_never</a> to disable the timeout for subsequent logical operations. A logical operation is any series of one or more direct or indirect calls to the timeout stream's asynchronous read, asynchronous write, or asynchronous connect functions.</p>
<p>When a timeout is set and a mixed operation is performed (one that includes both reads and writes, for example) the timeout applies to all of the intermediate asynchronous operations used in the enclosing operation. This allows timeouts to be applied to stream algorithms which were not written specifically to allow for timeouts, when those algorithms are passed a timeout stream with a timeout set.</p>
<p>When a timeout occurs the socket will be closed, canceling any pending I/O operations. The completion handlers for these canceled operations will be invoked with the error beast::error::timeout.</p>
<dl class="section user"><dt>Examples</dt><dd></dd></dl>
<p>This function reads an HTTP request with a timeout, then sends the HTTP response with a different timeout.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> process_http_1 (tcp_stream&amp; stream, net::yield_context yield)</div>
<div class="line">{</div>
<div class="line">    flat_buffer buffer;</div>
<div class="line">    http::request&lt;http::empty_body&gt; req;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Read the request, with a 15 second timeout</span></div>
<div class="line">    stream.expires_after(std::chrono::seconds(15));</div>
<div class="line">    http::async_read(stream, buffer, req, yield);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Calculate the response</span></div>
<div class="line">    http::response&lt;http::string_body&gt; res = make_response(req);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Send the response, with a 30 second timeout.</span></div>
<div class="line">    stream.expires_after (std::chrono::seconds(30));</div>
<div class="line">    http::async_write (stream, res, yield);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The example above could be expressed using a single timeout with a simple modification. The function that follows first reads an HTTP request then sends the HTTP response, with a single timeout that applies to the entire combined operation of reading and writing:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> process_http_2 (tcp_stream&amp; stream, net::yield_context yield)</div>
<div class="line">{</div>
<div class="line">    flat_buffer buffer;</div>
<div class="line">    http::request&lt;http::empty_body&gt; req;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Require that the read and write combined take no longer than 30 seconds</span></div>
<div class="line">    stream.expires_after(std::chrono::seconds(30));</div>
<div class="line"> </div>
<div class="line">    http::async_read(stream, buffer, req, yield);</div>
<div class="line"> </div>
<div class="line">    http::response&lt;http::string_body&gt; res = make_response(req);</div>
<div class="line">    http::async_write (stream, res, yield);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Some stream algorithms, such as <code>ssl::stream::async_handshake</code> perform both reads and writes. A timeout set before calling the initiating function of such composite stream algorithms will apply to the entire composite operation. For example, a timeout may be set on performing the SSL handshake thusly:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> do_ssl_handshake (net::ssl::stream&lt;tcp_stream&gt;&amp; stream, net::yield_context yield)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Require that the SSL handshake take no longer than 10 seconds</span></div>
<div class="line">    stream.expires_after(std::chrono::seconds(10));</div>
<div class="line"> </div>
<div class="line">    stream.async_handshake(net::ssl::stream_base::client, yield);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section user"><dt>Blocking I/O</dt><dd></dd></dl>
<p>Synchronous functions behave identically as that of the wrapped <code>net::basic_stream_socket</code>. Timeouts are not available when performing blocking calls.</p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Protocol</td><td>A type meeting the requirements of <em>Protocol</em> representing the protocol the protocol to use for the basic stream socket. A common choice is <code>net::ip::tcp</code>.</td></tr>
    <tr><td class="paramname">Executor</td><td>A type meeting the requirements of <em>Executor</em> to be used for submitting all completion handlers which do not already have an associated executor. If this type is omitted, the default of <code>net::any_io_executor</code> will be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Thread Safety</dt><dd><em>Distinct objects</em>: Safe.<br  />
<em>Shared objects</em>: Unsafe. The application must also ensure that all asynchronous operations are performed within the same implicit or explicit strand.</dd></dl>
<dl class="section see"><dt>参照</dt><dd></dd></dl>
<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1322r0.html">[P1322R0] Networking TS enhancement to enable custom I/O executors</a>. </li>
</ul>
</div><h2 class="groupheader">型定義メンバ詳解</h2>
<a id="a8123de0d5f298d1cd39cd9c38e8720bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8123de0d5f298d1cd39cd9c38e8720bc">&#9670;&nbsp;</a></span>executor_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Protocol , class Executor  = net::any_io_executor, class RatePolicy  = unlimited_rate_policy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classboost_1_1beast_1_1basic__stream.html">boost::beast::basic_stream</a>&lt; Protocol, Executor, RatePolicy &gt;::<a class="el" href="classboost_1_1beast_1_1basic__stream.html#a8123de0d5f298d1cd39cd9c38e8720bc">executor_type</a> =  beast::executor_type&lt;<a class="el" href="classboost_1_1beast_1_1basic__stream.html#ae6d0d00dfc12e1caa34d216380c1c43e">socket_type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of the executor associated with the stream.</p>
<p>This will be the type of executor used to invoke completion handlers which do not have an explicit associated executor. </p>

</div>
</div>
<h2 class="groupheader">構築子と解体子</h2>
<a id="af0eb5f82a3347e83746f754d72b77743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0eb5f82a3347e83746f754d72b77743">&#9670;&nbsp;</a></span>~basic_stream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Protocol , class Executor , class RatePolicy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1basic__stream.html">boost::beast::basic_stream</a>&lt; Protocol, Executor, RatePolicy &gt;::~<a class="el" href="classboost_1_1beast_1_1basic__stream.html">basic_stream</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor</p>
<p>This function destroys the stream, cancelling any outstanding asynchronous operations associated with the socket as if by calling cancel. </p>

</div>
</div>
<a id="aac3218f690f613d430f8776e7c63bb57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac3218f690f613d430f8776e7c63bb57">&#9670;&nbsp;</a></span>basic_stream() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Protocol , class Executor , class RatePolicy &gt; </div>
<div class="memtemplate">
template&lt;class Arg0 , class... Args, class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1basic__stream.html">boost::beast::basic_stream</a>&lt; Protocol, Executor, RatePolicy &gt;::<a class="el" href="classboost_1_1beast_1_1basic__stream.html">basic_stream</a> </td>
          <td>(</td>
          <td class="paramtype">Arg0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>argo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor</p>
<p>This constructor creates the stream by forwarding all arguments to the underlying socket. The socket then needs to be open and connected or accepted before data can be sent or received on it.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>A list of parameters forwarded to the constructor of the underlying socket. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51233e8e2240575d2e2458ca50107c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51233e8e2240575d2e2458ca50107c48">&#9670;&nbsp;</a></span>basic_stream() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Protocol , class Executor , class RatePolicy &gt; </div>
<div class="memtemplate">
template&lt;class RatePolicy_ , class Arg0 , class... Args, class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1basic__stream.html">boost::beast::basic_stream</a>&lt; Protocol, Executor, RatePolicy &gt;::<a class="el" href="classboost_1_1beast_1_1basic__stream.html">basic_stream</a> </td>
          <td>(</td>
          <td class="paramtype">RatePolicy_ &amp;&amp;&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor</p>
<p>This constructor creates the stream with the specified rate policy, and forwards all remaining arguments to the underlying socket. The socket then needs to be open and connected or accepted before data can be sent or received on it.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>The rate policy object to use. The stream will take ownership of this object by decay-copy.</td></tr>
    <tr><td class="paramname">args</td><td>A list of parameters forwarded to the constructor of the underlying socket. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79e32b7ae4ef8693b154837655860244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79e32b7ae4ef8693b154837655860244">&#9670;&nbsp;</a></span>basic_stream() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Protocol , class Executor , class RatePolicy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1basic__stream.html">boost::beast::basic_stream</a>&lt; Protocol, Executor, RatePolicy &gt;::<a class="el" href="classboost_1_1beast_1_1basic__stream.html">basic_stream</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1basic__stream.html">basic_stream</a>&lt; Protocol, Executor, RatePolicy &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move constructor</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other object from which the move will occur.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>Following the move, the moved-from object is in the same state as if newly constructed. </dd></dl>

</div>
</div>
<h2 class="groupheader">関数詳解</h2>
<a id="afa8097b6371c49d7394118ee2d6cc697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa8097b6371c49d7394118ee2d6cc697">&#9670;&nbsp;</a></span>async_connect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Protocol , class Executor , class RatePolicy &gt; </div>
<div class="memtemplate">
template&lt;BOOST_BEAST_ASYNC_TPARAM1 ConnectHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1basic__stream.html">boost::beast::basic_stream</a>&lt; Protocol, Executor, RatePolicy &gt;::async_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#acf8b4b53a1a8c757057185e88d55502f">endpoint_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em> = <code>net::default_completion_token_t&lt;&#160;<a class="el" href="classboost_1_1beast_1_1basic__stream.html#a8123de0d5f298d1cd39cd9c38e8720bc">executor_type</a>&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connect the stream to the specified endpoint asynchronously.</p>
<p>This function is used to asynchronously connect the underlying socket to the specified remote endpoint. The function call always returns immediately. The underlying socket is automatically opened if needed. An automatically opened socket is not returned to the closed state upon failure.</p>
<p>If the timeout timer expires while the operation is outstanding, the operation will be canceled and the completion handler will be invoked with the error error::timeout.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep</td><td>The remote endpoint to which the underlying socket will be connected. Copies will be made of the endpoint object as required.</td></tr>
    <tr><td class="paramname">handler</td><td>The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(</div>
<div class="line">    error_code ec         <span class="comment">// Result of operation</span></div>
<div class="line">);</div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>net::post</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="classboost_1_1beast_1_1basic__stream.html#afa8097b6371c49d7394118ee2d6cc697">async_connect</a> </dd></dl>

</div>
</div>
<a id="a90f9d3ae2925de7e14f77fc0e186bb42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f9d3ae2925de7e14f77fc0e186bb42">&#9670;&nbsp;</a></span>async_read_some()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Protocol , class Executor , class RatePolicy &gt; </div>
<div class="memtemplate">
template&lt;class MutableBufferSequence , BOOST_BEAST_ASYNC_TPARAM2 ReadHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1basic__stream.html">boost::beast::basic_stream</a>&lt; Protocol, Executor, RatePolicy &gt;::async_read_some </td>
          <td>(</td>
          <td class="paramtype">MutableBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em> = <code>net::default_completion_token_t&lt;<a class="el" href="classboost_1_1beast_1_1basic__stream.html#a8123de0d5f298d1cd39cd9c38e8720bc">executor_type</a>&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read some data asynchronously.</p>
<p>This function is used to asynchronously read data from the stream.</p>
<p>This call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>One or more bytes are read from the stream.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed asynchronous operation</em>, is implemented in terms of calls to the next layer's <code>async_read_some</code> function. The program must ensure that no other calls to <a class="el" href="classboost_1_1beast_1_1basic__stream.html#ac807d7b85c0e7df88a193935ce785901">read_some</a> or <a class="el" href="classboost_1_1beast_1_1basic__stream.html#a90f9d3ae2925de7e14f77fc0e186bb42">async_read_some</a> are performed until this operation completes.</p>
<p>If the timeout timer expires while the operation is outstanding, the operation will be canceled and the completion handler will be invoked with the error error::timeout.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The buffers into which the data will be read. If the size of the buffers is zero bytes, the operation always completes immediately with no error. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(</div>
<div class="line">    error_code error,               <span class="comment">// Result of operation.</span></div>
<div class="line">    std::size_t bytes_transferred   <span class="comment">// Number of bytes read.</span></div>
<div class="line">);</div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>net::post</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>The <code>async_read_some</code> operation may not receive all of the requested number of bytes. Consider using the function <code>net::async_read</code> if you need to ensure that the requested amount of data is read before the asynchronous operation completes. </dd></dl>

</div>
</div>
<a id="af1d52db851f0644e75ac6bc665da42ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1d52db851f0644e75ac6bc665da42ea">&#9670;&nbsp;</a></span>async_write_some()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Protocol , class Executor , class RatePolicy &gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence , BOOST_BEAST_ASYNC_TPARAM2 WriteHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1basic__stream.html">boost::beast::basic_stream</a>&lt; Protocol, Executor, RatePolicy &gt;::async_write_some </td>
          <td>(</td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em> = <code>net::default_completion_token_t&lt;Executor&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write some data asynchronously.</p>
<p>This function is used to asynchronously write data to the underlying socket.</p>
<p>This call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>One or more bytes are written to the stream.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>The algorithm, known as a <em>composed asynchronous operation</em>, is implemented in terms of calls to the next layer's <code>async_write_some</code> function. The program must ensure that no other calls to <a class="el" href="classboost_1_1beast_1_1basic__stream.html#af1d52db851f0644e75ac6bc665da42ea">async_write_some</a> are performed until this operation completes.</p>
<p>If the timeout timer expires while the operation is outstanding, the operation will be canceled and the completion handler will be invoked with the error error::timeout.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The buffers from which the data will be written. If the size of the buffers is zero bytes, the operation always completes immediately with no error. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(</div>
<div class="line">    error_code error,               <span class="comment">// Result of operation.</span></div>
<div class="line">    std::size_t bytes_transferred   <span class="comment">// Number of bytes written.</span></div>
<div class="line">);</div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>net::post</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>The <code>async_write_some</code> operation may not transmit all of the requested number of bytes. Consider using the function <code>net::async_write</code> if you need to ensure that the requested amount of data is sent before the asynchronous operation completes. </dd></dl>

</div>
</div>
<a id="a1cdb467c632b047431c7bb5b12d6b021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cdb467c632b047431c7bb5b12d6b021">&#9670;&nbsp;</a></span>BOOST_ASIO_INITFN_RESULT_TYPE() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Protocol , class Executor  = net::any_io_executor, class RatePolicy  = unlimited_rate_policy&gt; </div>
<div class="memtemplate">
template&lt;class Iterator , BOOST_ASIO_COMPLETION_TOKEN_FOR(void(error_code, Iterator)) IteratorConnectHandler = net::default_completion_token_t&lt;executor_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1basic__stream.html">boost::beast::basic_stream</a>&lt; Protocol, Executor, RatePolicy &gt;::BOOST_ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">IteratorConnectHandler&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(<a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a>, Iterator)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Establishes a connection by trying each endpoint in a sequence asynchronously.</p>
<p>This function attempts to connect the stream to one of a sequence of endpoints by trying each endpoint until a connection is successfully established. The underlying socket is automatically opened if needed. An automatically opened socket is not returned to the closed state upon failure.</p>
<p>The algorithm, known as a <em>composed asynchronous operation</em>, is implemented in terms of calls to the underlying socket's <code>async_connect</code> function.</p>
<p>If the timeout timer expires while the operation is outstanding, the current connection attempt will be canceled and the completion handler will be invoked with the error error::timeout.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">end</td><td>An iterator pointing to the end of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">handler</td><td>The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(</div>
<div class="line">    <span class="comment">// Result of operation. if the sequence is empty, set to</span></div>
<div class="line">    <span class="comment">// net::error::not_found. Otherwise, contains the</span></div>
<div class="line">    <span class="comment">// error from the last connection attempt.</span></div>
<div class="line">    error_code <span class="keyword">const</span>&amp; error,</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// On success, an iterator denoting the successfully</span></div>
<div class="line">    <span class="comment">// connected endpoint. Otherwise, the end iterator.</span></div>
<div class="line">    Iterator iterator</div>
<div class="line">);</div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>net::post</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a672d2833f70c2b8bb13fa78048a03268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a672d2833f70c2b8bb13fa78048a03268">&#9670;&nbsp;</a></span>BOOST_ASIO_INITFN_RESULT_TYPE() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Protocol , class Executor  = net::any_io_executor, class RatePolicy  = unlimited_rate_policy&gt; </div>
<div class="memtemplate">
template&lt;class Iterator , class ConnectCondition , BOOST_ASIO_COMPLETION_TOKEN_FOR(void(error_code, Iterator)) IteratorConnectHandler = net::default_completion_token_t&lt;executor_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1basic__stream.html">boost::beast::basic_stream</a>&lt; Protocol, Executor, RatePolicy &gt;::BOOST_ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">IteratorConnectHandler&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(<a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a>, Iterator)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Establishes a connection by trying each endpoint in a sequence asynchronously.</p>
<p>This function attempts to connect the stream to one of a sequence of endpoints by trying each endpoint until a connection is successfully established. The algorithm, known as a <em>composed asynchronous operation</em>, is implemented in terms of calls to the underlying socket's <code>async_connect</code> function.</p>
<p>If the timeout timer expires while the operation is outstanding, the current connection attempt will be canceled and the completion handler will be invoked with the error error::timeout.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">end</td><td>An iterator pointing to the end of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> connect_condition(</div>
<div class="line">    error_code <span class="keyword">const</span>&amp; ec,</div>
<div class="line">    <span class="keyword">typename</span> Protocol::endpoint <span class="keyword">const</span>&amp; next);</div>
</div><!-- fragment --></td></tr>
    <tr><td class="paramname">handler</td><td>The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(</div>
<div class="line">    <span class="comment">// Result of operation. if the sequence is empty, set to</span></div>
<div class="line">    <span class="comment">// net::error::not_found. Otherwise, contains the</span></div>
<div class="line">    <span class="comment">// error from the last connection attempt.</span></div>
<div class="line">    error_code <span class="keyword">const</span>&amp; error,</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// On success, an iterator denoting the successfully</span></div>
<div class="line">    <span class="comment">// connected endpoint. Otherwise, the end iterator.</span></div>
<div class="line">    Iterator iterator</div>
<div class="line">);</div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>net::post</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0741faf6729cbd1358a155a50e11899f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0741faf6729cbd1358a155a50e11899f">&#9670;&nbsp;</a></span>BOOST_ASIO_INITFN_RESULT_TYPE() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Protocol , class Executor  = net::any_io_executor, class RatePolicy  = unlimited_rate_policy&gt; </div>
<div class="memtemplate">
template&lt;class EndpointSequence , BOOST_ASIO_COMPLETION_TOKEN_FOR(void(error_code, typename Protocol::endpoint)) RangeConnectHandler = net::default_completion_token_t&lt;executor_type&gt;, class  = typename std::enable_if&lt;            net::is_endpoint_sequence&lt;                EndpointSequence&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1basic__stream.html">boost::beast::basic_stream</a>&lt; Protocol, Executor, RatePolicy &gt;::BOOST_ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">RangeConnectHandler&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(<a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a>, typename Protocol::endpoint)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Establishes a connection by trying each endpoint in a sequence asynchronously.</p>
<p>This function attempts to connect the stream to one of a sequence of endpoints by trying each endpoint until a connection is successfully established. The underlying socket is automatically opened if needed. An automatically opened socket is not returned to the closed state upon failure.</p>
<p>The algorithm, known as a <em>composed asynchronous operation</em>, is implemented in terms of calls to the underlying socket's <code>async_connect</code> function.</p>
<p>If the timeout timer expires while the operation is outstanding, the current connection attempt will be canceled and the completion handler will be invoked with the error error::timeout.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoints</td><td>A sequence of endpoints. This this object must meet the requirements of <em>EndpointSequence</em>.</td></tr>
    <tr><td class="paramname">handler</td><td>The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(</div>
<div class="line">    <span class="comment">// Result of operation. if the sequence is empty, set to</span></div>
<div class="line">    <span class="comment">// net::error::not_found. Otherwise, contains the</span></div>
<div class="line">    <span class="comment">// error from the last connection attempt.</span></div>
<div class="line">    error_code <span class="keyword">const</span>&amp; error,</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// On success, the successfully connected endpoint.</span></div>
<div class="line">    <span class="comment">// Otherwise, a default-constructed endpoint.</span></div>
<div class="line">    <span class="keyword">typename</span> Protocol::endpoint <span class="keyword">const</span>&amp; endpoint</div>
<div class="line">);</div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>net::post</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd66a7b49a480e297f0f7ad8a427cec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd66a7b49a480e297f0f7ad8a427cec0">&#9670;&nbsp;</a></span>BOOST_ASIO_INITFN_RESULT_TYPE() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Protocol , class Executor  = net::any_io_executor, class RatePolicy  = unlimited_rate_policy&gt; </div>
<div class="memtemplate">
template&lt;class EndpointSequence , class ConnectCondition , BOOST_ASIO_COMPLETION_TOKEN_FOR(void(error_code, typename Protocol::endpoint)) RangeConnectHandler = net::default_completion_token_t&lt;executor_type&gt;, class  = typename std::enable_if&lt;            net::is_endpoint_sequence&lt;                EndpointSequence&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1basic__stream.html">boost::beast::basic_stream</a>&lt; Protocol, Executor, RatePolicy &gt;::BOOST_ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">RangeConnectHandler&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(<a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a>, typename Protocol::endpoint)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Establishes a connection by trying each endpoint in a sequence asynchronously.</p>
<p>This function attempts to connect the stream to one of a sequence of endpoints by trying each endpoint until a connection is successfully established. The underlying socket is automatically opened if needed. An automatically opened socket is not returned to the closed state upon failure.</p>
<p>The algorithm, known as a <em>composed asynchronous operation</em>, is implemented in terms of calls to the underlying socket's <code>async_connect</code> function.</p>
<p>If the timeout timer expires while the operation is outstanding, the current connection attempt will be canceled and the completion handler will be invoked with the error error::timeout.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoints</td><td>A sequence of endpoints. This this object must meet the requirements of <em>EndpointSequence</em>.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> connect_condition(</div>
<div class="line">    error_code <span class="keyword">const</span>&amp; ec,</div>
<div class="line">    <span class="keyword">typename</span> Protocol::endpoint <span class="keyword">const</span>&amp; next);</div>
</div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
    <tr><td class="paramname">handler</td><td>The completion handler to invoke when the operation completes. The implementation takes ownership of the handler by performing a decay-copy. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(</div>
<div class="line">    <span class="comment">// Result of operation. if the sequence is empty, set to</span></div>
<div class="line">    <span class="comment">// net::error::not_found. Otherwise, contains the</span></div>
<div class="line">    <span class="comment">// error from the last connection attempt.</span></div>
<div class="line">    error_code <span class="keyword">const</span>&amp; error,</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// On success, the successfully connected endpoint.</span></div>
<div class="line">    <span class="comment">// Otherwise, a default-constructed endpoint.</span></div>
<div class="line">    <span class="keyword">typename</span> Protocol::endpoint <span class="keyword">const</span>&amp; endpoint</div>
<div class="line">);</div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>net::post</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>The following connect condition function object can be used to output information about the individual connection attempts: <div class="fragment"><div class="line"><span class="keyword">struct </span>my_connect_condition</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">bool</span> operator()(</div>
<div class="line">        error_code <span class="keyword">const</span>&amp; ec,</div>
<div class="line">        net::ip::tcp::endpoint <span class="keyword">const</span>&amp; next)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (ec)</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ec.message() &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Trying: &quot;</span> &lt;&lt; next &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a88493d0b533c4d055d9f91793c0aa3c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88493d0b533c4d055d9f91793c0aa3c6">&#9670;&nbsp;</a></span>cancel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Protocol , class Executor , class RatePolicy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1basic__stream.html">boost::beast::basic_stream</a>&lt; Protocol, Executor, RatePolicy &gt;::cancel</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cancel all asynchronous operations associated with the socket.</p>
<p>This function causes all outstanding asynchronous connect, read, and write operations to finish immediately. Completion handlers for cancelled operations will receive the error <code>net::error::operation_aborted</code>. Completion handlers not yet invoked whose operations have completed, will receive the error corresponding to the result of the operation (which may indicate success). </p>

</div>
</div>
<a id="a8cfbc568c55fdef3c5cd60b2071d221a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cfbc568c55fdef3c5cd60b2071d221a">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Protocol , class Executor , class RatePolicy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1basic__stream.html">boost::beast::basic_stream</a>&lt; Protocol, Executor, RatePolicy &gt;::close</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close the timed stream.</p>
<p>This cancels all of the outstanding asynchronous operations as if by calling <a class="el" href="classboost_1_1beast_1_1basic__stream.html#a88493d0b533c4d055d9f91793c0aa3c6">cancel</a>, and closes the underlying socket. </p>

</div>
</div>
<a id="aba6155abe5ec0abcbc7aa8a82510915e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba6155abe5ec0abcbc7aa8a82510915e">&#9670;&nbsp;</a></span>connect() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Protocol , class Executor  = net::any_io_executor, class RatePolicy  = unlimited_rate_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1basic__stream.html">boost::beast::basic_stream</a>&lt; Protocol, Executor, RatePolicy &gt;::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#acf8b4b53a1a8c757057185e88d55502f">endpoint_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>ep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Connect the stream to the specified endpoint.</p>
<p>This function is used to connect the underlying socket to the specified remote endpoint. The function call will block until the connection is successfully made or an error occurs. The underlying socket is automatically opened if needed. An automatically opened socket is not returned to the closed state upon failure.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep</td><td>The remote endpoint to connect to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="classboost_1_1beast_1_1basic__stream.html#aba6155abe5ec0abcbc7aa8a82510915e">connect</a> </dd></dl>

</div>
</div>
<a id="ac01f120038810dac9cae9ac2b49a0454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac01f120038810dac9cae9ac2b49a0454">&#9670;&nbsp;</a></span>connect() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Protocol , class Executor  = net::any_io_executor, class RatePolicy  = unlimited_rate_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1basic__stream.html">boost::beast::basic_stream</a>&lt; Protocol, Executor, RatePolicy &gt;::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#acf8b4b53a1a8c757057185e88d55502f">endpoint_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Connect the stream to the specified endpoint.</p>
<p>This function is used to connect the underlying socket to the specified remote endpoint. The function call will block until the connection is successfully made or an error occurs. The underlying socket is automatically opened if needed. An automatically opened socket is not returned to the closed state upon failure.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep</td><td>The remote endpoint to connect to.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="classboost_1_1beast_1_1basic__stream.html#aba6155abe5ec0abcbc7aa8a82510915e">connect</a> </dd></dl>

</div>
</div>
<a id="a42259670d8f33fa6287adaed8a0fa932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42259670d8f33fa6287adaed8a0fa932">&#9670;&nbsp;</a></span>connect() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Protocol , class Executor  = net::any_io_executor, class RatePolicy  = unlimited_rate_policy&gt; </div>
<div class="memtemplate">
template&lt;class EndpointSequence , class  = typename std::enable_if&lt;            net::is_endpoint_sequence&lt;                EndpointSequence&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Protocol::endpoint <a class="el" href="classboost_1_1beast_1_1basic__stream.html">boost::beast::basic_stream</a>&lt; Protocol, Executor, RatePolicy &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">EndpointSequence const &amp;&#160;</td>
          <td class="paramname"><em>endpoints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Establishes a connection by trying each endpoint in a sequence.</p>
<p>This function attempts to connect the stream to one of a sequence of endpoints by trying each endpoint until a connection is successfully established. The underlying socket is automatically opened if needed. An automatically opened socket is not returned to the closed state upon failure.</p>
<p>The algorithm, known as a <em>composed operation</em>, is implemented in terms of calls to the underlying socket's <code>connect</code> function.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoints</td><td>A sequence of endpoints.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The successfully connected endpoint.</dd></dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure. If the sequence is empty, the associated error code is <code>net::error::not_found</code>. Otherwise, contains the error from the last connection attempt. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ad51494c0febc4c9c66b88b2653f114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad51494c0febc4c9c66b88b2653f114">&#9670;&nbsp;</a></span>connect() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Protocol , class Executor  = net::any_io_executor, class RatePolicy  = unlimited_rate_policy&gt; </div>
<div class="memtemplate">
template&lt;class EndpointSequence , class ConnectCondition , class  = typename std::enable_if&lt;            net::is_endpoint_sequence&lt;                EndpointSequence&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Protocol::endpoint <a class="el" href="classboost_1_1beast_1_1basic__stream.html">boost::beast::basic_stream</a>&lt; Protocol, Executor, RatePolicy &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">EndpointSequence const &amp;&#160;</td>
          <td class="paramname"><em>endpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectCondition&#160;</td>
          <td class="paramname"><em>connect_condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Establishes a connection by trying each endpoint in a sequence.</p>
<p>This function attempts to connect the stream to one of a sequence of endpoints by trying each endpoint until a connection is successfully established. The underlying socket is automatically opened if needed. An automatically opened socket is not returned to the closed state upon failure.</p>
<p>The algorithm, known as a <em>composed operation</em>, is implemented in terms of calls to the underlying socket's <code>connect</code> function.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoints</td><td>A sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> connect_condition(</div>
<div class="line">    error_code <span class="keyword">const</span>&amp; ec,</div>
<div class="line">    <span class="keyword">typename</span> Protocol::endpoint <span class="keyword">const</span>&amp; next);</div>
</div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The successfully connected endpoint.</dd></dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classboost_1_1system_1_1system__error.html">boost::system::system_error</a></td><td>Thrown on failure. If the sequence is empty, the associated error code is <code>net::error::not_found</code>. Otherwise, contains the error from the last connection attempt. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6a38f0f54bb51107d7b2ea034f1902d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6a38f0f54bb51107d7b2ea034f1902d">&#9670;&nbsp;</a></span>connect() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Protocol , class Executor  = net::any_io_executor, class RatePolicy  = unlimited_rate_policy&gt; </div>
<div class="memtemplate">
template&lt;class EndpointSequence , class ConnectCondition , class  = typename std::enable_if&lt;            net::is_endpoint_sequence&lt;                EndpointSequence&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Protocol::endpoint <a class="el" href="classboost_1_1beast_1_1basic__stream.html">boost::beast::basic_stream</a>&lt; Protocol, Executor, RatePolicy &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">EndpointSequence const &amp;&#160;</td>
          <td class="paramname"><em>endpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectCondition&#160;</td>
          <td class="paramname"><em>connect_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Establishes a connection by trying each endpoint in a sequence.</p>
<p>This function attempts to connect the stream to one of a sequence of endpoints by trying each endpoint until a connection is successfully established. The underlying socket is automatically opened if needed. An automatically opened socket is not returned to the closed state upon failure.</p>
<p>The algorithm, known as a <em>composed operation</em>, is implemented in terms of calls to the underlying socket's <code>connect</code> function.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoints</td><td>A sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> connect_condition(</div>
<div class="line">    error_code <span class="keyword">const</span>&amp; ec,</div>
<div class="line">    <span class="keyword">typename</span> Protocol::endpoint <span class="keyword">const</span>&amp; next);</div>
</div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. If the sequence is empty, set to <code>net::error::not_found</code>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>On success, the successfully connected endpoint. Otherwise, a default-constructed endpoint. </dd></dl>

</div>
</div>
<a id="af3fee8d5692e2aedd0d0fa29a41ebac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3fee8d5692e2aedd0d0fa29a41ebac6">&#9670;&nbsp;</a></span>connect() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Protocol , class Executor  = net::any_io_executor, class RatePolicy  = unlimited_rate_policy&gt; </div>
<div class="memtemplate">
template&lt;class EndpointSequence , class  = typename std::enable_if&lt;            net::is_endpoint_sequence&lt;                EndpointSequence&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Protocol::endpoint <a class="el" href="classboost_1_1beast_1_1basic__stream.html">boost::beast::basic_stream</a>&lt; Protocol, Executor, RatePolicy &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">EndpointSequence const &amp;&#160;</td>
          <td class="paramname"><em>endpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Establishes a connection by trying each endpoint in a sequence.</p>
<p>This function attempts to connect the stream to one of a sequence of endpoints by trying each endpoint until a connection is successfully established. The underlying socket is automatically opened if needed. An automatically opened socket is not returned to the closed state upon failure.</p>
<p>The algorithm, known as a <em>composed operation</em>, is implemented in terms of calls to the underlying socket's <code>connect</code> function.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoints</td><td>A sequence of endpoints.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. If the sequence is empty, set to <code>net::error::not_found</code>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>On success, the successfully connected endpoint. Otherwise, a default-constructed endpoint. </dd></dl>

</div>
</div>
<a id="a93c939e17a39c009e3eaa8c5fbd2fa4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93c939e17a39c009e3eaa8c5fbd2fa4d">&#9670;&nbsp;</a></span>connect() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Protocol , class Executor  = net::any_io_executor, class RatePolicy  = unlimited_rate_policy&gt; </div>
<div class="memtemplate">
template&lt;class Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Iterator <a class="el" href="classboost_1_1beast_1_1basic__stream.html">boost::beast::basic_stream</a>&lt; Protocol, Executor, RatePolicy &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Establishes a connection by trying each endpoint in a sequence.</p>
<p>This function attempts to connect the stream to one of a sequence of endpoints by trying each endpoint until a connection is successfully established. The underlying socket is automatically opened if needed. An automatically opened socket is not returned to the closed state upon failure.</p>
<p>The algorithm, known as a <em>composed operation</em>, is implemented in terms of calls to the underlying socket's <code>connect</code> function.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">end</td><td>An iterator pointing to the end of a sequence of endpoints.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>An iterator denoting the successfully connected endpoint.</dd></dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure. If the sequence is empty, the associated error code is <code>net::error::not_found</code>. Otherwise, contains the error from the last connection attempt. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a579142799c27ab5be6864dfa5c91c3c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a579142799c27ab5be6864dfa5c91c3c5">&#9670;&nbsp;</a></span>connect() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Protocol , class Executor  = net::any_io_executor, class RatePolicy  = unlimited_rate_policy&gt; </div>
<div class="memtemplate">
template&lt;class Iterator , class ConnectCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Iterator <a class="el" href="classboost_1_1beast_1_1basic__stream.html">boost::beast::basic_stream</a>&lt; Protocol, Executor, RatePolicy &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectCondition&#160;</td>
          <td class="paramname"><em>connect_condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Establishes a connection by trying each endpoint in a sequence.</p>
<p>This function attempts to connect the stream to one of a sequence of endpoints by trying each endpoint until a connection is successfully established. The underlying socket is automatically opened if needed. An automatically opened socket is not returned to the closed state upon failure.</p>
<p>The algorithm, known as a <em>composed operation</em>, is implemented in terms of calls to the underlying socket's <code>connect</code> function.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">end</td><td>An iterator pointing to the end of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> connect_condition(</div>
<div class="line">    error_code <span class="keyword">const</span>&amp; ec,</div>
<div class="line">    <span class="keyword">typename</span> Protocol::endpoint <span class="keyword">const</span>&amp; next);</div>
</div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>An iterator denoting the successfully connected endpoint.</dd></dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classboost_1_1system_1_1system__error.html">boost::system::system_error</a></td><td>Thrown on failure. If the sequence is empty, the associated <code>error_code</code> is <code>net::error::not_found</code>. Otherwise, contains the error from the last connection attempt. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7adfe59fefada2b6edeab8870d3ad723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7adfe59fefada2b6edeab8870d3ad723">&#9670;&nbsp;</a></span>connect() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Protocol , class Executor  = net::any_io_executor, class RatePolicy  = unlimited_rate_policy&gt; </div>
<div class="memtemplate">
template&lt;class Iterator , class ConnectCondition &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Iterator <a class="el" href="classboost_1_1beast_1_1basic__stream.html">boost::beast::basic_stream</a>&lt; Protocol, Executor, RatePolicy &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectCondition&#160;</td>
          <td class="paramname"><em>connect_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Establishes a connection by trying each endpoint in a sequence.</p>
<p>This function attempts to connect the stream to one of a sequence of endpoints by trying each endpoint until a connection is successfully established. The underlying socket is automatically opened if needed. An automatically opened socket is not returned to the closed state upon failure.</p>
<p>The algorithm, known as a <em>composed operation</em>, is implemented in terms of calls to the underlying socket's <code>connect</code> function.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">end</td><td>An iterator pointing to the end of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> connect_condition(</div>
<div class="line">    error_code <span class="keyword">const</span>&amp; ec,</div>
<div class="line">    <span class="keyword">typename</span> Protocol::endpoint <span class="keyword">const</span>&amp; next);</div>
</div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. If the sequence is empty, set to <code>net::error::not_found</code>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>On success, an iterator denoting the successfully connected endpoint. Otherwise, the end iterator. </dd></dl>

</div>
</div>
<a id="a9ccbe7bc568008337bd388406dc1056d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ccbe7bc568008337bd388406dc1056d">&#9670;&nbsp;</a></span>connect() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Protocol , class Executor  = net::any_io_executor, class RatePolicy  = unlimited_rate_policy&gt; </div>
<div class="memtemplate">
template&lt;class Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Iterator <a class="el" href="classboost_1_1beast_1_1basic__stream.html">boost::beast::basic_stream</a>&lt; Protocol, Executor, RatePolicy &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Establishes a connection by trying each endpoint in a sequence.</p>
<p>This function attempts to connect the stream to one of a sequence of endpoints by trying each endpoint until a connection is successfully established. The underlying socket is automatically opened if needed. An automatically opened socket is not returned to the closed state upon failure.</p>
<p>The algorithm, known as a <em>composed operation</em>, is implemented in terms of calls to the underlying socket's <code>connect</code> function.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">end</td><td>An iterator pointing to the end of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. If the sequence is empty, set to boost::asio::error::not_found. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>On success, an iterator denoting the successfully connected endpoint. Otherwise, the end iterator. </dd></dl>

</div>
</div>
<a id="aaf9aaa1478d079e7729121fbcdc32b52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf9aaa1478d079e7729121fbcdc32b52">&#9670;&nbsp;</a></span>expires_after()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Protocol , class Executor , class RatePolicy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1basic__stream.html">boost::beast::basic_stream</a>&lt; Protocol, Executor, RatePolicy &gt;::expires_after </td>
          <td>(</td>
          <td class="paramtype">net::steady_timer::duration&#160;</td>
          <td class="paramname"><em>expiry_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the timeout for the next logical operation.</p>
<p>This sets either the read timer, the write timer, or both timers to expire after the specified amount of time has elapsed. If a timer expires when the corresponding asynchronous operation is outstanding, the stream will be closed and any outstanding operations will complete with the error beast::error::timeout. Otherwise, if the timer expires while no operations are outstanding, and the expiraton is not set again, the next operation will time out immediately.</p>
<p>The timer applies collectively to any asynchronous reads or writes initiated after the expiration is set, until the expiration is set again. A call to <a class="el" href="group__async__connect.html">boost::asio::async_connect</a> counts as both a read and a write.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">expiry_time</td><td>The amount of time after which a logical operation should be considered timed out. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a277a177873e5fed1ba606c03387f9a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a277a177873e5fed1ba606c03387f9a57">&#9670;&nbsp;</a></span>expires_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Protocol , class Executor , class RatePolicy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1basic__stream.html">boost::beast::basic_stream</a>&lt; Protocol, Executor, RatePolicy &gt;::expires_at </td>
          <td>(</td>
          <td class="paramtype">net::steady_timer::time_point&#160;</td>
          <td class="paramname"><em>expiry_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the timeout for the next logical operation.</p>
<p>This sets either the read timer, the write timer, or both timers to expire at the specified time point. If a timer expires when the corresponding asynchronous operation is outstanding, the stream will be closed and any outstanding operations will complete with the error beast::error::timeout. Otherwise, if the timer expires while no operations are outstanding, and the expiraton is not set again, the next operation will time out immediately.</p>
<p>The timer applies collectively to any asynchronous reads or writes initiated after the expiration is set, until the expiration is set again. A call to <a class="el" href="group__async__connect.html">boost::asio::async_connect</a> counts as both a read and a write.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">expiry_time</td><td>The time point after which a logical operation should be considered timed out. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3c696889183176ae7fc7a141af4e37d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3c696889183176ae7fc7a141af4e37d">&#9670;&nbsp;</a></span>get_executor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Protocol , class Executor  = net::any_io_executor, class RatePolicy  = unlimited_rate_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1basic__stream.html#a8123de0d5f298d1cd39cd9c38e8720bc">executor_type</a> <a class="el" href="classboost_1_1beast_1_1basic__stream.html">boost::beast::basic_stream</a>&lt; Protocol, Executor, RatePolicy &gt;::get_executor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the executor associated with the object.</p>
<p>This function may be used to obtain the executor object that the stream uses to dispatch completion handlers without an assocaited executor.</p>
<dl class="section return"><dt>戻り値</dt><dd>A copy of the executor that stream will use to dispatch handlers. </dd></dl>

</div>
</div>
<a id="ac807d7b85c0e7df88a193935ce785901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac807d7b85c0e7df88a193935ce785901">&#9670;&nbsp;</a></span>read_some() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Protocol , class Executor  = net::any_io_executor, class RatePolicy  = unlimited_rate_policy&gt; </div>
<div class="memtemplate">
template&lt;class MutableBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1basic__stream.html">boost::beast::basic_stream</a>&lt; Protocol, Executor, RatePolicy &gt;::read_some </td>
          <td>(</td>
          <td class="paramtype">MutableBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read some data.</p>
<p>This function is used to read some data from the stream.</p>
<p>The call blocks until one of the following is true:</p>
<ul>
<li>One or more bytes are read from the stream.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The buffers into which the data will be read. If the size of the buffers is zero bytes, the call always returns immediately with no error.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The number of bytes read.</dd></dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>The <code>read_some</code> operation may not receive all of the requested number of bytes. Consider using the function <code>net::read</code> if you need to ensure that the requested amount of data is read before the blocking operation completes. </dd></dl>

</div>
</div>
<a id="aed6b24c1917384bfd12b7d3726a3a7ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed6b24c1917384bfd12b7d3726a3a7ec">&#9670;&nbsp;</a></span>read_some() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Protocol , class Executor  = net::any_io_executor, class RatePolicy  = unlimited_rate_policy&gt; </div>
<div class="memtemplate">
template&lt;class MutableBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1basic__stream.html">boost::beast::basic_stream</a>&lt; Protocol, Executor, RatePolicy &gt;::read_some </td>
          <td>(</td>
          <td class="paramtype">MutableBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read some data.</p>
<p>This function is used to read some data from the underlying socket.</p>
<p>The call blocks until one of the following is true:</p>
<ul>
<li>One or more bytes are read from the stream.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The buffers into which the data will be read. If the size of the buffers is zero bytes, the call always returns immediately with no error.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The number of bytes read.</dd></dl>
<dl class="section note"><dt>覚え書き</dt><dd>The <code>read_some</code> operation may not receive all of the requested number of bytes. Consider using the function <code>net::read</code> if you need to ensure that the requested amount of data is read before the blocking operation completes. </dd></dl>

</div>
</div>
<a id="af8f4285655f95aa4ef1fc66a9bc42b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8f4285655f95aa4ef1fc66a9bc42b7a">&#9670;&nbsp;</a></span>release_socket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Protocol , class Executor , class RatePolicy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classboost_1_1beast_1_1basic__stream.html">boost::beast::basic_stream</a>&lt; Protocol, Executor, RatePolicy &gt;::release_socket</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release ownership of the underlying socket.</p>
<p>This function causes all outstanding asynchronous connect, read, and write operations to be canceled as if by a call to <a class="el" href="classboost_1_1beast_1_1basic__stream.html#a88493d0b533c4d055d9f91793c0aa3c6">cancel</a>. Ownership of the underlying socket is then transferred to the caller. </p>

</div>
</div>
<a id="a31bf9178f4c85b8204341af9507b3a10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31bf9178f4c85b8204341af9507b3a10">&#9670;&nbsp;</a></span>write_some() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Protocol , class Executor  = net::any_io_executor, class RatePolicy  = unlimited_rate_policy&gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1basic__stream.html">boost::beast::basic_stream</a>&lt; Protocol, Executor, RatePolicy &gt;::write_some </td>
          <td>(</td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write some data.</p>
<p>This function is used to write some data to the stream.</p>
<p>The call blocks until one of the following is true:</p>
<ul>
<li>One or more bytes are written to the stream.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The buffers from which the data will be written. If the size of the buffers is zero bytes, the call always returns immediately with no error.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The number of bytes written.</dd></dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>The <code>write_some</code> operation may not transmit all of the requested number of bytes. Consider using the function <code>net::write</code> if you need to ensure that the requested amount of data is written before the blocking operation completes. </dd></dl>

</div>
</div>
<a id="a65eebd2ee90f118ee592c8f742631ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65eebd2ee90f118ee592c8f742631ec3">&#9670;&nbsp;</a></span>write_some() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Protocol , class Executor  = net::any_io_executor, class RatePolicy  = unlimited_rate_policy&gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1basic__stream.html">boost::beast::basic_stream</a>&lt; Protocol, Executor, RatePolicy &gt;::write_some </td>
          <td>(</td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write some data.</p>
<p>This function is used to write some data to the stream.</p>
<p>The call blocks until one of the following is true:</p>
<ul>
<li>One or more bytes are written to the stream.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The buffers from which the data will be written. If the size of the buffers is zero bytes, the call always returns immediately with no error.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The number of bytes written.</dd></dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>The <code>write_some</code> operation may not transmit all of the requested number of bytes. Consider using the function <code>net::write</code> if you need to ensure that the requested amount of data is written before the blocking operation completes. </dd></dl>

</div>
</div>
<h2 class="groupheader">メンバ詳解</h2>
<a id="a3144b25287ce039361de1675270ff77a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3144b25287ce039361de1675270ff77a">&#9670;&nbsp;</a></span>handler <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Protocol , class Executor  = net::any_io_executor, class RatePolicy  = unlimited_rate_policy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RangeConnectHandler&amp;&amp; <a class="el" href="classboost_1_1beast_1_1basic__stream.html">boost::beast::basic_stream</a>&lt; Protocol, Executor, RatePolicy &gt;::handler</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>初期値:</b><div class="fragment"><div class="line">=</div>
<div class="line">            net::default_completion_token_t&lt;executor_type&gt;{})</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8ca72bc76b5678c1ab6367cc09ba0f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ca72bc76b5678c1ab6367cc09ba0f54">&#9670;&nbsp;</a></span>handler <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Protocol , class Executor  = net::any_io_executor, class RatePolicy  = unlimited_rate_policy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ConnectCondition RangeConnectHandler&amp;&amp; <a class="el" href="classboost_1_1beast_1_1basic__stream.html">boost::beast::basic_stream</a>&lt; Protocol, Executor, RatePolicy &gt;::handler</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>初期値:</b><div class="fragment"><div class="line">=</div>
<div class="line">            net::default_completion_token_t&lt;</div>
<div class="line">                <a class="code" href="classboost_1_1beast_1_1basic__stream.html#a8123de0d5f298d1cd39cd9c38e8720bc">executor_type</a>&gt;{})</div>
</div><!-- fragment -->
</div>
</div>
<a id="a091b5d9a15e4b38a400dcc062e06ac45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a091b5d9a15e4b38a400dcc062e06ac45">&#9670;&nbsp;</a></span>handler <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Protocol , class Executor  = net::any_io_executor, class RatePolicy  = unlimited_rate_policy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator IteratorConnectHandler&amp;&amp; <a class="el" href="classboost_1_1beast_1_1basic__stream.html">boost::beast::basic_stream</a>&lt; Protocol, Executor, RatePolicy &gt;::handler</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>初期値:</b><div class="fragment"><div class="line">=</div>
<div class="line">            net::default_completion_token_t&lt;executor_type&gt;{})</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad0de762f9bcc052a1c49805bd3ca2a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0de762f9bcc052a1c49805bd3ca2a4a">&#9670;&nbsp;</a></span>handler <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Protocol , class Executor  = net::any_io_executor, class RatePolicy  = unlimited_rate_policy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator ConnectCondition IteratorConnectHandler&amp;&amp; <a class="el" href="classboost_1_1beast_1_1basic__stream.html">boost::beast::basic_stream</a>&lt; Protocol, Executor, RatePolicy &gt;::handler</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>初期値:</b><div class="fragment"><div class="line">=</div>
<div class="line">            net::default_completion_token_t&lt;executor_type&gt;{})</div>
</div><!-- fragment -->
</div>
</div>
<hr/>このクラス詳解は次のファイルから抽出されました:<ul>
<li>include/external/boost/boost/beast/core/<a class="el" href="basic__stream_8hpp_source.html">basic_stream.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="aclassboost_1_1beast_1_1basic__stream_html_a8123de0d5f298d1cd39cd9c38e8720bc"><div class="ttname"><a href="classboost_1_1beast_1_1basic__stream.html#a8123de0d5f298d1cd39cd9c38e8720bc">boost::beast::basic_stream::executor_type</a></div><div class="ttdeci">beast::executor_type&lt; socket_type &gt; executor_type</div><div class="ttdef"><b>Definition:</b> basic_stream.hpp:218</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceboost.html">boost</a></li><li class="navelem"><b>beast</b></li><li class="navelem"><a class="el" href="classboost_1_1beast_1_1basic__stream.html">basic_stream</a></li>
    <li class="footer">構築:
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
