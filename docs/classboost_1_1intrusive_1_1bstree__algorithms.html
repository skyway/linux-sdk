<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
<head>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
        'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
        })(window,document,'script','dataLayer','GTM-NN5JX4B');</script>
    <!-- End Google Tag Manager -->
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=11"/>
    <meta name="generator" content="Doxygen 1.9.8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>SkyWay Linux SDK</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="resize.js"></script>
    <script type="text/javascript" src="navtreedata.js"></script>
    <script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="search/searchdata.js"></script>
    <script type="text/javascript" src="search/search.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NN5JX4B"
        height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
            <tbody>
                <tr id="projectrow">
                    <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
                    <td id="projectalign">
                        <div id="projectname">SkyWay Linux SDK
                        </div>
                    </td>
                </tr>
            </tbody>
        </table>
    </div><!-- 構築: Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'検索');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','検索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classboost_1_1intrusive_1_1bstree__algorithms.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">公開型</a> &#124;
<a href="#pub-static-methods">静的公開メンバ関数</a> &#124;
<a href="#pro-static-methods">静的限定公開メンバ関数</a> &#124;
<a href="classboost_1_1intrusive_1_1bstree__algorithms-members.html">全メンバ一覧</a>  </div>
  <div class="headertitle">
<div class="title">boost::intrusive::bstree_algorithms&lt; NodeTraits &gt; クラステンプレート</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="bstree__algorithms_8hpp_source.html">bstree_algorithms.hpp</a>&gt;</code></p>
<div class="dynheader">
boost::intrusive::bstree_algorithms&lt; NodeTraits &gt; の継承関係図</div>
<div class="dyncontent">
 <div class="center">
  <img src="classboost_1_1intrusive_1_1bstree__algorithms.png" usemap="#boost::intrusive::bstree_5Falgorithms_3C_20NodeTraits_20_3E_map" alt=""/>
  <map id="boost::intrusive::bstree_5Falgorithms_3C_20NodeTraits_20_3E_map" name="boost::intrusive::bstree_5Falgorithms_3C_20NodeTraits_20_3E_map">
<area href="classboost_1_1intrusive_1_1bstree__algorithms__base.html" alt="boost::intrusive::bstree_algorithms_base&lt; NodeTraits &gt;" shape="rect" coords="0,0,320,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
公開型</h2></td></tr>
<tr class="memitem:aa974c0e6042bc8ca7cdbcbc2b55b3d28"><td class="memItemLeft" align="right" valign="top"><a id="aa974c0e6042bc8ca7cdbcbc2b55b3d28"></a>
typedef NodeTraits::node&#160;</td><td class="memItemRight" valign="bottom"><b>node</b></td></tr>
<tr class="separator:aa974c0e6042bc8ca7cdbcbc2b55b3d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16af0e159ed9bade1082120b22d2de0a"><td class="memItemLeft" align="right" valign="top"><a id="a16af0e159ed9bade1082120b22d2de0a"></a>
typedef NodeTraits&#160;</td><td class="memItemRight" valign="bottom"><b>node_traits</b></td></tr>
<tr class="separator:a16af0e159ed9bade1082120b22d2de0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affacff4bfc3aea1701566169b2c8b2f5"><td class="memItemLeft" align="right" valign="top"><a id="affacff4bfc3aea1701566169b2c8b2f5"></a>
typedef NodeTraits::node_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>node_ptr</b></td></tr>
<tr class="separator:affacff4bfc3aea1701566169b2c8b2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7451fe8593a4aed2efe3f7d6e06b310e"><td class="memItemLeft" align="right" valign="top"><a id="a7451fe8593a4aed2efe3f7d6e06b310e"></a>
typedef NodeTraits::const_node_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>const_node_ptr</b></td></tr>
<tr class="separator:a7451fe8593a4aed2efe3f7d6e06b310e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a213ac9d40b71d003a5cc3bc3450ec8"><td class="memItemLeft" align="right" valign="top"><a id="a0a213ac9d40b71d003a5cc3bc3450ec8"></a>
typedef insert_commit_data_t&lt; node_ptr &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>insert_commit_data</b></td></tr>
<tr class="separator:a0a213ac9d40b71d003a5cc3bc3450ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2eea0a6aaea45435ebd16547719e84b"><td class="memItemLeft" align="right" valign="top"><a id="ab2eea0a6aaea45435ebd16547719e84b"></a>
typedef data_for_rebalance_t&lt; node_ptr &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>data_for_rebalance</b></td></tr>
<tr class="separator:ab2eea0a6aaea45435ebd16547719e84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classboost_1_1intrusive_1_1bstree__algorithms__base"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classboost_1_1intrusive_1_1bstree__algorithms__base')"><img src="closed.png" alt="-"/>&#160;基底クラス <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms__base.html">boost::intrusive::bstree_algorithms_base&lt; NodeTraits &gt;</a> に属する継承公開型</td></tr>
<tr class="memitem:a976719dc70a95cd1ed8c19f9f81cd50e inherit pub_types_classboost_1_1intrusive_1_1bstree__algorithms__base"><td class="memItemLeft" align="right" valign="top"><a id="a976719dc70a95cd1ed8c19f9f81cd50e"></a>
typedef NodeTraits::node&#160;</td><td class="memItemRight" valign="bottom"><b>node</b></td></tr>
<tr class="separator:a976719dc70a95cd1ed8c19f9f81cd50e inherit pub_types_classboost_1_1intrusive_1_1bstree__algorithms__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24790ece4ab54ca576422e128acab44 inherit pub_types_classboost_1_1intrusive_1_1bstree__algorithms__base"><td class="memItemLeft" align="right" valign="top"><a id="af24790ece4ab54ca576422e128acab44"></a>
typedef NodeTraits&#160;</td><td class="memItemRight" valign="bottom"><b>node_traits</b></td></tr>
<tr class="separator:af24790ece4ab54ca576422e128acab44 inherit pub_types_classboost_1_1intrusive_1_1bstree__algorithms__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8ccc349632c4017d50906a69bdf355 inherit pub_types_classboost_1_1intrusive_1_1bstree__algorithms__base"><td class="memItemLeft" align="right" valign="top"><a id="a0b8ccc349632c4017d50906a69bdf355"></a>
typedef NodeTraits::node_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>node_ptr</b></td></tr>
<tr class="separator:a0b8ccc349632c4017d50906a69bdf355 inherit pub_types_classboost_1_1intrusive_1_1bstree__algorithms__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a8e681e932f2c8d985e62b311da5ef inherit pub_types_classboost_1_1intrusive_1_1bstree__algorithms__base"><td class="memItemLeft" align="right" valign="top"><a id="ac9a8e681e932f2c8d985e62b311da5ef"></a>
typedef NodeTraits::const_node_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>const_node_ptr</b></td></tr>
<tr class="separator:ac9a8e681e932f2c8d985e62b311da5ef inherit pub_types_classboost_1_1intrusive_1_1bstree__algorithms__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
静的公開メンバ関数</h2></td></tr>
<tr class="memitem:a3645f585a7142f8e47c84f1d53a54cae"><td class="memItemLeft" align="right" valign="top">static BOOST_INTRUSIVE_FORCEINLINE node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#a3645f585a7142f8e47c84f1d53a54cae">begin_node</a> (const const_node_ptr &amp;header)</td></tr>
<tr class="separator:a3645f585a7142f8e47c84f1d53a54cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d81e9a4e18ed37ff825dd6be3780ec"><td class="memItemLeft" align="right" valign="top">static BOOST_INTRUSIVE_FORCEINLINE node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#a18d81e9a4e18ed37ff825dd6be3780ec">end_node</a> (const const_node_ptr &amp;header)</td></tr>
<tr class="separator:a18d81e9a4e18ed37ff825dd6be3780ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab838ea8f26371cca42858500da72505e"><td class="memItemLeft" align="right" valign="top">static BOOST_INTRUSIVE_FORCEINLINE node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#ab838ea8f26371cca42858500da72505e">root_node</a> (const const_node_ptr &amp;header)</td></tr>
<tr class="separator:ab838ea8f26371cca42858500da72505e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e72515913cf5b268e7b751772cb120"><td class="memItemLeft" align="right" valign="top">static BOOST_INTRUSIVE_FORCEINLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#a93e72515913cf5b268e7b751772cb120">unique</a> (const const_node_ptr &amp;node)</td></tr>
<tr class="separator:a93e72515913cf5b268e7b751772cb120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaaf1f755df8b4f6ca4d1945fc0e8a06"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#adaaf1f755df8b4f6ca4d1945fc0e8a06">swap_nodes</a> (node_ptr node1, node_ptr node2)</td></tr>
<tr class="separator:adaaf1f755df8b4f6ca4d1945fc0e8a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f944f847babc32f769dfcbb4ca2d328"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#a0f944f847babc32f769dfcbb4ca2d328">swap_nodes</a> (node_ptr node1, node_ptr header1, node_ptr node2, node_ptr header2)</td></tr>
<tr class="separator:a0f944f847babc32f769dfcbb4ca2d328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aaa7efa169ac8d35a3b4701543712f8"><td class="memItemLeft" align="right" valign="top">static BOOST_INTRUSIVE_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#a8aaa7efa169ac8d35a3b4701543712f8">replace_node</a> (node_ptr node_to_be_replaced, node_ptr new_node)</td></tr>
<tr class="separator:a8aaa7efa169ac8d35a3b4701543712f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6144ccc5a40401c25d7bde977da862"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#a0b6144ccc5a40401c25d7bde977da862">replace_node</a> (node_ptr node_to_be_replaced, node_ptr header, node_ptr new_node)</td></tr>
<tr class="separator:a0b6144ccc5a40401c25d7bde977da862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d38aecb00b33895184b66b9de91cade"><td class="memItemLeft" align="right" valign="top">static BOOST_INTRUSIVE_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#a9d38aecb00b33895184b66b9de91cade">init</a> (node_ptr node)</td></tr>
<tr class="separator:a9d38aecb00b33895184b66b9de91cade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa16bedbce3e5247321c00a9477207d"><td class="memItemLeft" align="right" valign="top">static BOOST_INTRUSIVE_FORCEINLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#adfa16bedbce3e5247321c00a9477207d">inited</a> (const const_node_ptr &amp;node)</td></tr>
<tr class="separator:adfa16bedbce3e5247321c00a9477207d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3934adf1b08e3ce8dbdd32c9c5f1ee3"><td class="memItemLeft" align="right" valign="top">static BOOST_INTRUSIVE_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#af3934adf1b08e3ce8dbdd32c9c5f1ee3">init_header</a> (node_ptr header)</td></tr>
<tr class="separator:af3934adf1b08e3ce8dbdd32c9c5f1ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04747a10e259d548d5cc3282c3c869f"><td class="memTemplParams" colspan="2">template&lt;class Disposer &gt; </td></tr>
<tr class="memitem:ab04747a10e259d548d5cc3282c3c869f"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#ab04747a10e259d548d5cc3282c3c869f">clear_and_dispose</a> (const node_ptr &amp;header, Disposer disposer)</td></tr>
<tr class="separator:ab04747a10e259d548d5cc3282c3c869f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad018e6d390e6b3f0951ad8efd1a781fb"><td class="memItemLeft" align="right" valign="top">static node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#ad018e6d390e6b3f0951ad8efd1a781fb">unlink_leftmost_without_rebalance</a> (node_ptr header)</td></tr>
<tr class="separator:ad018e6d390e6b3f0951ad8efd1a781fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8724b81859e7b262273057159cc94a9"><td class="memItemLeft" align="right" valign="top">static std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#aa8724b81859e7b262273057159cc94a9">size</a> (const const_node_ptr &amp;header)</td></tr>
<tr class="separator:aa8724b81859e7b262273057159cc94a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5acdfee62d8c6958768496111fde0b8c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#a5acdfee62d8c6958768496111fde0b8c">swap_tree</a> (node_ptr header1, node_ptr header2)</td></tr>
<tr class="separator:a5acdfee62d8c6958768496111fde0b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d948878092698fc4c9fdb63e1ccfb3a"><td class="memTemplParams" colspan="2">template&lt;class KeyType , class KeyNodePtrCompare &gt; </td></tr>
<tr class="memitem:a3d948878092698fc4c9fdb63e1ccfb3a"><td class="memTemplItemLeft" align="right" valign="top">static node_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#a3d948878092698fc4c9fdb63e1ccfb3a">find</a> (const const_node_ptr &amp;header, const KeyType &amp;key, KeyNodePtrCompare comp)</td></tr>
<tr class="separator:a3d948878092698fc4c9fdb63e1ccfb3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac3f1d7c1e77471d463530353e6dd19"><td class="memTemplParams" colspan="2">template&lt;class KeyType , class KeyNodePtrCompare &gt; </td></tr>
<tr class="memitem:a5ac3f1d7c1e77471d463530353e6dd19"><td class="memTemplItemLeft" align="right" valign="top">static std::pair&lt; node_ptr, node_ptr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#a5ac3f1d7c1e77471d463530353e6dd19">bounded_range</a> (const const_node_ptr &amp;header, const KeyType &amp;lower_key, const KeyType &amp;upper_key, KeyNodePtrCompare comp, bool left_closed, bool right_closed)</td></tr>
<tr class="separator:a5ac3f1d7c1e77471d463530353e6dd19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e82b6887af90c8dcd343af9b2b804c"><td class="memTemplParams" colspan="2">template&lt;class KeyType , class KeyNodePtrCompare &gt; </td></tr>
<tr class="memitem:a92e82b6887af90c8dcd343af9b2b804c"><td class="memTemplItemLeft" align="right" valign="top">static std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#a92e82b6887af90c8dcd343af9b2b804c">count</a> (const const_node_ptr &amp;header, const KeyType &amp;key, KeyNodePtrCompare comp)</td></tr>
<tr class="separator:a92e82b6887af90c8dcd343af9b2b804c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06bf1f73e5b2d4d9b77bd32a0a66c2df"><td class="memTemplParams" colspan="2">template&lt;class KeyType , class KeyNodePtrCompare &gt; </td></tr>
<tr class="memitem:a06bf1f73e5b2d4d9b77bd32a0a66c2df"><td class="memTemplItemLeft" align="right" valign="top">static BOOST_INTRUSIVE_FORCEINLINE std::pair&lt; node_ptr, node_ptr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#a06bf1f73e5b2d4d9b77bd32a0a66c2df">equal_range</a> (const const_node_ptr &amp;header, const KeyType &amp;key, KeyNodePtrCompare comp)</td></tr>
<tr class="separator:a06bf1f73e5b2d4d9b77bd32a0a66c2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454624d956cc1a958f5f9489e667f4a2"><td class="memTemplParams" colspan="2">template&lt;class KeyType , class KeyNodePtrCompare &gt; </td></tr>
<tr class="memitem:a454624d956cc1a958f5f9489e667f4a2"><td class="memTemplItemLeft" align="right" valign="top">static std::pair&lt; node_ptr, node_ptr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#a454624d956cc1a958f5f9489e667f4a2">lower_bound_range</a> (const const_node_ptr &amp;header, const KeyType &amp;key, KeyNodePtrCompare comp)</td></tr>
<tr class="separator:a454624d956cc1a958f5f9489e667f4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d094812366967052b7570011e9a64be"><td class="memTemplParams" colspan="2">template&lt;class KeyType , class KeyNodePtrCompare &gt; </td></tr>
<tr class="memitem:a9d094812366967052b7570011e9a64be"><td class="memTemplItemLeft" align="right" valign="top">static BOOST_INTRUSIVE_FORCEINLINE node_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#a9d094812366967052b7570011e9a64be">lower_bound</a> (const const_node_ptr &amp;header, const KeyType &amp;key, KeyNodePtrCompare comp)</td></tr>
<tr class="separator:a9d094812366967052b7570011e9a64be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e89df4bcd55bfa846bb8f408bbb6c81"><td class="memTemplParams" colspan="2">template&lt;class KeyType , class KeyNodePtrCompare &gt; </td></tr>
<tr class="memitem:a9e89df4bcd55bfa846bb8f408bbb6c81"><td class="memTemplItemLeft" align="right" valign="top">static BOOST_INTRUSIVE_FORCEINLINE node_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#a9e89df4bcd55bfa846bb8f408bbb6c81">upper_bound</a> (const const_node_ptr &amp;header, const KeyType &amp;key, KeyNodePtrCompare comp)</td></tr>
<tr class="separator:a9e89df4bcd55bfa846bb8f408bbb6c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2709751dd8286203f972edb0c35f98"><td class="memItemLeft" align="right" valign="top">static BOOST_INTRUSIVE_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#aff2709751dd8286203f972edb0c35f98">insert_unique_commit</a> (node_ptr header, node_ptr new_value, const insert_commit_data &amp;commit_data)</td></tr>
<tr class="separator:aff2709751dd8286203f972edb0c35f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c24171a162cd8f528f2dbbc2f73e09"><td class="memTemplParams" colspan="2">template&lt;class KeyType , class KeyNodePtrCompare &gt; </td></tr>
<tr class="memitem:a43c24171a162cd8f528f2dbbc2f73e09"><td class="memTemplItemLeft" align="right" valign="top">static std::pair&lt; node_ptr, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#a43c24171a162cd8f528f2dbbc2f73e09">insert_unique_check</a> (const const_node_ptr &amp;header, const KeyType &amp;key, KeyNodePtrCompare comp, insert_commit_data &amp;commit_data, std::size_t *pdepth=0)</td></tr>
<tr class="separator:a43c24171a162cd8f528f2dbbc2f73e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e9b650d0b7a105505924f9b5c9b650"><td class="memTemplParams" colspan="2">template&lt;class KeyType , class KeyNodePtrCompare &gt; </td></tr>
<tr class="memitem:a40e9b650d0b7a105505924f9b5c9b650"><td class="memTemplItemLeft" align="right" valign="top">static std::pair&lt; node_ptr, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#a40e9b650d0b7a105505924f9b5c9b650">insert_unique_check</a> (const const_node_ptr &amp;header, const node_ptr &amp;hint, const KeyType &amp;key, KeyNodePtrCompare comp, insert_commit_data &amp;commit_data, std::size_t *pdepth=0)</td></tr>
<tr class="separator:a40e9b650d0b7a105505924f9b5c9b650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3f637ae3a06ef0ed85e932368d4038"><td class="memTemplParams" colspan="2">template&lt;class NodePtrCompare &gt; </td></tr>
<tr class="memitem:afe3f637ae3a06ef0ed85e932368d4038"><td class="memTemplItemLeft" align="right" valign="top">static node_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#afe3f637ae3a06ef0ed85e932368d4038">insert_equal</a> (node_ptr h, node_ptr hint, node_ptr new_node, NodePtrCompare comp, std::size_t *pdepth=0)</td></tr>
<tr class="separator:afe3f637ae3a06ef0ed85e932368d4038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4576b97ce5bbad8417de1e73f66a7738"><td class="memTemplParams" colspan="2">template&lt;class NodePtrCompare &gt; </td></tr>
<tr class="memitem:a4576b97ce5bbad8417de1e73f66a7738"><td class="memTemplItemLeft" align="right" valign="top">static node_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#a4576b97ce5bbad8417de1e73f66a7738">insert_equal_upper_bound</a> (node_ptr h, node_ptr new_node, NodePtrCompare comp, std::size_t *pdepth=0)</td></tr>
<tr class="separator:a4576b97ce5bbad8417de1e73f66a7738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480df863207c07ad24b594c32a49db27"><td class="memTemplParams" colspan="2">template&lt;class NodePtrCompare &gt; </td></tr>
<tr class="memitem:a480df863207c07ad24b594c32a49db27"><td class="memTemplItemLeft" align="right" valign="top">static node_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#a480df863207c07ad24b594c32a49db27">insert_equal_lower_bound</a> (node_ptr h, node_ptr new_node, NodePtrCompare comp, std::size_t *pdepth=0)</td></tr>
<tr class="separator:a480df863207c07ad24b594c32a49db27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6735224506d05a000c46d1bae9f333d4"><td class="memItemLeft" align="right" valign="top">static node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#a6735224506d05a000c46d1bae9f333d4">insert_before</a> (node_ptr header, node_ptr pos, node_ptr new_node, std::size_t *pdepth=0)</td></tr>
<tr class="separator:a6735224506d05a000c46d1bae9f333d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a59d215532dcfd3f190b1b4477da301"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#a5a59d215532dcfd3f190b1b4477da301">push_back</a> (node_ptr header, node_ptr new_node, std::size_t *pdepth=0)</td></tr>
<tr class="separator:a5a59d215532dcfd3f190b1b4477da301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4fa0c51707b3921f0c3b8a979a812da"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#aa4fa0c51707b3921f0c3b8a979a812da">push_front</a> (node_ptr header, node_ptr new_node, std::size_t *pdepth=0)</td></tr>
<tr class="separator:aa4fa0c51707b3921f0c3b8a979a812da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b16bd009d4f4ae62b5bc2d72166a015"><td class="memItemLeft" align="right" valign="top">static std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#a9b16bd009d4f4ae62b5bc2d72166a015">depth</a> (const_node_ptr node)</td></tr>
<tr class="separator:a9b16bd009d4f4ae62b5bc2d72166a015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30f2c6286d1e4ea88700546424af95b"><td class="memTemplParams" colspan="2">template&lt;class Cloner , class Disposer &gt; </td></tr>
<tr class="memitem:aa30f2c6286d1e4ea88700546424af95b"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#aa30f2c6286d1e4ea88700546424af95b">clone</a> (const const_node_ptr &amp;source_header, node_ptr target_header, Cloner cloner, Disposer disposer)</td></tr>
<tr class="separator:aa30f2c6286d1e4ea88700546424af95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ba491127d2286a0321839ab6146990"><td class="memItemLeft" align="right" valign="top">static BOOST_INTRUSIVE_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#ad9ba491127d2286a0321839ab6146990">erase</a> (node_ptr header, node_ptr z)</td></tr>
<tr class="separator:ad9ba491127d2286a0321839ab6146990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abecc400acbfb82498a29896cf16fde6e"><td class="memTemplParams" colspan="2">template&lt;class NodePtrCompare &gt; </td></tr>
<tr class="memitem:abecc400acbfb82498a29896cf16fde6e"><td class="memTemplItemLeft" align="right" valign="top">static BOOST_INTRUSIVE_FORCEINLINE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#abecc400acbfb82498a29896cf16fde6e">transfer_unique</a> (node_ptr header1, NodePtrCompare comp, node_ptr header2, node_ptr z)</td></tr>
<tr class="separator:abecc400acbfb82498a29896cf16fde6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b965e71fa5ea51f8b78dfb4344a856f"><td class="memTemplParams" colspan="2">template&lt;class NodePtrCompare &gt; </td></tr>
<tr class="memitem:a9b965e71fa5ea51f8b78dfb4344a856f"><td class="memTemplItemLeft" align="right" valign="top">static BOOST_INTRUSIVE_FORCEINLINE void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#a9b965e71fa5ea51f8b78dfb4344a856f">transfer_equal</a> (node_ptr header1, NodePtrCompare comp, node_ptr header2, node_ptr z)</td></tr>
<tr class="separator:a9b965e71fa5ea51f8b78dfb4344a856f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb2cd5984a9710795d38a2595caea04"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#a0eb2cd5984a9710795d38a2595caea04">unlink</a> (node_ptr node)</td></tr>
<tr class="separator:a0eb2cd5984a9710795d38a2595caea04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dfa34ba424c5cfb7bfb4cec1d35fa74"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#a3dfa34ba424c5cfb7bfb4cec1d35fa74">rebalance</a> (node_ptr header)</td></tr>
<tr class="separator:a3dfa34ba424c5cfb7bfb4cec1d35fa74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402c1bd70bcb147401fd2bbaae564c3f"><td class="memItemLeft" align="right" valign="top">static node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#a402c1bd70bcb147401fd2bbaae564c3f">rebalance_subtree</a> (node_ptr old_root)</td></tr>
<tr class="separator:a402c1bd70bcb147401fd2bbaae564c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f1a9f055d1ebf3e41751670d2d1bfb"><td class="memTemplParams" colspan="2">template&lt;class Checker &gt; </td></tr>
<tr class="memitem:a12f1a9f055d1ebf3e41751670d2d1bfb"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#a12f1a9f055d1ebf3e41751670d2d1bfb">check</a> (const const_node_ptr &amp;header, Checker checker, typename Checker::return_type &amp;checker_return)</td></tr>
<tr class="separator:a12f1a9f055d1ebf3e41751670d2d1bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classboost_1_1intrusive_1_1bstree__algorithms__base"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classboost_1_1intrusive_1_1bstree__algorithms__base')"><img src="closed.png" alt="-"/>&#160;基底クラス <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms__base.html">boost::intrusive::bstree_algorithms_base&lt; NodeTraits &gt;</a> に属する継承静的公開メンバ関数</td></tr>
<tr class="memitem:aed47bd6ea74d75d87ee68e8554f71914 inherit pub_static_methods_classboost_1_1intrusive_1_1bstree__algorithms__base"><td class="memItemLeft" align="right" valign="top">static node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms__base.html#aed47bd6ea74d75d87ee68e8554f71914">next_node</a> (const node_ptr &amp;node)</td></tr>
<tr class="separator:aed47bd6ea74d75d87ee68e8554f71914 inherit pub_static_methods_classboost_1_1intrusive_1_1bstree__algorithms__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee31b33ed063446b387dbbfd225402c1 inherit pub_static_methods_classboost_1_1intrusive_1_1bstree__algorithms__base"><td class="memItemLeft" align="right" valign="top">static node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms__base.html#aee31b33ed063446b387dbbfd225402c1">prev_node</a> (const node_ptr &amp;node)</td></tr>
<tr class="separator:aee31b33ed063446b387dbbfd225402c1 inherit pub_static_methods_classboost_1_1intrusive_1_1bstree__algorithms__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f403939f14885b115c8615ea3a24ce3 inherit pub_static_methods_classboost_1_1intrusive_1_1bstree__algorithms__base"><td class="memItemLeft" align="right" valign="top">static node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms__base.html#a6f403939f14885b115c8615ea3a24ce3">minimum</a> (node_ptr node)</td></tr>
<tr class="separator:a6f403939f14885b115c8615ea3a24ce3 inherit pub_static_methods_classboost_1_1intrusive_1_1bstree__algorithms__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d0faaa26c552c684be357469845227 inherit pub_static_methods_classboost_1_1intrusive_1_1bstree__algorithms__base"><td class="memItemLeft" align="right" valign="top">static node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms__base.html#a21d0faaa26c552c684be357469845227">maximum</a> (node_ptr node)</td></tr>
<tr class="separator:a21d0faaa26c552c684be357469845227 inherit pub_static_methods_classboost_1_1intrusive_1_1bstree__algorithms__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a02c4f0030cd0fcf6396091f004d249 inherit pub_static_methods_classboost_1_1intrusive_1_1bstree__algorithms__base"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms__base.html#a5a02c4f0030cd0fcf6396091f004d249">is_header</a> (const const_node_ptr &amp;p)</td></tr>
<tr class="separator:a5a02c4f0030cd0fcf6396091f004d249 inherit pub_static_methods_classboost_1_1intrusive_1_1bstree__algorithms__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b0ddc3be2df2febed25be565912cd2 inherit pub_static_methods_classboost_1_1intrusive_1_1bstree__algorithms__base"><td class="memItemLeft" align="right" valign="top">static node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms__base.html#a34b0ddc3be2df2febed25be565912cd2">get_header</a> (const const_node_ptr &amp;node)</td></tr>
<tr class="separator:a34b0ddc3be2df2febed25be565912cd2 inherit pub_static_methods_classboost_1_1intrusive_1_1bstree__algorithms__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
静的限定公開メンバ関数</h2></td></tr>
<tr class="memitem:ac0869970c353ba82d155b05bfd3da4d7"><td class="memTemplParams" colspan="2"><a id="ac0869970c353ba82d155b05bfd3da4d7"></a>
template&lt;class NodePtrCompare &gt; </td></tr>
<tr class="memitem:ac0869970c353ba82d155b05bfd3da4d7"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transfer_unique</b> (node_ptr header1, NodePtrCompare comp, node_ptr header2, node_ptr z, data_for_rebalance &amp;info)</td></tr>
<tr class="separator:ac0869970c353ba82d155b05bfd3da4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5182afeb279ec3f6e1c34514a2a234d2"><td class="memTemplParams" colspan="2"><a id="a5182afeb279ec3f6e1c34514a2a234d2"></a>
template&lt;class NodePtrCompare &gt; </td></tr>
<tr class="memitem:a5182afeb279ec3f6e1c34514a2a234d2"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transfer_equal</b> (node_ptr header1, NodePtrCompare comp, node_ptr header2, node_ptr z, data_for_rebalance &amp;info)</td></tr>
<tr class="separator:a5182afeb279ec3f6e1c34514a2a234d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb133a71faa7350fdc7f73b643155b8e"><td class="memItemLeft" align="right" valign="top"><a id="acb133a71faa7350fdc7f73b643155b8e"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (node_ptr header, node_ptr z, data_for_rebalance &amp;info)</td></tr>
<tr class="separator:acb133a71faa7350fdc7f73b643155b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1c12903737e1008a514b7bf1da6b26"><td class="memItemLeft" align="right" valign="top">static std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#a3a1c12903737e1008a514b7bf1da6b26">subtree_size</a> (const const_node_ptr &amp;subtree)</td></tr>
<tr class="separator:a3a1c12903737e1008a514b7bf1da6b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6933a07facaf7a1a75ddbee1e0f41d"><td class="memItemLeft" align="right" valign="top">static BOOST_INTRUSIVE_FORCEINLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#a0a6933a07facaf7a1a75ddbee1e0f41d">is_left_child</a> (const node_ptr &amp;p)</td></tr>
<tr class="separator:a0a6933a07facaf7a1a75ddbee1e0f41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f230346da62cfadf7079529a460654"><td class="memItemLeft" align="right" valign="top">static BOOST_INTRUSIVE_FORCEINLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#ae7f230346da62cfadf7079529a460654">is_right_child</a> (const node_ptr &amp;p)</td></tr>
<tr class="separator:ae7f230346da62cfadf7079529a460654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab938b6c006cbe04a7e313be1c17747b5"><td class="memItemLeft" align="right" valign="top"><a id="ab938b6c006cbe04a7e313be1c17747b5"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>insert_before_check</b> (node_ptr header, node_ptr pos, insert_commit_data &amp;commit_data, std::size_t *pdepth=0)</td></tr>
<tr class="separator:ab938b6c006cbe04a7e313be1c17747b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16c9af4f2acb8ee5456cb3f153c9db3"><td class="memItemLeft" align="right" valign="top"><a id="ae16c9af4f2acb8ee5456cb3f153c9db3"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>push_back_check</b> (node_ptr header, insert_commit_data &amp;commit_data, std::size_t *pdepth=0)</td></tr>
<tr class="separator:ae16c9af4f2acb8ee5456cb3f153c9db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0fc5a615ac08eb47afab12136d50dac"><td class="memItemLeft" align="right" valign="top"><a id="af0fc5a615ac08eb47afab12136d50dac"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>push_front_check</b> (node_ptr header, insert_commit_data &amp;commit_data, std::size_t *pdepth=0)</td></tr>
<tr class="separator:af0fc5a615ac08eb47afab12136d50dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ebb2e65f5ccaab876760a778e8c0590"><td class="memTemplParams" colspan="2"><a id="a5ebb2e65f5ccaab876760a778e8c0590"></a>
template&lt;class NodePtrCompare &gt; </td></tr>
<tr class="memitem:a5ebb2e65f5ccaab876760a778e8c0590"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_equal_check</b> (node_ptr header, node_ptr hint, node_ptr new_node, NodePtrCompare comp, insert_commit_data &amp;commit_data)</td></tr>
<tr class="separator:a5ebb2e65f5ccaab876760a778e8c0590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae057be5723147486e0ef4ce584a48c64"><td class="memTemplParams" colspan="2"><a id="ae057be5723147486e0ef4ce584a48c64"></a>
template&lt;class NodePtrCompare &gt; </td></tr>
<tr class="memitem:ae057be5723147486e0ef4ce584a48c64"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_equal_upper_bound_check</b> (node_ptr h, node_ptr new_node, NodePtrCompare comp, insert_commit_data &amp;commit_data, std::size_t *pdepth=0)</td></tr>
<tr class="separator:ae057be5723147486e0ef4ce584a48c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d0356f6ca3273c7b87d8365a6928506"><td class="memTemplParams" colspan="2"><a id="a7d0356f6ca3273c7b87d8365a6928506"></a>
template&lt;class NodePtrCompare &gt; </td></tr>
<tr class="memitem:a7d0356f6ca3273c7b87d8365a6928506"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_equal_lower_bound_check</b> (node_ptr h, node_ptr new_node, NodePtrCompare comp, insert_commit_data &amp;commit_data, std::size_t *pdepth=0)</td></tr>
<tr class="separator:a7d0356f6ca3273c7b87d8365a6928506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e6482ab1222ff663a5fbfc5d058581"><td class="memItemLeft" align="right" valign="top"><a id="a74e6482ab1222ff663a5fbfc5d058581"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>insert_commit</b> (node_ptr header, node_ptr new_node, const insert_commit_data &amp;commit_data)</td></tr>
<tr class="separator:a74e6482ab1222ff663a5fbfc5d058581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b9faada321323e004a25f4dd4c0bef"><td class="memItemLeft" align="right" valign="top"><a id="aa5b9faada321323e004a25f4dd4c0bef"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>set_child</b> (node_ptr header, node_ptr new_child, node_ptr new_parent, const bool link_left)</td></tr>
<tr class="separator:aa5b9faada321323e004a25f4dd4c0bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abffc94ee151e74cdd6f9de92cdd9347b"><td class="memItemLeft" align="right" valign="top"><a id="abffc94ee151e74cdd6f9de92cdd9347b"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>rotate_left_no_parent_fix</b> (node_ptr p, node_ptr p_right)</td></tr>
<tr class="separator:abffc94ee151e74cdd6f9de92cdd9347b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d54147695f76bbcc565bfc81392ffd7"><td class="memItemLeft" align="right" valign="top"><a id="a8d54147695f76bbcc565bfc81392ffd7"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>rotate_left</b> (node_ptr p, node_ptr p_right, node_ptr p_parent, node_ptr header)</td></tr>
<tr class="separator:a8d54147695f76bbcc565bfc81392ffd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe4cb43d355bbc9b39c939856b11892"><td class="memItemLeft" align="right" valign="top"><a id="abbe4cb43d355bbc9b39c939856b11892"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>rotate_right_no_parent_fix</b> (node_ptr p, node_ptr p_left)</td></tr>
<tr class="separator:abbe4cb43d355bbc9b39c939856b11892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba33ae7f1e2e186a7cef8c5a4f86742"><td class="memItemLeft" align="right" valign="top"><a id="aaba33ae7f1e2e186a7cef8c5a4f86742"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>rotate_right</b> (node_ptr p, node_ptr p_left, node_ptr p_parent, node_ptr header)</td></tr>
<tr class="separator:aaba33ae7f1e2e186a7cef8c5a4f86742"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">詳解</h2>
<div class="textblock"><h3>template&lt;class NodeTraits&gt;<br />
class boost::intrusive::bstree_algorithms&lt; NodeTraits &gt;</h3>

<p>This is an implementation of a binary search tree. A node in the search tree has references to its children and its parent. This is to allow traversal of the whole tree from a given node making the implementation of iterator a pointer to a node. At the top of the tree a node is used specially. This node's parent pointer is pointing to the root of the tree. Its left pointer points to the leftmost node in the tree and the right pointer to the rightmost one. This node is used to represent the end-iterator. </p><pre class="fragment">                                     +---------+
header------------------------------&gt;|         |
                                     |         |
            +----------(left)--------|         |--------(right)---------+
            |                        +---------+                        |
            |                             |                             |
            |                             | (parent)                    |
            |                             |                             |
            |                             |                             |
            |                        +---------+                        |
</pre><p> root of tree ..|......................&gt; | | | | | D | | | | | | | +----&mdash;+------&mdash;+----&mdash;+ | </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
</table>
<p>| +------&mdash;+ +------&mdash;+ | | | | | | | | | B | | F | | | | | | | | | +&ndash;+------&mdash;+&ndash;+ +&ndash;+------&mdash;+&ndash;+ | </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone"></th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
</table>
<p>| +&mdash;+--&mdash;+ +--&mdash;+&mdash;+ +&mdash;+--&mdash;+ +--&mdash;+&mdash;+ | +--&gt;| | | | | | | |&lt;&ndash;+ | A | | C | | E | | G | | | | | | | | | +------&mdash;+ +------&mdash;+ +------&mdash;+ +------&mdash;+</p>
<p><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">bstree_algorithms</a> is configured with a NodeTraits class, which encapsulates the information about the node to be manipulated. NodeTraits must support the following interface:</p>
<p><b>Typedefs</b>:</p>
<p><code>node</code>: The type of the node that forms the binary search tree</p>
<p><code>node_ptr</code>: A pointer to a node</p>
<p><code>const_node_ptr</code>: A pointer to a const node</p>
<p><b>Static functions</b>:</p>
<p><code>static node_ptr get_parent(const_node_ptr n);</code></p>
<p><code>static void set_parent(node_ptr n, node_ptr parent);</code></p>
<p><code>static node_ptr get_left(const_node_ptr n);</code></p>
<p><code>static void set_left(node_ptr n, node_ptr left);</code></p>
<p><code>static node_ptr get_right(const_node_ptr n);</code></p>
<p><code>static void set_right(node_ptr n, node_ptr right);</code> </p>
</div><h2 class="groupheader">関数詳解</h2>
<a id="a3645f585a7142f8e47c84f1d53a54cae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3645f585a7142f8e47c84f1d53a54cae">&#9670;&nbsp;</a></span>begin_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BOOST_INTRUSIVE_FORCEINLINE node_ptr <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::begin_node </td>
          <td>(</td>
          <td class="paramtype">const const_node_ptr &amp;&#160;</td>
          <td class="paramname"><em>header</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: 'header' is the header node of a tree.</p>
<p><b>Effects</b>: Returns the first node of the tree, the header if the tree is empty.</p>
<p><b>Complexity</b>: Constant time.</p>
<p><b>Throws</b>: Nothing. </p>

</div>
</div>
<a id="a5ac3f1d7c1e77471d463530353e6dd19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ac3f1d7c1e77471d463530353e6dd19">&#9670;&nbsp;</a></span>bounded_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<div class="memtemplate">
template&lt;class KeyType , class KeyNodePtrCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::pair&lt;node_ptr, node_ptr&gt; <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::bounded_range </td>
          <td>(</td>
          <td class="paramtype">const const_node_ptr &amp;&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>lower_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>upper_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyNodePtrCompare&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>left_closed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>right_closed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs. 'lower_key' must not be greater than 'upper_key' according to 'comp'. If 'lower_key' == 'upper_key', ('left_closed' || 'right_closed') must be true.</p>
<p><b>Effects</b>: Returns an a pair with the following criteria:</p>
<p>first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise</p>
<p>second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise</p>
<p><b>Complexity</b>: Logarithmic.</p>
<p><b>Throws</b>: If "comp" throws.</p>
<p><b>Note</b>: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key.</p>
<p><b>Note</b>: Experimental function, the interface might change. </p>

</div>
</div>
<a id="a12f1a9f055d1ebf3e41751670d2d1bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12f1a9f055d1ebf3e41751670d2d1bfb">&#9670;&nbsp;</a></span>check()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<div class="memtemplate">
template&lt;class Checker &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::check </td>
          <td>(</td>
          <td class="paramtype">const const_node_ptr &amp;&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Checker&#160;</td>
          <td class="paramname"><em>checker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Checker::return_type &amp;&#160;</td>
          <td class="paramname"><em>checker_return</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Effects</b>: Asserts the integrity of the container with additional checks provided by the user.</p>
<p><b>Requires</b>: header must be the header of a tree.</p>
<p><b>Complexity</b>: Linear time.</p>
<p><b>Note</b>: The method might not have effect when asserts are turned off (e.g., with NDEBUG). Experimental function, interface might change in future versions. </p>

</div>
</div>
<a id="ab04747a10e259d548d5cc3282c3c869f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab04747a10e259d548d5cc3282c3c869f">&#9670;&nbsp;</a></span>clear_and_dispose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<div class="memtemplate">
template&lt;class Disposer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::clear_and_dispose </td>
          <td>(</td>
          <td class="paramtype">const node_ptr &amp;&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Disposer&#160;</td>
          <td class="paramname"><em>disposer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: "disposer" must be an object function taking a node_ptr parameter and shouldn't throw.</p>
<p><b>Effects</b>: Empties the target tree calling <code>void disposer::operator()(const node_ptr &amp;)</code> for every node of the tree except the header.</p>
<p><b>Complexity</b>: Linear to the number of element of the source tree plus the. number of elements of tree target tree when calling this function.</p>
<p><b>Throws</b>: If cloner functor throws. If this happens target nodes are disposed. </p>

</div>
</div>
<a id="aa30f2c6286d1e4ea88700546424af95b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30f2c6286d1e4ea88700546424af95b">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<div class="memtemplate">
template&lt;class Cloner , class Disposer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::clone </td>
          <td>(</td>
          <td class="paramtype">const const_node_ptr &amp;&#160;</td>
          <td class="paramname"><em>source_header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>target_header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cloner&#160;</td>
          <td class="paramname"><em>cloner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Disposer&#160;</td>
          <td class="paramname"><em>disposer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: "cloner" must be a function object taking a node_ptr and returning a new cloned node of it. "disposer" must take a node_ptr and shouldn't throw.</p>
<p><b>Effects</b>: First empties target tree calling <code>void disposer::operator()(const node_ptr &amp;)</code> for every node of the tree except the header.</p>
<p>Then, duplicates the entire tree pointed by "source_header" cloning each source node with <code>node_ptr Cloner::operator()(const node_ptr &amp;)</code> to obtain the nodes of the target tree. If "cloner" throws, the cloned target nodes are disposed using <code>void disposer(const node_ptr &amp;)</code>.</p>
<p><b>Complexity</b>: Linear to the number of element of the source tree plus the number of elements of tree target tree when calling this function.</p>
<p><b>Throws</b>: If cloner functor throws. If this happens target nodes are disposed. </p>

</div>
</div>
<a id="a92e82b6887af90c8dcd343af9b2b804c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e82b6887af90c8dcd343af9b2b804c">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<div class="memtemplate">
template&lt;class KeyType , class KeyNodePtrCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::size_t <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const const_node_ptr &amp;&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyNodePtrCompare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</p>
<p><b>Effects</b>: Returns the number of elements with a key equivalent to "key" according to "comp".</p>
<p><b>Complexity</b>: Logarithmic.</p>
<p><b>Throws</b>: If "comp" throws. </p>

</div>
</div>
<a id="a9b16bd009d4f4ae62b5bc2d72166a015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b16bd009d4f4ae62b5bc2d72166a015">&#9670;&nbsp;</a></span>depth()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::size_t <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::depth </td>
          <td>(</td>
          <td class="paramtype">const_node_ptr&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: 'node' can't be a header node.</p>
<p><b>Effects</b>: Calculates the depth of a node: the depth of a node is the length (number of edges) of the path from the root to that node. (The root node is at depth 0.)</p>
<p><b>Complexity</b>: Logarithmic to the number of nodes in the tree.</p>
<p><b>Throws</b>: Nothing. </p>

</div>
</div>
<a id="a18d81e9a4e18ed37ff825dd6be3780ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18d81e9a4e18ed37ff825dd6be3780ec">&#9670;&nbsp;</a></span>end_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BOOST_INTRUSIVE_FORCEINLINE node_ptr <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::end_node </td>
          <td>(</td>
          <td class="paramtype">const const_node_ptr &amp;&#160;</td>
          <td class="paramname"><em>header</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: 'header' is the header node of a tree.</p>
<p><b>Effects</b>: Returns the header of the tree.</p>
<p><b>Complexity</b>: Constant time.</p>
<p><b>Throws</b>: Nothing. </p>

</div>
</div>
<a id="a06bf1f73e5b2d4d9b77bd32a0a66c2df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06bf1f73e5b2d4d9b77bd32a0a66c2df">&#9670;&nbsp;</a></span>equal_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<div class="memtemplate">
template&lt;class KeyType , class KeyNodePtrCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BOOST_INTRUSIVE_FORCEINLINE std::pair&lt;node_ptr, node_ptr&gt; <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const const_node_ptr &amp;&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyNodePtrCompare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</p>
<p><b>Effects</b>: Returns an a pair of node_ptr delimiting a range containing all elements that are equivalent to "key" according to "comp" or an empty range that indicates the position where those elements would be if there are no equivalent elements.</p>
<p><b>Complexity</b>: Logarithmic.</p>
<p><b>Throws</b>: If "comp" throws. </p>

</div>
</div>
<a id="ad9ba491127d2286a0321839ab6146990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9ba491127d2286a0321839ab6146990">&#9670;&nbsp;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BOOST_INTRUSIVE_FORCEINLINE void <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: header must be the header of a tree, z a node of that tree and z != header.</p>
<p><b>Effects</b>: Erases node "z" from the tree with header "header".</p>
<p><b>Complexity</b>: Amortized constant time.</p>
<p><b>Throws</b>: Nothing. </p>

</div>
</div>
<a id="a3d948878092698fc4c9fdb63e1ccfb3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d948878092698fc4c9fdb63e1ccfb3a">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<div class="memtemplate">
template&lt;class KeyType , class KeyNodePtrCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static node_ptr <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const const_node_ptr &amp;&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyNodePtrCompare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</p>
<p><b>Effects</b>: Returns a node_ptr to the first element that is equivalent to "key" according to "comp" or "header" if that element does not exist.</p>
<p><b>Complexity</b>: Logarithmic.</p>
<p><b>Throws</b>: If "comp" throws. </p>

</div>
</div>
<a id="a9d38aecb00b33895184b66b9de91cade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d38aecb00b33895184b66b9de91cade">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BOOST_INTRUSIVE_FORCEINLINE void <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::init </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: 'node' must not be part of any tree.</p>
<p><b>Effects</b>: After the function unique(node) == true.</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Nodes</b>: If node is inserted in a tree, this function corrupts the tree. </p>

</div>
</div>
<a id="af3934adf1b08e3ce8dbdd32c9c5f1ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3934adf1b08e3ce8dbdd32c9c5f1ee3">&#9670;&nbsp;</a></span>init_header()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BOOST_INTRUSIVE_FORCEINLINE void <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::init_header </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>header</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: node must not be part of any tree.</p>
<p><b>Effects</b>: Initializes the header to represent an empty tree. unique(header) == true.</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Nodes</b>: If node is inserted in a tree, this function corrupts the tree. </p>

</div>
</div>
<a id="adfa16bedbce3e5247321c00a9477207d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa16bedbce3e5247321c00a9477207d">&#9670;&nbsp;</a></span>inited()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BOOST_INTRUSIVE_FORCEINLINE bool <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::inited </td>
          <td>(</td>
          <td class="paramtype">const const_node_ptr &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Effects</b>: Returns true if node is in the same state as if called init(node)</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Throws</b>: Nothing. </p>

</div>
</div>
<a id="a6735224506d05a000c46d1bae9f333d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6735224506d05a000c46d1bae9f333d4">&#9670;&nbsp;</a></span>insert_before()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static node_ptr <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::insert_before </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>new_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t *&#160;</td>
          <td class="paramname"><em>pdepth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: "header" must be the header node of a tree. "pos" must be a valid iterator or header (end) node. "pos" must be an iterator pointing to the successor to "new_node" once inserted according to the order of already inserted nodes. This function does not check "pos" and this precondition must be guaranteed by the caller.</p>
<p><b>Effects</b>: Inserts new_node into the tree before "pos".</p>
<p><b>Complexity</b>: Constant-time.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Note</b>: If "pos" is not the successor of the newly inserted "new_node" tree invariants might be broken. </p>

</div>
</div>
<a id="afe3f637ae3a06ef0ed85e932368d4038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe3f637ae3a06ef0ed85e932368d4038">&#9670;&nbsp;</a></span>insert_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<div class="memtemplate">
template&lt;class NodePtrCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static node_ptr <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::insert_equal </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>new_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodePtrCompare&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t *&#160;</td>
          <td class="paramname"><em>pdepth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: "header" must be the header node of a tree. NodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares two node_ptrs. "hint" is node from the "header"'s tree.</p>
<p><b>Effects</b>: Inserts new_node into the tree, using "hint" as a hint to where it will be inserted. If "hint" is the upper_bound the insertion takes constant time (two comparisons in the worst case).</p>
<p><b>Complexity</b>: Logarithmic in general, but it is amortized constant time if new_node is inserted immediately before "hint".</p>
<p><b>Throws</b>: If "comp" throws. </p>

</div>
</div>
<a id="a480df863207c07ad24b594c32a49db27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a480df863207c07ad24b594c32a49db27">&#9670;&nbsp;</a></span>insert_equal_lower_bound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<div class="memtemplate">
template&lt;class NodePtrCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static node_ptr <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::insert_equal_lower_bound </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>new_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodePtrCompare&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t *&#160;</td>
          <td class="paramname"><em>pdepth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: "h" must be the header node of a tree. NodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares two node_ptrs.</p>
<p><b>Effects</b>: Inserts new_node into the tree before the lower bound according to "comp".</p>
<p><b>Complexity</b>: Average complexity for insert element is at most logarithmic.</p>
<p><b>Throws</b>: If "comp" throws. </p>

</div>
</div>
<a id="a4576b97ce5bbad8417de1e73f66a7738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4576b97ce5bbad8417de1e73f66a7738">&#9670;&nbsp;</a></span>insert_equal_upper_bound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<div class="memtemplate">
template&lt;class NodePtrCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static node_ptr <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::insert_equal_upper_bound </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>new_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodePtrCompare&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t *&#160;</td>
          <td class="paramname"><em>pdepth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: "h" must be the header node of a tree. NodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares two node_ptrs.</p>
<p><b>Effects</b>: Inserts new_node into the tree before the upper bound according to "comp".</p>
<p><b>Complexity</b>: Average complexity for insert element is at most logarithmic.</p>
<p><b>Throws</b>: If "comp" throws. </p>

</div>
</div>
<a id="a43c24171a162cd8f528f2dbbc2f73e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c24171a162cd8f528f2dbbc2f73e09">&#9670;&nbsp;</a></span>insert_unique_check() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<div class="memtemplate">
template&lt;class KeyType , class KeyNodePtrCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::pair&lt;node_ptr, bool&gt; <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::insert_unique_check </td>
          <td>(</td>
          <td class="paramtype">const const_node_ptr &amp;&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyNodePtrCompare&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">insert_commit_data &amp;&#160;</td>
          <td class="paramname"><em>commit_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t *&#160;</td>
          <td class="paramname"><em>pdepth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares KeyType with a node_ptr.</p>
<p><b>Effects</b>: Checks if there is an equivalent node to "key" in the tree according to "comp" and obtains the needed information to realize a constant-time node insertion if there is no equivalent node.</p>
<p><b>Returns</b>: If there is an equivalent value returns a pair containing a node_ptr to the already present node and false. If there is not equivalent key can be inserted returns true in the returned pair's boolean and fills "commit_data" that is meant to be used with the "insert_commit" function to achieve a constant-time insertion function.</p>
<p><b>Complexity</b>: Average complexity is at most logarithmic.</p>
<p><b>Throws</b>: If "comp" throws.</p>
<p><b>Notes</b>: This function is used to improve performance when constructing a node is expensive and the user does not want to have two equivalent nodes in the tree: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the node and this function offers the possibility to use that part to check if the insertion will be successful.</p>
<p>If the check is successful, the user can construct the node and use "insert_commit" to insert the node in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</p>
<p>"commit_data" remains valid for a subsequent "insert_unique_commit" only if no more objects are inserted or erased from the set. </p>

</div>
</div>
<a id="a40e9b650d0b7a105505924f9b5c9b650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40e9b650d0b7a105505924f9b5c9b650">&#9670;&nbsp;</a></span>insert_unique_check() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<div class="memtemplate">
template&lt;class KeyType , class KeyNodePtrCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::pair&lt;node_ptr, bool&gt; <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::insert_unique_check </td>
          <td>(</td>
          <td class="paramtype">const const_node_ptr &amp;&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const node_ptr &amp;&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyNodePtrCompare&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">insert_commit_data &amp;&#160;</td>
          <td class="paramname"><em>commit_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t *&#160;</td>
          <td class="paramname"><em>pdepth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares KeyType with a node_ptr. "hint" is node from the "header"'s tree.</p>
<p><b>Effects</b>: Checks if there is an equivalent node to "key" in the tree according to "comp" using "hint" as a hint to where it should be inserted and obtains the needed information to realize a constant-time node insertion if there is no equivalent node. If "hint" is the upper_bound the function has constant time complexity (two comparisons in the worst case).</p>
<p><b>Returns</b>: If there is an equivalent value returns a pair containing a node_ptr to the already present node and false. If there is not equivalent key can be inserted returns true in the returned pair's boolean and fills "commit_data" that is meant to be used with the "insert_commit" function to achieve a constant-time insertion function.</p>
<p><b>Complexity</b>: Average complexity is at most logarithmic, but it is amortized constant time if new_node should be inserted immediately before "hint".</p>
<p><b>Throws</b>: If "comp" throws.</p>
<p><b>Notes</b>: This function is used to improve performance when constructing a node is expensive and the user does not want to have two equivalent nodes in the tree: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the node and this function offers the possibility to use that part to check if the insertion will be successful.</p>
<p>If the check is successful, the user can construct the node and use "insert_commit" to insert the node in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</p>
<p>"commit_data" remains valid for a subsequent "insert_unique_commit" only if no more objects are inserted or erased from the set. </p>

</div>
</div>
<a id="aff2709751dd8286203f972edb0c35f98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2709751dd8286203f972edb0c35f98">&#9670;&nbsp;</a></span>insert_unique_commit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BOOST_INTRUSIVE_FORCEINLINE void <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::insert_unique_commit </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>new_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const insert_commit_data &amp;&#160;</td>
          <td class="paramname"><em>commit_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: "header" must be the header node of a tree. "commit_data" must have been obtained from a previous call to "insert_unique_check". No objects should have been inserted or erased from the set between the "insert_unique_check" that filled "commit_data" and the call to "insert_commit".</p>
<p><b>Effects</b>: Inserts new_node in the set using the information obtained from the "commit_data" that a previous "insert_check" filled.</p>
<p><b>Complexity</b>: Constant time.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Notes</b>: This function has only sense if a "insert_unique_check" has been previously executed to fill "commit_data". No value should be inserted or erased between the "insert_check" and "insert_commit" calls. </p>

</div>
</div>
<a id="a0a6933a07facaf7a1a75ddbee1e0f41d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a6933a07facaf7a1a75ddbee1e0f41d">&#9670;&nbsp;</a></span>is_left_child()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BOOST_INTRUSIVE_FORCEINLINE bool <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::is_left_child </td>
          <td>(</td>
          <td class="paramtype">const node_ptr &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: p is a node of a tree.</p>
<p><b>Effects</b>: Returns true if p is a left child.</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Throws</b>: Nothing. </p>

</div>
</div>
<a id="ae7f230346da62cfadf7079529a460654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7f230346da62cfadf7079529a460654">&#9670;&nbsp;</a></span>is_right_child()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BOOST_INTRUSIVE_FORCEINLINE bool <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::is_right_child </td>
          <td>(</td>
          <td class="paramtype">const node_ptr &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: p is a node of a tree.</p>
<p><b>Effects</b>: Returns true if p is a right child.</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Throws</b>: Nothing. </p>

</div>
</div>
<a id="a9d094812366967052b7570011e9a64be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d094812366967052b7570011e9a64be">&#9670;&nbsp;</a></span>lower_bound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<div class="memtemplate">
template&lt;class KeyType , class KeyNodePtrCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BOOST_INTRUSIVE_FORCEINLINE node_ptr <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const const_node_ptr &amp;&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyNodePtrCompare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</p>
<p><b>Effects</b>: Returns a node_ptr to the first element that is not less than "key" according to "comp" or "header" if that element does not exist.</p>
<p><b>Complexity</b>: Logarithmic.</p>
<p><b>Throws</b>: If "comp" throws. </p>

</div>
</div>
<a id="a454624d956cc1a958f5f9489e667f4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a454624d956cc1a958f5f9489e667f4a2">&#9670;&nbsp;</a></span>lower_bound_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<div class="memtemplate">
template&lt;class KeyType , class KeyNodePtrCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::pair&lt;node_ptr, node_ptr&gt; <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::lower_bound_range </td>
          <td>(</td>
          <td class="paramtype">const const_node_ptr &amp;&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyNodePtrCompare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</p>
<p><b>Effects</b>: Returns an a pair of node_ptr delimiting a range containing the first element that is equivalent to "key" according to "comp" or an empty range that indicates the position where that element would be if there are no equivalent elements.</p>
<p><b>Complexity</b>: Logarithmic.</p>
<p><b>Throws</b>: If "comp" throws. </p>

</div>
</div>
<a id="a5a59d215532dcfd3f190b1b4477da301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a59d215532dcfd3f190b1b4477da301">&#9670;&nbsp;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>new_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t *&#160;</td>
          <td class="paramname"><em>pdepth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: "header" must be the header node of a tree. "new_node" must be, according to the used ordering no less than the greatest inserted key.</p>
<p><b>Effects</b>: Inserts new_node into the tree before "pos".</p>
<p><b>Complexity</b>: Constant-time.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Note</b>: If "new_node" is less than the greatest inserted key tree invariants are broken. This function is slightly faster than using "insert_before". </p>

</div>
</div>
<a id="aa4fa0c51707b3921f0c3b8a979a812da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4fa0c51707b3921f0c3b8a979a812da">&#9670;&nbsp;</a></span>push_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>new_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t *&#160;</td>
          <td class="paramname"><em>pdepth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: "header" must be the header node of a tree. "new_node" must be, according to the used ordering, no greater than the lowest inserted key.</p>
<p><b>Effects</b>: Inserts new_node into the tree before "pos".</p>
<p><b>Complexity</b>: Constant-time.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Note</b>: If "new_node" is greater than the lowest inserted key tree invariants are broken. This function is slightly faster than using "insert_before". </p>

</div>
</div>
<a id="a3dfa34ba424c5cfb7bfb4cec1d35fa74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dfa34ba424c5cfb7bfb4cec1d35fa74">&#9670;&nbsp;</a></span>rebalance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::rebalance </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>header</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: header must be the header of a tree.</p>
<p><b>Effects</b>: Rebalances the tree.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Complexity</b>: Linear. </p>

</div>
</div>
<a id="a402c1bd70bcb147401fd2bbaae564c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a402c1bd70bcb147401fd2bbaae564c3f">&#9670;&nbsp;</a></span>rebalance_subtree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static node_ptr <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::rebalance_subtree </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>old_root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: old_root is a node of a tree. It shall not be null.</p>
<p><b>Effects</b>: Rebalances the subtree rooted at old_root.</p>
<p><b>Returns</b>: The new root of the subtree.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Complexity</b>: Linear. </p>

</div>
</div>
<a id="a0b6144ccc5a40401c25d7bde977da862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b6144ccc5a40401c25d7bde977da862">&#9670;&nbsp;</a></span>replace_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::replace_node </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>node_to_be_replaced</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>new_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: node_to_be_replaced must be inserted in a tree with header "header" and new_node must not be inserted in a tree.</p>
<p><b>Effects</b>: Replaces node_to_be_replaced in its position in the tree with new_node. The tree does not need to be rebalanced</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Note</b>: This function will break container ordering invariants if new_node is not equivalent to node_to_be_replaced according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed. Experimental function </p>

</div>
</div>
<a id="a8aaa7efa169ac8d35a3b4701543712f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aaa7efa169ac8d35a3b4701543712f8">&#9670;&nbsp;</a></span>replace_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BOOST_INTRUSIVE_FORCEINLINE void <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::replace_node </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>node_to_be_replaced</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>new_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: node_to_be_replaced must be inserted in a tree and new_node must not be inserted in a tree.</p>
<p><b>Effects</b>: Replaces node_to_be_replaced in its position in the tree with new_node. The tree does not need to be rebalanced</p>
<p><b>Complexity</b>: Logarithmic.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Note</b>: This function will break container ordering invariants if new_node is not equivalent to node_to_be_replaced according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing and comparison is needed. Experimental function </p>

</div>
</div>
<a id="ab838ea8f26371cca42858500da72505e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab838ea8f26371cca42858500da72505e">&#9670;&nbsp;</a></span>root_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BOOST_INTRUSIVE_FORCEINLINE node_ptr <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::root_node </td>
          <td>(</td>
          <td class="paramtype">const const_node_ptr &amp;&#160;</td>
          <td class="paramname"><em>header</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: 'header' is the header node of a tree.</p>
<p><b>Effects</b>: Returns the root of the tree if any, header otherwise</p>
<p><b>Complexity</b>: Constant time.</p>
<p><b>Throws</b>: Nothing. </p>

</div>
</div>
<a id="aa8724b81859e7b262273057159cc94a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8724b81859e7b262273057159cc94a9">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::size_t <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::size </td>
          <td>(</td>
          <td class="paramtype">const const_node_ptr &amp;&#160;</td>
          <td class="paramname"><em>header</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: node is a node of the tree but it's not the header.</p>
<p><b>Effects</b>: Returns the number of nodes of the subtree.</p>
<p><b>Complexity</b>: Linear time.</p>
<p><b>Throws</b>: Nothing. </p>

</div>
</div>
<a id="a3a1c12903737e1008a514b7bf1da6b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a1c12903737e1008a514b7bf1da6b26">&#9670;&nbsp;</a></span>subtree_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::size_t <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::subtree_size </td>
          <td>(</td>
          <td class="paramtype">const const_node_ptr &amp;&#160;</td>
          <td class="paramname"><em>subtree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: node is a node of the tree but it's not the header.</p>
<p><b>Effects</b>: Returns the number of nodes of the subtree.</p>
<p><b>Complexity</b>: Linear time.</p>
<p><b>Throws</b>: Nothing. </p>

</div>
</div>
<a id="a0f944f847babc32f769dfcbb4ca2d328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f944f847babc32f769dfcbb4ca2d328">&#9670;&nbsp;</a></span>swap_nodes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::swap_nodes </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>header1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>node2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>header2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: node1 and node2 can't be header nodes of two trees with header header1 and header2.</p>
<p><b>Effects</b>: Swaps two nodes. After the function node1 will be inserted in the position node2 before the function. node2 will be inserted in the position node1 had before the function.</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Note</b>: This function will break container ordering invariants if node1 and node2 are not equivalent according to the ordering rules.</p>
<p>Experimental function </p>

</div>
</div>
<a id="adaaf1f755df8b4f6ca4d1945fc0e8a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaaf1f755df8b4f6ca4d1945fc0e8a06">&#9670;&nbsp;</a></span>swap_nodes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::swap_nodes </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>node2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: node1 and node2 can't be header nodes of two trees.</p>
<p><b>Effects</b>: Swaps two nodes. After the function node1 will be inserted in the position node2 before the function. node2 will be inserted in the position node1 had before the function.</p>
<p><b>Complexity</b>: Logarithmic.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Note</b>: This function will break container ordering invariants if node1 and node2 are not equivalent according to the ordering rules.</p>
<p>Experimental function </p>

</div>
</div>
<a id="a5acdfee62d8c6958768496111fde0b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5acdfee62d8c6958768496111fde0b8c">&#9670;&nbsp;</a></span>swap_tree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::swap_tree </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>header1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>header2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: header1 and header2 must be the header nodes of two trees.</p>
<p><b>Effects</b>: Swaps two trees. After the function header1 will contain links to the second tree and header2 will have links to the first tree.</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Throws</b>: Nothing. </p>

</div>
</div>
<a id="a9b965e71fa5ea51f8b78dfb4344a856f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b965e71fa5ea51f8b78dfb4344a856f">&#9670;&nbsp;</a></span>transfer_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<div class="memtemplate">
template&lt;class NodePtrCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BOOST_INTRUSIVE_FORCEINLINE void <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::transfer_equal </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>header1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodePtrCompare&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>header2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: header1 and header2 must be the headers of trees tree1 and tree2 respectively, z a non-header node of tree1. NodePtrCompare is the comparison function of tree1..</p>
<p><b>Effects</b>: Transfers node "z" from tree1 to tree2.</p>
<p><b>Complexity</b>: Logarithmic.</p>
<p><b>Throws</b>: If the comparison throws. </p>

</div>
</div>
<a id="abecc400acbfb82498a29896cf16fde6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abecc400acbfb82498a29896cf16fde6e">&#9670;&nbsp;</a></span>transfer_unique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<div class="memtemplate">
template&lt;class NodePtrCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BOOST_INTRUSIVE_FORCEINLINE bool <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::transfer_unique </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>header1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodePtrCompare&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>header2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: header1 and header2 must be the headers of trees tree1 and tree2 respectively, z a non-header node of tree1. NodePtrCompare is the comparison function of tree1..</p>
<p><b>Effects</b>: Transfers node "z" from tree1 to tree2 if tree1 does not contain a node that is equivalent to z.</p>
<p><b>Returns</b>: True if the node was trasferred, false otherwise.</p>
<p><b>Complexity</b>: Logarithmic.</p>
<p><b>Throws</b>: If the comparison throws. </p>

</div>
</div>
<a id="a93e72515913cf5b268e7b751772cb120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e72515913cf5b268e7b751772cb120">&#9670;&nbsp;</a></span>unique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BOOST_INTRUSIVE_FORCEINLINE bool <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::unique </td>
          <td>(</td>
          <td class="paramtype">const const_node_ptr &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: 'node' is a node of the tree or a node initialized by init(...) or init_node.</p>
<p><b>Effects</b>: Returns true if the node is initialized by <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html#a9d38aecb00b33895184b66b9de91cade">init()</a> or init_node().</p>
<p><b>Complexity</b>: Constant time.</p>
<p><b>Throws</b>: Nothing. </p>

</div>
</div>
<a id="a0eb2cd5984a9710795d38a2595caea04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb2cd5984a9710795d38a2595caea04">&#9670;&nbsp;</a></span>unlink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::unlink </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: node is a tree node but not the header.</p>
<p><b>Effects</b>: Unlinks the node and rebalances the tree.</p>
<p><b>Complexity</b>: Average complexity is constant time.</p>
<p><b>Throws</b>: Nothing. </p>

</div>
</div>
<a id="ad018e6d390e6b3f0951ad8efd1a781fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad018e6d390e6b3f0951ad8efd1a781fb">&#9670;&nbsp;</a></span>unlink_leftmost_without_rebalance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static node_ptr <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::unlink_leftmost_without_rebalance </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>header</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: header is the header of a tree.</p>
<p><b>Effects</b>: Unlinks the leftmost node from the tree, and updates the header link to the new leftmost node.</p>
<p><b>Complexity</b>: Average complexity is constant time.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Notes</b>: This function breaks the tree and the tree can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the tree. </p>

</div>
</div>
<a id="a9e89df4bcd55bfa846bb8f408bbb6c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e89df4bcd55bfa846bb8f408bbb6c81">&#9670;&nbsp;</a></span>upper_bound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<div class="memtemplate">
template&lt;class KeyType , class KeyNodePtrCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BOOST_INTRUSIVE_FORCEINLINE node_ptr <a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">boost::intrusive::bstree_algorithms</a>&lt; NodeTraits &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const const_node_ptr &amp;&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyNodePtrCompare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>Requires</b>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</p>
<p><b>Effects</b>: Returns a node_ptr to the first element that is greater than "key" according to "comp" or "header" if that element does not exist.</p>
<p><b>Complexity</b>: Logarithmic.</p>
<p><b>Throws</b>: If "comp" throws. </p>

</div>
</div>
<hr/>このクラス詳解は次のファイルから抽出されました:<ul>
<li>include/external/boost/boost/intrusive/<a class="el" href="bstree__algorithms_8hpp_source.html">bstree_algorithms.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceboost.html">boost</a></li><li class="navelem"><b>intrusive</b></li><li class="navelem"><a class="el" href="classboost_1_1intrusive_1_1bstree__algorithms.html">bstree_algorithms</a></li>
    <li class="footer">構築:
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
