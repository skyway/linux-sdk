<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
<head>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
        'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
        })(window,document,'script','dataLayer','GTM-NN5JX4B');</script>
    <!-- End Google Tag Manager -->
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=11"/>
    <meta name="generator" content="Doxygen 1.9.8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>SkyWay Linux SDK</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="resize.js"></script>
    <script type="text/javascript" src="navtreedata.js"></script>
    <script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="search/searchdata.js"></script>
    <script type="text/javascript" src="search/search.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NN5JX4B"
        height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
            <tbody>
                <tr id="projectrow">
                    <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
                    <td id="projectalign">
                        <div id="projectname">SkyWay Linux SDK
                        </div>
                    </td>
                </tr>
            </tbody>
        </table>
    </div><!-- 構築: Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'検索');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','検索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classboost_1_1beast_1_1basic__flat__buffer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">公開型</a> &#124;
<a href="#pub-methods">公開メンバ関数</a> &#124;
<a href="#friends">フレンド</a> &#124;
<a href="classboost_1_1beast_1_1basic__flat__buffer-members.html">全メンバ一覧</a>  </div>
  <div class="headertitle">
<div class="title">boost::beast::basic_flat_buffer&lt; Allocator &gt; クラステンプレート</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="flat__buffer_8hpp_source.html">flat_buffer.hpp</a>&gt;</code></p>
<div class="dynheader">
boost::beast::basic_flat_buffer&lt; Allocator &gt; の継承関係図</div>
<div class="dyncontent">
 <div class="center">
  <img src="classboost_1_1beast_1_1basic__flat__buffer.png" usemap="#boost::beast::basic_5Fflat_5Fbuffer_3C_20Allocator_20_3E_map" alt=""/>
  <map id="boost::beast::basic_5Fflat_5Fbuffer_3C_20Allocator_20_3E_map" name="boost::beast::basic_5Fflat_5Fbuffer_3C_20Allocator_20_3E_map">
<area href="classboost_1_1empty___1_1empty__value.html" alt="boost::empty_::empty_value&lt; T, N, E &gt;" shape="rect" coords="0,0,560,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
公開型</h2></td></tr>
<tr class="memitem:af9bc60f05624b61b01f0bd1fb14eba61"><td class="memItemLeft" align="right" valign="top"><a id="af9bc60f05624b61b01f0bd1fb14eba61"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#af9bc60f05624b61b01f0bd1fb14eba61">allocator_type</a> = Allocator</td></tr>
<tr class="memdesc:af9bc60f05624b61b01f0bd1fb14eba61"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of allocator used. <br /></td></tr>
<tr class="separator:af9bc60f05624b61b01f0bd1fb14eba61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775c96864a8b53cebd233ec783601533"><td class="memItemLeft" align="right" valign="top"><a id="a775c96864a8b53cebd233ec783601533"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a775c96864a8b53cebd233ec783601533">const_buffers_type</a> = <a class="el" href="classboost_1_1asio_1_1const__buffer.html">net::const_buffer</a></td></tr>
<tr class="memdesc:a775c96864a8b53cebd233ec783601533"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ConstBufferSequence used to represent the readable bytes. <br /></td></tr>
<tr class="separator:a775c96864a8b53cebd233ec783601533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03faa4f310bf6407d51b3855ec1bc626"><td class="memItemLeft" align="right" valign="top"><a id="a03faa4f310bf6407d51b3855ec1bc626"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a03faa4f310bf6407d51b3855ec1bc626">mutable_buffers_type</a> = <a class="el" href="classboost_1_1asio_1_1mutable__buffer.html">net::mutable_buffer</a></td></tr>
<tr class="memdesc:a03faa4f310bf6407d51b3855ec1bc626"><td class="mdescLeft">&#160;</td><td class="mdescRight">The MutableBufferSequence used to represent the writable bytes. <br /></td></tr>
<tr class="separator:a03faa4f310bf6407d51b3855ec1bc626"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
公開メンバ関数</h2></td></tr>
<tr class="memitem:a9ef1f971e4f05d97cc5e30ca0c9614af"><td class="memItemLeft" align="right" valign="top"><a id="a9ef1f971e4f05d97cc5e30ca0c9614af"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a9ef1f971e4f05d97cc5e30ca0c9614af">~basic_flat_buffer</a> ()</td></tr>
<tr class="memdesc:a9ef1f971e4f05d97cc5e30ca0c9614af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor <br /></td></tr>
<tr class="separator:a9ef1f971e4f05d97cc5e30ca0c9614af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e07bc47f7d7e187de8163d3eae593b8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a5e07bc47f7d7e187de8163d3eae593b8">basic_flat_buffer</a> () noexcept(default_nothrow)</td></tr>
<tr class="separator:a5e07bc47f7d7e187de8163d3eae593b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd0fe3a889b8611e11dcd051333d047"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#abfd0fe3a889b8611e11dcd051333d047">basic_flat_buffer</a> (std::size_t limit) noexcept(default_nothrow)</td></tr>
<tr class="separator:abfd0fe3a889b8611e11dcd051333d047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8881f701e69db28542cfb0026cfe7049"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a8881f701e69db28542cfb0026cfe7049">basic_flat_buffer</a> (Allocator const &amp;alloc) noexcept</td></tr>
<tr class="separator:a8881f701e69db28542cfb0026cfe7049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb504cd35ac3e8e6d05a93ba73f07a5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a2cb504cd35ac3e8e6d05a93ba73f07a5">basic_flat_buffer</a> (std::size_t limit, Allocator const &amp;alloc) noexcept</td></tr>
<tr class="separator:a2cb504cd35ac3e8e6d05a93ba73f07a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb17dc9ecaf629724fa43ca1296216b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#adb17dc9ecaf629724fa43ca1296216b2">basic_flat_buffer</a> (<a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">basic_flat_buffer</a> &amp;&amp;other) noexcept</td></tr>
<tr class="separator:adb17dc9ecaf629724fa43ca1296216b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f462d24e27b67795044fc8d89ce638e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a5f462d24e27b67795044fc8d89ce638e">basic_flat_buffer</a> (<a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">basic_flat_buffer</a> &amp;&amp;other, Allocator const &amp;alloc)</td></tr>
<tr class="separator:a5f462d24e27b67795044fc8d89ce638e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe42d610a65c68c56e5b22ad83915e60"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#abe42d610a65c68c56e5b22ad83915e60">basic_flat_buffer</a> (<a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">basic_flat_buffer</a> const &amp;other)</td></tr>
<tr class="separator:abe42d610a65c68c56e5b22ad83915e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6369c1d38d86b190456cd8966b484366"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a6369c1d38d86b190456cd8966b484366">basic_flat_buffer</a> (<a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">basic_flat_buffer</a> const &amp;other, Allocator const &amp;alloc)</td></tr>
<tr class="separator:a6369c1d38d86b190456cd8966b484366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfec38a6e62636222a9ec06aa2015c20"><td class="memTemplParams" colspan="2">template&lt;class OtherAlloc &gt; </td></tr>
<tr class="memitem:adfec38a6e62636222a9ec06aa2015c20"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#adfec38a6e62636222a9ec06aa2015c20">basic_flat_buffer</a> (<a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">basic_flat_buffer</a>&lt; OtherAlloc &gt; const &amp;other) noexcept(default_nothrow)</td></tr>
<tr class="separator:adfec38a6e62636222a9ec06aa2015c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37db211965c35a990e76349cd2548a38"><td class="memTemplParams" colspan="2">template&lt;class OtherAlloc &gt; </td></tr>
<tr class="memitem:a37db211965c35a990e76349cd2548a38"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a37db211965c35a990e76349cd2548a38">basic_flat_buffer</a> (<a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">basic_flat_buffer</a>&lt; OtherAlloc &gt; const &amp;other, Allocator const &amp;alloc)</td></tr>
<tr class="separator:a37db211965c35a990e76349cd2548a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a2fdc6ed1f8d5502a4ce29a6e66216"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">basic_flat_buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a26a2fdc6ed1f8d5502a4ce29a6e66216">operator=</a> (<a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">basic_flat_buffer</a> &amp;&amp;other) noexcept</td></tr>
<tr class="separator:a26a2fdc6ed1f8d5502a4ce29a6e66216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506ea65053948273c8bcd6db755b07b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">basic_flat_buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a506ea65053948273c8bcd6db755b07b1">operator=</a> (<a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">basic_flat_buffer</a> const &amp;other)</td></tr>
<tr class="separator:a506ea65053948273c8bcd6db755b07b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10dbbd6c980d6f6c3ef0c402395615cc"><td class="memTemplParams" colspan="2">template&lt;class OtherAlloc &gt; </td></tr>
<tr class="memitem:a10dbbd6c980d6f6c3ef0c402395615cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">basic_flat_buffer</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a10dbbd6c980d6f6c3ef0c402395615cc">operator=</a> (<a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">basic_flat_buffer</a>&lt; OtherAlloc &gt; const &amp;other)</td></tr>
<tr class="separator:a10dbbd6c980d6f6c3ef0c402395615cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1b8753644b1d4599a3b1ee37426213"><td class="memItemLeft" align="right" valign="top"><a id="a7e1b8753644b1d4599a3b1ee37426213"></a>
<a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#af9bc60f05624b61b01f0bd1fb14eba61">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a7e1b8753644b1d4599a3b1ee37426213">get_allocator</a> () const</td></tr>
<tr class="memdesc:a7e1b8753644b1d4599a3b1ee37426213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the allocator used. <br /></td></tr>
<tr class="separator:a7e1b8753644b1d4599a3b1ee37426213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044e4022c19b6957a524557221278100"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a044e4022c19b6957a524557221278100">max_size</a> (std::size_t n) noexcept</td></tr>
<tr class="separator:a044e4022c19b6957a524557221278100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affbbd92d11c8a76de9a6bfdba6771088"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#affbbd92d11c8a76de9a6bfdba6771088">reserve</a> (std::size_t n)</td></tr>
<tr class="separator:affbbd92d11c8a76de9a6bfdba6771088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5a36f1728ba27978f9c63942475638"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#aaa5a36f1728ba27978f9c63942475638">shrink_to_fit</a> () noexcept</td></tr>
<tr class="separator:aaa5a36f1728ba27978f9c63942475638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76bb49fbe5ba1596b2157e57496aa574"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a76bb49fbe5ba1596b2157e57496aa574">clear</a> () noexcept</td></tr>
<tr class="separator:a76bb49fbe5ba1596b2157e57496aa574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5602a8b3a3f921c85697b633d6cbb9af"><td class="memItemLeft" align="right" valign="top"><a id="a5602a8b3a3f921c85697b633d6cbb9af"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a5602a8b3a3f921c85697b633d6cbb9af">size</a> () const noexcept</td></tr>
<tr class="memdesc:a5602a8b3a3f921c85697b633d6cbb9af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of readable bytes. <br /></td></tr>
<tr class="separator:a5602a8b3a3f921c85697b633d6cbb9af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b18e27e214b809d594457cf6c834c94"><td class="memItemLeft" align="right" valign="top"><a id="a1b18e27e214b809d594457cf6c834c94"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a1b18e27e214b809d594457cf6c834c94">max_size</a> () const noexcept</td></tr>
<tr class="memdesc:a1b18e27e214b809d594457cf6c834c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum number of bytes, both readable and writable, that can ever be held. <br /></td></tr>
<tr class="separator:a1b18e27e214b809d594457cf6c834c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d97358ecd8fd7241b2665b58a25334f"><td class="memItemLeft" align="right" valign="top"><a id="a7d97358ecd8fd7241b2665b58a25334f"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a7d97358ecd8fd7241b2665b58a25334f">capacity</a> () const noexcept</td></tr>
<tr class="memdesc:a7d97358ecd8fd7241b2665b58a25334f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum number of bytes, both readable and writable, that can be held without requiring an allocation. <br /></td></tr>
<tr class="separator:a7d97358ecd8fd7241b2665b58a25334f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2788a14a6e41b000cb6950e2f9e3fa"><td class="memItemLeft" align="right" valign="top"><a id="acf2788a14a6e41b000cb6950e2f9e3fa"></a>
<a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a775c96864a8b53cebd233ec783601533">const_buffers_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#acf2788a14a6e41b000cb6950e2f9e3fa">data</a> () const noexcept</td></tr>
<tr class="memdesc:acf2788a14a6e41b000cb6950e2f9e3fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant buffer sequence representing the readable bytes <br /></td></tr>
<tr class="separator:acf2788a14a6e41b000cb6950e2f9e3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952cb33d8c9eda8090e074f655aaba97"><td class="memItemLeft" align="right" valign="top"><a id="a952cb33d8c9eda8090e074f655aaba97"></a>
<a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a775c96864a8b53cebd233ec783601533">const_buffers_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a952cb33d8c9eda8090e074f655aaba97">cdata</a> () const noexcept</td></tr>
<tr class="memdesc:a952cb33d8c9eda8090e074f655aaba97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant buffer sequence representing the readable bytes <br /></td></tr>
<tr class="separator:a952cb33d8c9eda8090e074f655aaba97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbd586b9a2e220b35d45948669328c2"><td class="memItemLeft" align="right" valign="top"><a id="afbbd586b9a2e220b35d45948669328c2"></a>
<a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a03faa4f310bf6407d51b3855ec1bc626">mutable_buffers_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#afbbd586b9a2e220b35d45948669328c2">data</a> () noexcept</td></tr>
<tr class="memdesc:afbbd586b9a2e220b35d45948669328c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable buffer sequence representing the readable bytes <br /></td></tr>
<tr class="separator:afbbd586b9a2e220b35d45948669328c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fce6694fd2c0fb303d11cc9504145b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a03faa4f310bf6407d51b3855ec1bc626">mutable_buffers_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a2fce6694fd2c0fb303d11cc9504145b0">prepare</a> (std::size_t n)</td></tr>
<tr class="separator:a2fce6694fd2c0fb303d11cc9504145b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d941e070be2625c1d8347dfc0187c8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a2d941e070be2625c1d8347dfc0187c8c">commit</a> (std::size_t n) noexcept</td></tr>
<tr class="separator:a2d941e070be2625c1d8347dfc0187c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ea3b56ffbb776680b132d9129d5b60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#ac5ea3b56ffbb776680b132d9129d5b60">consume</a> (std::size_t n) noexcept</td></tr>
<tr class="separator:ac5ea3b56ffbb776680b132d9129d5b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f12cbcb514ac63410fae7d6f0a3396"><td class="memTemplParams" colspan="2"><a id="af7f12cbcb514ac63410fae7d6f0a3396"></a>
template&lt;class OtherAlloc &gt; </td></tr>
<tr class="memitem:af7f12cbcb514ac63410fae7d6f0a3396"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">basic_flat_buffer</a>&lt; OtherAlloc &gt; const &amp;other) -&gt; <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">basic_flat_buffer</a> &amp;</td></tr>
<tr class="separator:af7f12cbcb514ac63410fae7d6f0a3396"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
フレンド</h2></td></tr>
<tr class="memitem:aa2fef003ab4081838b2b311a7b6e521f"><td class="memTemplParams" colspan="2"><a id="aa2fef003ab4081838b2b311a7b6e521f"></a>
template&lt;class Alloc &gt; </td></tr>
<tr class="memitem:aa2fef003ab4081838b2b311a7b6e521f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#aa2fef003ab4081838b2b311a7b6e521f">swap</a> (<a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">basic_flat_buffer</a>&lt; Alloc &gt; &amp;, <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">basic_flat_buffer</a>&lt; Alloc &gt; &amp;)</td></tr>
<tr class="memdesc:aa2fef003ab4081838b2b311a7b6e521f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchange two dynamic buffers <br /></td></tr>
<tr class="separator:aa2fef003ab4081838b2b311a7b6e521f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">詳解</h2>
<div class="textblock"><h3>template&lt;class Allocator&gt;<br />
class boost::beast::basic_flat_buffer&lt; Allocator &gt;</h3>

<p>A dynamic buffer providing buffer sequences of length one.</p>
<p>A dynamic buffer encapsulates memory storage that may be automatically resized as required, where the memory is divided into two regions: readable bytes followed by writable bytes. These memory regions are internal to the dynamic buffer, but direct access to the elements is provided to permit them to be efficiently used with I/O operations.</p>
<p>Objects of this type meet the requirements of <em>DynamicBuffer</em> and have the following additional properties:</p>
<ul>
<li>A mutable buffer sequence representing the readable bytes is returned by <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#acf2788a14a6e41b000cb6950e2f9e3fa">data</a> when <code>this</code> is non-const.</li>
</ul>
<ul>
<li>A configurable maximum buffer size may be set upon construction. Attempts to exceed the buffer size will throw <code>std::length_error</code>.</li>
</ul>
<ul>
<li>Buffer sequences representing the readable and writable bytes, returned by <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#acf2788a14a6e41b000cb6950e2f9e3fa">data</a> and <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a2fce6694fd2c0fb303d11cc9504145b0">prepare</a>, will have length one.</li>
</ul>
<p>Upon construction, a maximum size for the buffer may be specified. If this limit is exceeded, the <code>std::length_error</code> exception will be thrown.</p>
<dl class="section note"><dt>覚え書き</dt><dd>This class is designed for use with algorithms that take dynamic buffers as parameters, and are optimized for the case where the input sequence or output sequence is stored in a single contiguous buffer. </dd></dl>
</div><h2 class="groupheader">構築子と解体子</h2>
<a id="a5e07bc47f7d7e187de8163d3eae593b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e07bc47f7d7e187de8163d3eae593b8">&#9670;&nbsp;</a></span>basic_flat_buffer() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">boost::beast::basic_flat_buffer</a>&lt; Allocator &gt;::<a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">basic_flat_buffer</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor</p>
<p>After construction, <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a7d97358ecd8fd7241b2665b58a25334f">capacity</a> will return zero, and <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a044e4022c19b6957a524557221278100">max_size</a> will return the largest value which may be passed to the allocator's <code>allocate</code> function. </p>

</div>
</div>
<a id="abfd0fe3a889b8611e11dcd051333d047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd0fe3a889b8611e11dcd051333d047">&#9670;&nbsp;</a></span>basic_flat_buffer() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">boost::beast::basic_flat_buffer</a>&lt; Allocator &gt;::<a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">basic_flat_buffer</a> </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>limit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor</p>
<p>After construction, <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a7d97358ecd8fd7241b2665b58a25334f">capacity</a> will return zero, and <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a044e4022c19b6957a524557221278100">max_size</a> will return the specified value of <code>limit</code>.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">limit</td><td>The desired maximum size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8881f701e69db28542cfb0026cfe7049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8881f701e69db28542cfb0026cfe7049">&#9670;&nbsp;</a></span>basic_flat_buffer() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">boost::beast::basic_flat_buffer</a>&lt; Allocator &gt;::<a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">basic_flat_buffer</a> </td>
          <td>(</td>
          <td class="paramtype">Allocator const &amp;&#160;</td>
          <td class="paramname"><em>alloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor</p>
<p>After construction, <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a7d97358ecd8fd7241b2665b58a25334f">capacity</a> will return zero, and <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a044e4022c19b6957a524557221278100">max_size</a> will return the largest value which may be passed to the allocator's <code>allocate</code> function.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>The allocator to use for the object.</td></tr>
  </table>
  </dd>
</dl>
<p>@esafe</p>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="a2cb504cd35ac3e8e6d05a93ba73f07a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb504cd35ac3e8e6d05a93ba73f07a5">&#9670;&nbsp;</a></span>basic_flat_buffer() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">boost::beast::basic_flat_buffer</a>&lt; Allocator &gt;::<a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">basic_flat_buffer</a> </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator const &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor</p>
<p>After construction, <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a7d97358ecd8fd7241b2665b58a25334f">capacity</a> will return zero, and <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a044e4022c19b6957a524557221278100">max_size</a> will return the specified value of <code>limit</code>.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">limit</td><td>The desired maximum size.</td></tr>
    <tr><td class="paramname">alloc</td><td>The allocator to use for the object.</td></tr>
  </table>
  </dd>
</dl>
<p>@esafe</p>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="adb17dc9ecaf629724fa43ca1296216b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb17dc9ecaf629724fa43ca1296216b2">&#9670;&nbsp;</a></span>basic_flat_buffer() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">boost::beast::basic_flat_buffer</a>&lt; Allocator &gt;::<a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">basic_flat_buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">basic_flat_buffer</a>&lt; Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move Constructor</p>
<p>The container is constructed with the contents of <code>other</code> using move semantics. The maximum size will be the same as the moved-from object.</p>
<p>Buffer sequences previously obtained from <code>other</code> using <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#acf2788a14a6e41b000cb6950e2f9e3fa">data</a> or <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a2fce6694fd2c0fb303d11cc9504145b0">prepare</a> remain valid after the move.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The object to move from. After the move, the moved-from object will have zero capacity, zero readable bytes, and zero writable bytes.</td></tr>
  </table>
  </dd>
</dl>
<p>@esafe</p>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="a5f462d24e27b67795044fc8d89ce638e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f462d24e27b67795044fc8d89ce638e">&#9670;&nbsp;</a></span>basic_flat_buffer() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">boost::beast::basic_flat_buffer</a>&lt; Allocator &gt;::<a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">basic_flat_buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">basic_flat_buffer</a>&lt; Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator const &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move Constructor</p>
<p>Using <code>alloc</code> as the allocator for the new container, the contents of <code>other</code> are moved. If <code>alloc != other.get_allocator()</code>, this results in a copy. The maximum size will be the same as the moved-from object.</p>
<p>Buffer sequences previously obtained from <code>other</code> using <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#acf2788a14a6e41b000cb6950e2f9e3fa">data</a> or <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a2fce6694fd2c0fb303d11cc9504145b0">prepare</a> become invalid after the move.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The object to move from. After the move, the moved-from object will have zero capacity, zero readable bytes, and zero writable bytes.</td></tr>
    <tr><td class="paramname">alloc</td><td>The allocator to use for the object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if <code>other.size()</code> exceeds the maximum allocation size of <code>alloc</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe42d610a65c68c56e5b22ad83915e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe42d610a65c68c56e5b22ad83915e60">&#9670;&nbsp;</a></span>basic_flat_buffer() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">boost::beast::basic_flat_buffer</a>&lt; Allocator &gt;::<a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">basic_flat_buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">basic_flat_buffer</a>&lt; Allocator &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy Constructor</p>
<p>This container is constructed with the contents of <code>other</code> using copy semantics. The maximum size will be the same as the copied object.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The object to copy from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if <code>other.size()</code> exceeds the maximum allocation size of the allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6369c1d38d86b190456cd8966b484366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6369c1d38d86b190456cd8966b484366">&#9670;&nbsp;</a></span>basic_flat_buffer() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">boost::beast::basic_flat_buffer</a>&lt; Allocator &gt;::<a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">basic_flat_buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">basic_flat_buffer</a>&lt; Allocator &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator const &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy Constructor</p>
<p>This container is constructed with the contents of <code>other</code> using copy semantics and the specified allocator. The maximum size will be the same as the copied object.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The object to copy from.</td></tr>
    <tr><td class="paramname">alloc</td><td>The allocator to use for the object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if <code>other.size()</code> exceeds the maximum allocation size of <code>alloc</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfec38a6e62636222a9ec06aa2015c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfec38a6e62636222a9ec06aa2015c20">&#9670;&nbsp;</a></span>basic_flat_buffer() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class OtherAlloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">boost::beast::basic_flat_buffer</a>&lt; Allocator &gt;::<a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">basic_flat_buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">basic_flat_buffer</a>&lt; OtherAlloc &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy Constructor</p>
<p>This container is constructed with the contents of <code>other</code> using copy semantics. The maximum size will be the same as the copied object.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The object to copy from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if <code>other.size()</code> exceeds the maximum allocation size of the allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37db211965c35a990e76349cd2548a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37db211965c35a990e76349cd2548a38">&#9670;&nbsp;</a></span>basic_flat_buffer() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class OtherAlloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">boost::beast::basic_flat_buffer</a>&lt; Allocator &gt;::<a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">basic_flat_buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">basic_flat_buffer</a>&lt; OtherAlloc &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator const &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy Constructor</p>
<p>This container is constructed with the contents of <code>other</code> using copy semantics. The maximum size will be the same as the copied object.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The object to copy from.</td></tr>
    <tr><td class="paramname">alloc</td><td>The allocator to use for the object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if <code>other.size()</code> exceeds the maximum allocation size of <code>alloc</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">関数詳解</h2>
<a id="a76bb49fbe5ba1596b2157e57496aa574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76bb49fbe5ba1596b2157e57496aa574">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">boost::beast::basic_flat_buffer</a>&lt; Allocator &gt;::clear</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the size of the readable and writable bytes to zero.</p>
<p>This clears the buffer without changing capacity. Buffer sequences previously obtained using <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#acf2788a14a6e41b000cb6950e2f9e3fa">data</a> or <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a2fce6694fd2c0fb303d11cc9504145b0">prepare</a> become invalid.</p>
<p>@esafe</p>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="a2d941e070be2625c1d8347dfc0187c8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d941e070be2625c1d8347dfc0187c8c">&#9670;&nbsp;</a></span>commit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">boost::beast::basic_flat_buffer</a>&lt; Allocator &gt;::commit </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Append writable bytes to the readable bytes.</p>
<p>Appends n bytes from the start of the writable bytes to the end of the readable bytes. The remainder of the writable bytes are discarded. If n is greater than the number of writable bytes, all writable bytes are appended to the readable bytes.</p>
<p>All buffers sequences previously obtained using <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#acf2788a14a6e41b000cb6950e2f9e3fa">data</a> or <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a2fce6694fd2c0fb303d11cc9504145b0">prepare</a> become invalid.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of bytes to append. If this number is greater than the number of writable bytes, all writable bytes are appended.</td></tr>
  </table>
  </dd>
</dl>
<p>@esafe</p>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="ac5ea3b56ffbb776680b132d9129d5b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ea3b56ffbb776680b132d9129d5b60">&#9670;&nbsp;</a></span>consume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">boost::beast::basic_flat_buffer</a>&lt; Allocator &gt;::consume </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove bytes from beginning of the readable bytes.</p>
<p>Removes n bytes from the beginning of the readable bytes.</p>
<p>All buffers sequences previously obtained using <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#acf2788a14a6e41b000cb6950e2f9e3fa">data</a> or <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a2fce6694fd2c0fb303d11cc9504145b0">prepare</a> become invalid.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of bytes to remove. If this number is greater than the number of readable bytes, all readable bytes are removed.</td></tr>
  </table>
  </dd>
</dl>
<p>@esafe</p>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="a044e4022c19b6957a524557221278100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044e4022c19b6957a524557221278100">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">boost::beast::basic_flat_buffer</a>&lt; Allocator &gt;::max_size </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the maximum allowed capacity</p>
<p>This function changes the currently configured upper limit on capacity to the specified value.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The maximum number of bytes ever allowed for capacity.</td></tr>
  </table>
  </dd>
</dl>
<p>@esafe</p>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="a26a2fdc6ed1f8d5502a4ce29a6e66216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26a2fdc6ed1f8d5502a4ce29a6e66216">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">boost::beast::basic_flat_buffer</a>&lt; Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">basic_flat_buffer</a>&lt; Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move Assignment</p>
<p>The container is assigned with the contents of <code>other</code> using move semantics. The maximum size will be the same as the moved-from object.</p>
<p>Buffer sequences previously obtained from <code>other</code> using <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#acf2788a14a6e41b000cb6950e2f9e3fa">data</a> or <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a2fce6694fd2c0fb303d11cc9504145b0">prepare</a> remain valid after the move.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The object to move from. After the move, the moved-from object will have zero capacity, zero readable bytes, and zero writable bytes.</td></tr>
  </table>
  </dd>
</dl>
<p>@esafe</p>
<p>No-throw guarantee. </p>

</div>
</div>
<a id="a506ea65053948273c8bcd6db755b07b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a506ea65053948273c8bcd6db755b07b1">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">boost::beast::basic_flat_buffer</a>&lt; Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">basic_flat_buffer</a>&lt; Allocator &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy Assignment</p>
<p>The container is assigned with the contents of <code>other</code> using copy semantics. The maximum size will be the same as the copied object.</p>
<p>After the copy, <code>this</code> will have zero writable bytes.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The object to copy from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if <code>other.size()</code> exceeds the maximum allocation size of the allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a10dbbd6c980d6f6c3ef0c402395615cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10dbbd6c980d6f6c3ef0c402395615cc">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class OtherAlloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">basic_flat_buffer</a>&amp; <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">boost::beast::basic_flat_buffer</a>&lt; Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">basic_flat_buffer</a>&lt; OtherAlloc &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy assignment</p>
<p>The container is assigned with the contents of <code>other</code> using copy semantics. The maximum size will be the same as the copied object.</p>
<p>After the copy, <code>this</code> will have zero writable bytes.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The object to copy from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if <code>other.size()</code> exceeds the maximum allocation size of the allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2fce6694fd2c0fb303d11cc9504145b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fce6694fd2c0fb303d11cc9504145b0">&#9670;&nbsp;</a></span>prepare()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">boost::beast::basic_flat_buffer</a>&lt; Allocator &gt;::prepare </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a mutable buffer sequence representing writable bytes.</p>
<p>Returns a mutable buffer sequence representing the writable bytes containing exactly <code>n</code> bytes of storage. Memory may be reallocated as needed.</p>
<p>All buffers sequences previously obtained using <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#acf2788a14a6e41b000cb6950e2f9e3fa">data</a> or <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a2fce6694fd2c0fb303d11cc9504145b0">prepare</a> become invalid.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The desired number of bytes in the returned buffer sequence.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if <code><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a5602a8b3a3f921c85697b633d6cbb9af" title="Returns the number of readable bytes.">size()</a> + n</code> exceeds either <code><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a044e4022c19b6957a524557221278100">max_size()</a></code> or the allocator's maximum allocation size.</td></tr>
  </table>
  </dd>
</dl>
<p>@esafe</p>
<p>Strong guarantee. </p>

</div>
</div>
<a id="affbbd92d11c8a76de9a6bfdba6771088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affbbd92d11c8a76de9a6bfdba6771088">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">boost::beast::basic_flat_buffer</a>&lt; Allocator &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Guarantee a minimum capacity</p>
<p>This function adjusts the internal storage (if necessary) to guarantee space for at least <code>n</code> bytes.</p>
<p>Buffer sequences previously obtained using <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#acf2788a14a6e41b000cb6950e2f9e3fa">data</a> or <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a2fce6694fd2c0fb303d11cc9504145b0">prepare</a> become invalid.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The minimum number of byte for the new capacity. If this value is greater than the maximum size, then the maximum size will be adjusted upwards to this value.</td></tr>
  </table>
  </dd>
</dl>
<p>@esafe</p>
<p>Basic guarantee.</p>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if n is larger than the maximum allocation size of the allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa5a36f1728ba27978f9c63942475638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa5a36f1728ba27978f9c63942475638">&#9670;&nbsp;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">boost::beast::basic_flat_buffer</a>&lt; Allocator &gt;::shrink_to_fit</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Request the removal of unused capacity.</p>
<p>This function attempts to reduce <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a7d97358ecd8fd7241b2665b58a25334f">capacity()</a> to <a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html#a5602a8b3a3f921c85697b633d6cbb9af">size()</a>, which may not succeed.</p>
<p>@esafe</p>
<p>No-throw guarantee. </p>

</div>
</div>
<hr/>このクラス詳解は次のファイルから抽出されました:<ul>
<li>include/external/boost/boost/beast/core/<a class="el" href="flat__buffer_8hpp_source.html">flat_buffer.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceboost.html">boost</a></li><li class="navelem"><b>beast</b></li><li class="navelem"><a class="el" href="classboost_1_1beast_1_1basic__flat__buffer.html">basic_flat_buffer</a></li>
    <li class="footer">構築:
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
