<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
<head>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
        'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
        })(window,document,'script','dataLayer','GTM-NN5JX4B');</script>
    <!-- End Google Tag Manager -->
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=11"/>
    <meta name="generator" content="Doxygen 1.9.8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>SkyWay Linux SDK</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="resize.js"></script>
    <script type="text/javascript" src="navtreedata.js"></script>
    <script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="search/searchdata.js"></script>
    <script type="text/javascript" src="search/search.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NN5JX4B"
        height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
            <tbody>
                <tr id="projectrow">
                    <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
                    <td id="projectalign">
                        <div id="projectname">SkyWay Linux SDK
                        </div>
                    </td>
                </tr>
            </tbody>
        </table>
    </div><!-- 構築: Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'検索');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','検索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('predicate_8hpp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">名前空間</a> &#124;
<a href="#func-members">関数</a>  </div>
  <div class="headertitle">
<div class="title">predicate.hpp ファイル</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;iterator&gt;</code><br />
<code>#include &lt;boost/algorithm/string/config.hpp&gt;</code><br />
<code>#include &lt;boost/range/begin.hpp&gt;</code><br />
<code>#include &lt;boost/range/end.hpp&gt;</code><br />
<code>#include &lt;boost/range/iterator.hpp&gt;</code><br />
<code>#include &lt;boost/range/const_iterator.hpp&gt;</code><br />
<code>#include &lt;boost/range/as_literal.hpp&gt;</code><br />
<code>#include &lt;<a class="el" href="iterator__range__core_8hpp_source.html">boost/range/iterator_range_core.hpp</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="compare_8hpp_source.html">boost/algorithm/string/compare.hpp</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="algorithm_2string_2find_8hpp_source.html">boost/algorithm/string/find.hpp</a>&gt;</code><br />
<code>#include &lt;boost/algorithm/string/detail/predicate.hpp&gt;</code><br />
</div>
<p><a href="predicate_8hpp_source.html">[ソースコード]</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
名前空間</h2></td></tr>
<tr class="memitem:namespaceboost"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost.html">boost</a></td></tr>
<tr class="memdesc:namespaceboost"><td class="mdescLeft">&#160;</td><td class="mdescRight">defined(BOOST_MOVE_DOXYGEN_INVOKED) <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
関数</h2></td></tr>
<tr class="memitem:a8bd43e694e6202b357abee9deffe9ade"><td class="memTemplParams" colspan="2">template&lt;typename Range1T , typename Range2T , typename PredicateT &gt; </td></tr>
<tr class="memitem:a8bd43e694e6202b357abee9deffe9ade"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="predicate_8hpp.html#a8bd43e694e6202b357abee9deffe9ade">boost::algorithm::starts_with</a> (const Range1T &amp;Input, const Range2T &amp;Test, PredicateT Comp)</td></tr>
<tr class="memdesc:a8bd43e694e6202b357abee9deffe9ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">'Starts with' predicate  <a href="predicate_8hpp.html#a8bd43e694e6202b357abee9deffe9ade">[詳解]</a><br /></td></tr>
<tr class="separator:a8bd43e694e6202b357abee9deffe9ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b2fecf83180440803ee7681e280390"><td class="memTemplParams" colspan="2">template&lt;typename Range1T , typename Range2T &gt; </td></tr>
<tr class="memitem:a48b2fecf83180440803ee7681e280390"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="predicate_8hpp.html#a48b2fecf83180440803ee7681e280390">boost::algorithm::starts_with</a> (const Range1T &amp;Input, const Range2T &amp;Test)</td></tr>
<tr class="memdesc:a48b2fecf83180440803ee7681e280390"><td class="mdescLeft">&#160;</td><td class="mdescRight">'Starts with' predicate  <a href="predicate_8hpp.html#a48b2fecf83180440803ee7681e280390">[詳解]</a><br /></td></tr>
<tr class="separator:a48b2fecf83180440803ee7681e280390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754936c071b73fd2fbf90696a95c2bf7"><td class="memTemplParams" colspan="2">template&lt;typename Range1T , typename Range2T &gt; </td></tr>
<tr class="memitem:a754936c071b73fd2fbf90696a95c2bf7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="predicate_8hpp.html#a754936c071b73fd2fbf90696a95c2bf7">boost::algorithm::istarts_with</a> (const Range1T &amp;Input, const Range2T &amp;Test, const std::locale &amp;Loc=std::locale())</td></tr>
<tr class="memdesc:a754936c071b73fd2fbf90696a95c2bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">'Starts with' predicate ( case insensitive )  <a href="predicate_8hpp.html#a754936c071b73fd2fbf90696a95c2bf7">[詳解]</a><br /></td></tr>
<tr class="separator:a754936c071b73fd2fbf90696a95c2bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29350a2b35157e9f7d474815244540d7"><td class="memTemplParams" colspan="2">template&lt;typename Range1T , typename Range2T , typename PredicateT &gt; </td></tr>
<tr class="memitem:a29350a2b35157e9f7d474815244540d7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="predicate_8hpp.html#a29350a2b35157e9f7d474815244540d7">boost::algorithm::ends_with</a> (const Range1T &amp;Input, const Range2T &amp;Test, PredicateT Comp)</td></tr>
<tr class="memdesc:a29350a2b35157e9f7d474815244540d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">'Ends with' predicate  <a href="predicate_8hpp.html#a29350a2b35157e9f7d474815244540d7">[詳解]</a><br /></td></tr>
<tr class="separator:a29350a2b35157e9f7d474815244540d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28768adfb6dcd23737853ede3fc7658a"><td class="memTemplParams" colspan="2">template&lt;typename Range1T , typename Range2T &gt; </td></tr>
<tr class="memitem:a28768adfb6dcd23737853ede3fc7658a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="predicate_8hpp.html#a28768adfb6dcd23737853ede3fc7658a">boost::algorithm::ends_with</a> (const Range1T &amp;Input, const Range2T &amp;Test)</td></tr>
<tr class="memdesc:a28768adfb6dcd23737853ede3fc7658a"><td class="mdescLeft">&#160;</td><td class="mdescRight">'Ends with' predicate  <a href="predicate_8hpp.html#a28768adfb6dcd23737853ede3fc7658a">[詳解]</a><br /></td></tr>
<tr class="separator:a28768adfb6dcd23737853ede3fc7658a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123041d82b0b20788aa5fbd13c892e2d"><td class="memTemplParams" colspan="2">template&lt;typename Range1T , typename Range2T &gt; </td></tr>
<tr class="memitem:a123041d82b0b20788aa5fbd13c892e2d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="predicate_8hpp.html#a123041d82b0b20788aa5fbd13c892e2d">boost::algorithm::iends_with</a> (const Range1T &amp;Input, const Range2T &amp;Test, const std::locale &amp;Loc=std::locale())</td></tr>
<tr class="memdesc:a123041d82b0b20788aa5fbd13c892e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">'Ends with' predicate ( case insensitive )  <a href="predicate_8hpp.html#a123041d82b0b20788aa5fbd13c892e2d">[詳解]</a><br /></td></tr>
<tr class="separator:a123041d82b0b20788aa5fbd13c892e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea40974228db77cc0189545b6db42623"><td class="memTemplParams" colspan="2">template&lt;typename Range1T , typename Range2T , typename PredicateT &gt; </td></tr>
<tr class="memitem:aea40974228db77cc0189545b6db42623"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="predicate_8hpp.html#aea40974228db77cc0189545b6db42623">boost::algorithm::contains</a> (const Range1T &amp;Input, const Range2T &amp;Test, PredicateT Comp)</td></tr>
<tr class="memdesc:aea40974228db77cc0189545b6db42623"><td class="mdescLeft">&#160;</td><td class="mdescRight">'Contains' predicate  <a href="predicate_8hpp.html#aea40974228db77cc0189545b6db42623">[詳解]</a><br /></td></tr>
<tr class="separator:aea40974228db77cc0189545b6db42623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a192511c45feb8065a3019545d6667240"><td class="memTemplParams" colspan="2">template&lt;typename Range1T , typename Range2T &gt; </td></tr>
<tr class="memitem:a192511c45feb8065a3019545d6667240"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="predicate_8hpp.html#a192511c45feb8065a3019545d6667240">boost::algorithm::contains</a> (const Range1T &amp;Input, const Range2T &amp;Test)</td></tr>
<tr class="memdesc:a192511c45feb8065a3019545d6667240"><td class="mdescLeft">&#160;</td><td class="mdescRight">'Contains' predicate  <a href="predicate_8hpp.html#a192511c45feb8065a3019545d6667240">[詳解]</a><br /></td></tr>
<tr class="separator:a192511c45feb8065a3019545d6667240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d00c06a5c29059549ab2b603829688a"><td class="memTemplParams" colspan="2">template&lt;typename Range1T , typename Range2T &gt; </td></tr>
<tr class="memitem:a1d00c06a5c29059549ab2b603829688a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="predicate_8hpp.html#a1d00c06a5c29059549ab2b603829688a">boost::algorithm::icontains</a> (const Range1T &amp;Input, const Range2T &amp;Test, const std::locale &amp;Loc=std::locale())</td></tr>
<tr class="memdesc:a1d00c06a5c29059549ab2b603829688a"><td class="mdescLeft">&#160;</td><td class="mdescRight">'Contains' predicate ( case insensitive )  <a href="predicate_8hpp.html#a1d00c06a5c29059549ab2b603829688a">[詳解]</a><br /></td></tr>
<tr class="separator:a1d00c06a5c29059549ab2b603829688a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae725b4746b62fd5a852813902fbe76e5"><td class="memTemplParams" colspan="2">template&lt;typename Range1T , typename Range2T , typename PredicateT &gt; </td></tr>
<tr class="memitem:ae725b4746b62fd5a852813902fbe76e5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="predicate_8hpp.html#ae725b4746b62fd5a852813902fbe76e5">boost::algorithm::equals</a> (const Range1T &amp;Input, const Range2T &amp;Test, PredicateT Comp)</td></tr>
<tr class="memdesc:ae725b4746b62fd5a852813902fbe76e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">'Equals' predicate  <a href="predicate_8hpp.html#ae725b4746b62fd5a852813902fbe76e5">[詳解]</a><br /></td></tr>
<tr class="separator:ae725b4746b62fd5a852813902fbe76e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebe1b30026fbc351e2f08e52ad62584"><td class="memTemplParams" colspan="2">template&lt;typename Range1T , typename Range2T &gt; </td></tr>
<tr class="memitem:a2ebe1b30026fbc351e2f08e52ad62584"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="predicate_8hpp.html#a2ebe1b30026fbc351e2f08e52ad62584">boost::algorithm::equals</a> (const Range1T &amp;Input, const Range2T &amp;Test)</td></tr>
<tr class="memdesc:a2ebe1b30026fbc351e2f08e52ad62584"><td class="mdescLeft">&#160;</td><td class="mdescRight">'Equals' predicate  <a href="predicate_8hpp.html#a2ebe1b30026fbc351e2f08e52ad62584">[詳解]</a><br /></td></tr>
<tr class="separator:a2ebe1b30026fbc351e2f08e52ad62584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ed65a727f35ef0bb27bec3eecfe177"><td class="memTemplParams" colspan="2">template&lt;typename Range1T , typename Range2T &gt; </td></tr>
<tr class="memitem:aa4ed65a727f35ef0bb27bec3eecfe177"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="predicate_8hpp.html#aa4ed65a727f35ef0bb27bec3eecfe177">boost::algorithm::iequals</a> (const Range1T &amp;Input, const Range2T &amp;Test, const std::locale &amp;Loc=std::locale())</td></tr>
<tr class="memdesc:aa4ed65a727f35ef0bb27bec3eecfe177"><td class="mdescLeft">&#160;</td><td class="mdescRight">'Equals' predicate ( case insensitive )  <a href="predicate_8hpp.html#aa4ed65a727f35ef0bb27bec3eecfe177">[詳解]</a><br /></td></tr>
<tr class="separator:aa4ed65a727f35ef0bb27bec3eecfe177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d5eded5f0480ead2fc9b454ebdc5af"><td class="memTemplParams" colspan="2">template&lt;typename Range1T , typename Range2T , typename PredicateT &gt; </td></tr>
<tr class="memitem:ae0d5eded5f0480ead2fc9b454ebdc5af"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="predicate_8hpp.html#ae0d5eded5f0480ead2fc9b454ebdc5af">boost::algorithm::lexicographical_compare</a> (const Range1T &amp;Arg1, const Range2T &amp;Arg2, PredicateT Pred)</td></tr>
<tr class="memdesc:ae0d5eded5f0480ead2fc9b454ebdc5af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographical compare predicate  <a href="predicate_8hpp.html#ae0d5eded5f0480ead2fc9b454ebdc5af">[詳解]</a><br /></td></tr>
<tr class="separator:ae0d5eded5f0480ead2fc9b454ebdc5af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b68190a4653da5e458313b4741c3e9"><td class="memTemplParams" colspan="2">template&lt;typename Range1T , typename Range2T &gt; </td></tr>
<tr class="memitem:a60b68190a4653da5e458313b4741c3e9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="predicate_8hpp.html#a60b68190a4653da5e458313b4741c3e9">boost::algorithm::lexicographical_compare</a> (const Range1T &amp;Arg1, const Range2T &amp;Arg2)</td></tr>
<tr class="memdesc:a60b68190a4653da5e458313b4741c3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographical compare predicate  <a href="predicate_8hpp.html#a60b68190a4653da5e458313b4741c3e9">[詳解]</a><br /></td></tr>
<tr class="separator:a60b68190a4653da5e458313b4741c3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56ef3671cb8f7eaca746ebaf80c182b"><td class="memTemplParams" colspan="2">template&lt;typename Range1T , typename Range2T &gt; </td></tr>
<tr class="memitem:ac56ef3671cb8f7eaca746ebaf80c182b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="predicate_8hpp.html#ac56ef3671cb8f7eaca746ebaf80c182b">boost::algorithm::ilexicographical_compare</a> (const Range1T &amp;Arg1, const Range2T &amp;Arg2, const std::locale &amp;Loc=std::locale())</td></tr>
<tr class="memdesc:ac56ef3671cb8f7eaca746ebaf80c182b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographical compare predicate (case-insensitive)  <a href="predicate_8hpp.html#ac56ef3671cb8f7eaca746ebaf80c182b">[詳解]</a><br /></td></tr>
<tr class="separator:ac56ef3671cb8f7eaca746ebaf80c182b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b634f662d43fcbc5fbe52fa29e1886"><td class="memTemplParams" colspan="2">template&lt;typename RangeT , typename PredicateT &gt; </td></tr>
<tr class="memitem:a02b634f662d43fcbc5fbe52fa29e1886"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="predicate_8hpp.html#a02b634f662d43fcbc5fbe52fa29e1886">boost::algorithm::all</a> (const RangeT &amp;Input, PredicateT Pred)</td></tr>
<tr class="memdesc:a02b634f662d43fcbc5fbe52fa29e1886"><td class="mdescLeft">&#160;</td><td class="mdescRight">'All' predicate  <a href="predicate_8hpp.html#a02b634f662d43fcbc5fbe52fa29e1886">[詳解]</a><br /></td></tr>
<tr class="separator:a02b634f662d43fcbc5fbe52fa29e1886"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">詳解</h2>
<div class="textblock"><p>Defines string-related predicates. The predicates determine whether a substring is contained in the input string under various conditions: a string starts with the substring, ends with the substring, simply contains the substring or if both strings are equal. Additionaly the algorithm <code><a class="el" href="predicate_8hpp.html#a02b634f662d43fcbc5fbe52fa29e1886" title="&#39;All&#39; predicate">all()</a></code> checks all elements of a container to satisfy a condition.</p>
<p>All predicates provide the strong exception guarantee. </p>
</div><h2 class="groupheader">関数詳解</h2>
<a id="a02b634f662d43fcbc5fbe52fa29e1886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02b634f662d43fcbc5fbe52fa29e1886">&#9670;&nbsp;</a></span>all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT , typename PredicateT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::algorithm::all </td>
          <td>(</td>
          <td class="paramtype">const RangeT &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PredicateT&#160;</td>
          <td class="paramname"><em>Pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>'All' predicate </p>
<p>This predicate holds it all its elements satisfy a given condition, represented by the predicate.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>An input sequence </td></tr>
    <tr><td class="paramname">Pred</td><td>A predicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The result of the test</dd></dl>
<dl class="section note"><dt>覚え書き</dt><dd>This function provides the strong exception-safety guarantee </dd></dl>

</div>
</div>
<a id="a192511c45feb8065a3019545d6667240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a192511c45feb8065a3019545d6667240">&#9670;&nbsp;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range1T , typename Range2T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::algorithm::contains </td>
          <td>(</td>
          <td class="paramtype">const Range1T &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range2T &amp;&#160;</td>
          <td class="paramname"><em>Test</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>'Contains' predicate </p>
<p>これはオーバーロードされたメンバ関数です。利便性のために用意されています。元の関数との違いは引き数のみです。 </p>

</div>
</div>
<a id="aea40974228db77cc0189545b6db42623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea40974228db77cc0189545b6db42623">&#9670;&nbsp;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range1T , typename Range2T , typename PredicateT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::algorithm::contains </td>
          <td>(</td>
          <td class="paramtype">const Range1T &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range2T &amp;&#160;</td>
          <td class="paramname"><em>Test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PredicateT&#160;</td>
          <td class="paramname"><em>Comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>'Contains' predicate </p>
<p>This predicate holds when the test container is contained in the Input. When the optional predicate is specified, it is used for character-wise comparison.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>An input sequence </td></tr>
    <tr><td class="paramname">Test</td><td>A test sequence </td></tr>
    <tr><td class="paramname">Comp</td><td>An element comparison predicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The result of the test</dd></dl>
<dl class="section note"><dt>覚え書き</dt><dd>This function provides the strong exception-safety guarantee </dd></dl>

</div>
</div>
<a id="a28768adfb6dcd23737853ede3fc7658a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28768adfb6dcd23737853ede3fc7658a">&#9670;&nbsp;</a></span>ends_with() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range1T , typename Range2T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::algorithm::ends_with </td>
          <td>(</td>
          <td class="paramtype">const Range1T &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range2T &amp;&#160;</td>
          <td class="paramname"><em>Test</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>'Ends with' predicate </p>
<p>これはオーバーロードされたメンバ関数です。利便性のために用意されています。元の関数との違いは引き数のみです。 </p>

</div>
</div>
<a id="a29350a2b35157e9f7d474815244540d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29350a2b35157e9f7d474815244540d7">&#9670;&nbsp;</a></span>ends_with() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range1T , typename Range2T , typename PredicateT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::algorithm::ends_with </td>
          <td>(</td>
          <td class="paramtype">const Range1T &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range2T &amp;&#160;</td>
          <td class="paramname"><em>Test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PredicateT&#160;</td>
          <td class="paramname"><em>Comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>'Ends with' predicate </p>
<p>This predicate holds when the test string is a suffix of the Input. In other words, if the input ends with the test. When the optional predicate is specified, it is used for character-wise comparison.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>An input sequence </td></tr>
    <tr><td class="paramname">Test</td><td>A test sequence </td></tr>
    <tr><td class="paramname">Comp</td><td>An element comparison predicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The result of the test</dd></dl>
<dl class="section note"><dt>覚え書き</dt><dd>This function provides the strong exception-safety guarantee </dd></dl>

</div>
</div>
<a id="a2ebe1b30026fbc351e2f08e52ad62584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ebe1b30026fbc351e2f08e52ad62584">&#9670;&nbsp;</a></span>equals() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range1T , typename Range2T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::algorithm::equals </td>
          <td>(</td>
          <td class="paramtype">const Range1T &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range2T &amp;&#160;</td>
          <td class="paramname"><em>Test</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>'Equals' predicate </p>
<p>これはオーバーロードされたメンバ関数です。利便性のために用意されています。元の関数との違いは引き数のみです。 </p>

</div>
</div>
<a id="ae725b4746b62fd5a852813902fbe76e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae725b4746b62fd5a852813902fbe76e5">&#9670;&nbsp;</a></span>equals() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range1T , typename Range2T , typename PredicateT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::algorithm::equals </td>
          <td>(</td>
          <td class="paramtype">const Range1T &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range2T &amp;&#160;</td>
          <td class="paramname"><em>Test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PredicateT&#160;</td>
          <td class="paramname"><em>Comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>'Equals' predicate </p>
<p>This predicate holds when the test container is equal to the input container i.e. all elements in both containers are same. When the optional predicate is specified, it is used for character-wise comparison.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>An input sequence </td></tr>
    <tr><td class="paramname">Test</td><td>A test sequence </td></tr>
    <tr><td class="paramname">Comp</td><td>An element comparison predicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The result of the test</dd></dl>
<dl class="section note"><dt>覚え書き</dt><dd>This is a two-way version of <code>std::equal</code> algorithm</dd>
<dd>
This function provides the strong exception-safety guarantee </dd></dl>

</div>
</div>
<a id="a1d00c06a5c29059549ab2b603829688a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d00c06a5c29059549ab2b603829688a">&#9670;&nbsp;</a></span>icontains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range1T , typename Range2T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::algorithm::icontains </td>
          <td>(</td>
          <td class="paramtype">const Range1T &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range2T &amp;&#160;</td>
          <td class="paramname"><em>Test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::locale &amp;&#160;</td>
          <td class="paramname"><em>Loc</em> = <code>std::locale()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>'Contains' predicate ( case insensitive ) </p>
<p>This predicate holds when the test container is contained in the Input. Elements are compared case insensitively.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>An input sequence </td></tr>
    <tr><td class="paramname">Test</td><td>A test sequence </td></tr>
    <tr><td class="paramname">Loc</td><td>A locale used for case insensitive comparison </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The result of the test</dd></dl>
<dl class="section note"><dt>覚え書き</dt><dd>This function provides the strong exception-safety guarantee </dd></dl>

</div>
</div>
<a id="a123041d82b0b20788aa5fbd13c892e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a123041d82b0b20788aa5fbd13c892e2d">&#9670;&nbsp;</a></span>iends_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range1T , typename Range2T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::algorithm::iends_with </td>
          <td>(</td>
          <td class="paramtype">const Range1T &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range2T &amp;&#160;</td>
          <td class="paramname"><em>Test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::locale &amp;&#160;</td>
          <td class="paramname"><em>Loc</em> = <code>std::locale()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>'Ends with' predicate ( case insensitive ) </p>
<p>This predicate holds when the test container is a suffix of the Input. In other words, if the input ends with the test. Elements are compared case insensitively.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>An input sequence </td></tr>
    <tr><td class="paramname">Test</td><td>A test sequence </td></tr>
    <tr><td class="paramname">Loc</td><td>A locale used for case insensitive comparison </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The result of the test</dd></dl>
<dl class="section note"><dt>覚え書き</dt><dd>This function provides the strong exception-safety guarantee </dd></dl>

</div>
</div>
<a id="aa4ed65a727f35ef0bb27bec3eecfe177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4ed65a727f35ef0bb27bec3eecfe177">&#9670;&nbsp;</a></span>iequals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range1T , typename Range2T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::algorithm::iequals </td>
          <td>(</td>
          <td class="paramtype">const Range1T &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range2T &amp;&#160;</td>
          <td class="paramname"><em>Test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::locale &amp;&#160;</td>
          <td class="paramname"><em>Loc</em> = <code>std::locale()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>'Equals' predicate ( case insensitive ) </p>
<p>This predicate holds when the test container is equal to the input container i.e. all elements in both containers are same. Elements are compared case insensitively.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>An input sequence </td></tr>
    <tr><td class="paramname">Test</td><td>A test sequence </td></tr>
    <tr><td class="paramname">Loc</td><td>A locale used for case insensitive comparison </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The result of the test</dd></dl>
<dl class="section note"><dt>覚え書き</dt><dd>This is a two-way version of <code>std::equal</code> algorithm</dd>
<dd>
This function provides the strong exception-safety guarantee </dd></dl>

</div>
</div>
<a id="ac56ef3671cb8f7eaca746ebaf80c182b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac56ef3671cb8f7eaca746ebaf80c182b">&#9670;&nbsp;</a></span>ilexicographical_compare()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range1T , typename Range2T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::algorithm::ilexicographical_compare </td>
          <td>(</td>
          <td class="paramtype">const Range1T &amp;&#160;</td>
          <td class="paramname"><em>Arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range2T &amp;&#160;</td>
          <td class="paramname"><em>Arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::locale &amp;&#160;</td>
          <td class="paramname"><em>Loc</em> = <code>std::locale()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lexicographical compare predicate (case-insensitive) </p>
<p>This predicate is an overload of std::lexicographical_compare for range arguments. It check whether the first argument is lexicographically less then the second one. Elements are compared case insensitively</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Arg1</td><td>First argument </td></tr>
    <tr><td class="paramname">Arg2</td><td>Second argument </td></tr>
    <tr><td class="paramname">Loc</td><td>A locale used for case insensitive comparison </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The result of the test</dd></dl>
<dl class="section note"><dt>覚え書き</dt><dd>This function provides the strong exception-safety guarantee </dd></dl>

</div>
</div>
<a id="a754936c071b73fd2fbf90696a95c2bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754936c071b73fd2fbf90696a95c2bf7">&#9670;&nbsp;</a></span>istarts_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range1T , typename Range2T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::algorithm::istarts_with </td>
          <td>(</td>
          <td class="paramtype">const Range1T &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range2T &amp;&#160;</td>
          <td class="paramname"><em>Test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::locale &amp;&#160;</td>
          <td class="paramname"><em>Loc</em> = <code>std::locale()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>'Starts with' predicate ( case insensitive ) </p>
<p>This predicate holds when the test string is a prefix of the Input. In other words, if the input starts with the test. Elements are compared case insensitively.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>An input sequence </td></tr>
    <tr><td class="paramname">Test</td><td>A test sequence </td></tr>
    <tr><td class="paramname">Loc</td><td>A locale used for case insensitive comparison </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The result of the test</dd></dl>
<dl class="section note"><dt>覚え書き</dt><dd>This function provides the strong exception-safety guarantee </dd></dl>

</div>
</div>
<a id="a60b68190a4653da5e458313b4741c3e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60b68190a4653da5e458313b4741c3e9">&#9670;&nbsp;</a></span>lexicographical_compare() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range1T , typename Range2T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::algorithm::lexicographical_compare </td>
          <td>(</td>
          <td class="paramtype">const Range1T &amp;&#160;</td>
          <td class="paramname"><em>Arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range2T &amp;&#160;</td>
          <td class="paramname"><em>Arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lexicographical compare predicate </p>
<p>これはオーバーロードされたメンバ関数です。利便性のために用意されています。元の関数との違いは引き数のみです。 </p>

</div>
</div>
<a id="ae0d5eded5f0480ead2fc9b454ebdc5af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d5eded5f0480ead2fc9b454ebdc5af">&#9670;&nbsp;</a></span>lexicographical_compare() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range1T , typename Range2T , typename PredicateT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::algorithm::lexicographical_compare </td>
          <td>(</td>
          <td class="paramtype">const Range1T &amp;&#160;</td>
          <td class="paramname"><em>Arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range2T &amp;&#160;</td>
          <td class="paramname"><em>Arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PredicateT&#160;</td>
          <td class="paramname"><em>Pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lexicographical compare predicate </p>
<p>This predicate is an overload of std::lexicographical_compare for range arguments</p>
<p>It check whether the first argument is lexicographically less then the second one.</p>
<p>If the optional predicate is specified, it is used for character-wise comparison</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Arg1</td><td>First argument </td></tr>
    <tr><td class="paramname">Arg2</td><td>Second argument </td></tr>
    <tr><td class="paramname">Pred</td><td>Comparison predicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The result of the test</dd></dl>
<dl class="section note"><dt>覚え書き</dt><dd>This function provides the strong exception-safety guarantee </dd></dl>

</div>
</div>
<a id="a48b2fecf83180440803ee7681e280390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b2fecf83180440803ee7681e280390">&#9670;&nbsp;</a></span>starts_with() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range1T , typename Range2T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::algorithm::starts_with </td>
          <td>(</td>
          <td class="paramtype">const Range1T &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range2T &amp;&#160;</td>
          <td class="paramname"><em>Test</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>'Starts with' predicate </p>
<p>これはオーバーロードされたメンバ関数です。利便性のために用意されています。元の関数との違いは引き数のみです。 </p>

</div>
</div>
<a id="a8bd43e694e6202b357abee9deffe9ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bd43e694e6202b357abee9deffe9ade">&#9670;&nbsp;</a></span>starts_with() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range1T , typename Range2T , typename PredicateT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool boost::algorithm::starts_with </td>
          <td>(</td>
          <td class="paramtype">const Range1T &amp;&#160;</td>
          <td class="paramname"><em>Input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range2T &amp;&#160;</td>
          <td class="paramname"><em>Test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PredicateT&#160;</td>
          <td class="paramname"><em>Comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>'Starts with' predicate </p>
<p>This predicate holds when the test string is a prefix of the Input. In other words, if the input starts with the test. When the optional predicate is specified, it is used for character-wise comparison.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">Input</td><td>An input sequence </td></tr>
    <tr><td class="paramname">Test</td><td>A test sequence </td></tr>
    <tr><td class="paramname">Comp</td><td>An element comparison predicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The result of the test</dd></dl>
<dl class="section note"><dt>覚え書き</dt><dd>This function provides the strong exception-safety guarantee </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_1794b65aa62003e11b03e0565def47fa.html">external</a></li><li class="navelem"><a class="el" href="dir_c08529bcc08f755a4d16428f71043471.html">boost</a></li><li class="navelem"><a class="el" href="dir_08e916b1ba9423845cffef83795e9545.html">boost</a></li><li class="navelem"><a class="el" href="dir_9800f813ecac2c341b3805f88c329233.html">algorithm</a></li><li class="navelem"><a class="el" href="dir_8f2d71a5cad810076374860da5042034.html">string</a></li><li class="navelem"><a class="el" href="predicate_8hpp.html">predicate.hpp</a></li>
    <li class="footer">構築:
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
