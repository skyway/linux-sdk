<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
<head>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
        'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
        })(window,document,'script','dataLayer','GTM-NN5JX4B');</script>
    <!-- End Google Tag Manager -->
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=11"/>
    <meta name="generator" content="Doxygen 1.9.8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>SkyWay Linux SDK</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="resize.js"></script>
    <script type="text/javascript" src="navtreedata.js"></script>
    <script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="search/searchdata.js"></script>
    <script type="text/javascript" src="search/search.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NN5JX4B"
        height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
            <tbody>
                <tr id="projectrow">
                    <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
                    <td id="projectalign">
                        <div id="projectname">SkyWay Linux SDK
                        </div>
                    </td>
                </tr>
            </tbody>
        </table>
    </div><!-- 構築: Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'検索');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','検索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classboost_1_1asio_1_1basic__stream__socket.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">クラス</a> &#124;
<a href="#pub-types">公開型</a> &#124;
<a href="#pub-methods">公開メンバ関数</a> &#124;
<a href="#pub-attribs">公開変数類</a> &#124;
<a href="classboost_1_1asio_1_1basic__stream__socket-members.html">全メンバ一覧</a>  </div>
  <div class="headertitle">
<div class="title">boost::asio::basic_stream_socket&lt; Protocol, Executor &gt; クラステンプレート</div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides stream-oriented socket functionality.  
 <a href="classboost_1_1asio_1_1basic__stream__socket.html#details">[詳解]</a></p>

<p><code>#include &lt;<a class="el" href="basic__stream__socket_8hpp_source.html">basic_stream_socket.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
クラス</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1asio_1_1basic__stream__socket_1_1rebind__executor.html">rebind_executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebinds the socket type to another executor.  <a href="structboost_1_1asio_1_1basic__stream__socket_1_1rebind__executor.html#details">[詳解]</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
公開型</h2></td></tr>
<tr class="memitem:a425b8c8edc06ec1741e51c42bedfed09"><td class="memItemLeft" align="right" valign="top"><a id="a425b8c8edc06ec1741e51c42bedfed09"></a>
typedef Executor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#a425b8c8edc06ec1741e51c42bedfed09">executor_type</a></td></tr>
<tr class="memdesc:a425b8c8edc06ec1741e51c42bedfed09"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the executor associated with the object. <br /></td></tr>
<tr class="separator:a425b8c8edc06ec1741e51c42bedfed09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa383e95d6ccae072417a0125507750bc"><td class="memItemLeft" align="right" valign="top"><a id="aa383e95d6ccae072417a0125507750bc"></a>
typedef <a class="el" href="classboost_1_1asio_1_1basic__socket.html">basic_socket</a>&lt; Protocol, Executor &gt;::<a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#aa383e95d6ccae072417a0125507750bc">native_handle_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#aa383e95d6ccae072417a0125507750bc">native_handle_type</a></td></tr>
<tr class="memdesc:aa383e95d6ccae072417a0125507750bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The native representation of a socket. <br /></td></tr>
<tr class="separator:aa383e95d6ccae072417a0125507750bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede673f876ec45b978cb360974073415"><td class="memItemLeft" align="right" valign="top"><a id="aede673f876ec45b978cb360974073415"></a>
typedef Protocol&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#aede673f876ec45b978cb360974073415">protocol_type</a></td></tr>
<tr class="memdesc:aede673f876ec45b978cb360974073415"><td class="mdescLeft">&#160;</td><td class="mdescRight">The protocol type. <br /></td></tr>
<tr class="separator:aede673f876ec45b978cb360974073415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc4cf21b43db2f9235cc154d37a01c8"><td class="memItemLeft" align="right" valign="top"><a id="aafc4cf21b43db2f9235cc154d37a01c8"></a>
typedef Protocol::endpoint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#aafc4cf21b43db2f9235cc154d37a01c8">endpoint_type</a></td></tr>
<tr class="memdesc:aafc4cf21b43db2f9235cc154d37a01c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The endpoint type. <br /></td></tr>
<tr class="separator:aafc4cf21b43db2f9235cc154d37a01c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
公開メンバ関数</h2></td></tr>
<tr class="memitem:aff01fefa05e301f3bf64cd0ad4f2c70c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#aff01fefa05e301f3bf64cd0ad4f2c70c">basic_stream_socket</a> (const <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#a425b8c8edc06ec1741e51c42bedfed09">executor_type</a> &amp;ex)</td></tr>
<tr class="memdesc:aff01fefa05e301f3bf64cd0ad4f2c70c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html" title="Provides stream-oriented socket functionality.">basic_stream_socket</a> without opening it.  <a href="classboost_1_1asio_1_1basic__stream__socket.html#aff01fefa05e301f3bf64cd0ad4f2c70c">[詳解]</a><br /></td></tr>
<tr class="separator:aff01fefa05e301f3bf64cd0ad4f2c70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd3574354cf9e418766312fe2303045"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext &gt; </td></tr>
<tr class="memitem:a7bd3574354cf9e418766312fe2303045"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#a7bd3574354cf9e418766312fe2303045">basic_stream_socket</a> (ExecutionContext &amp;context, typename <a class="el" href="structboost_1_1asio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structboost_1_1is__convertible.html">is_convertible</a>&lt; ExecutionContext &amp;, <a class="el" href="classboost_1_1asio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;::<a class="el" href="structboost_1_1type.html">type</a> *=0)</td></tr>
<tr class="memdesc:a7bd3574354cf9e418766312fe2303045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html" title="Provides stream-oriented socket functionality.">basic_stream_socket</a> without opening it.  <a href="classboost_1_1asio_1_1basic__stream__socket.html#a7bd3574354cf9e418766312fe2303045">[詳解]</a><br /></td></tr>
<tr class="separator:a7bd3574354cf9e418766312fe2303045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc4bee6043a49626e4c12a8e51ba256"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#abfc4bee6043a49626e4c12a8e51ba256">basic_stream_socket</a> (const <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#a425b8c8edc06ec1741e51c42bedfed09">executor_type</a> &amp;ex, const <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#aede673f876ec45b978cb360974073415">protocol_type</a> &amp;protocol)</td></tr>
<tr class="memdesc:abfc4bee6043a49626e4c12a8e51ba256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and open a <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html" title="Provides stream-oriented socket functionality.">basic_stream_socket</a>.  <a href="classboost_1_1asio_1_1basic__stream__socket.html#abfc4bee6043a49626e4c12a8e51ba256">[詳解]</a><br /></td></tr>
<tr class="separator:abfc4bee6043a49626e4c12a8e51ba256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55bff23492228c56d07a1468d778f57"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext &gt; </td></tr>
<tr class="memitem:aa55bff23492228c56d07a1468d778f57"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#aa55bff23492228c56d07a1468d778f57">basic_stream_socket</a> (ExecutionContext &amp;context, const <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#aede673f876ec45b978cb360974073415">protocol_type</a> &amp;protocol, typename <a class="el" href="structboost_1_1asio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structboost_1_1is__convertible.html">is_convertible</a>&lt; ExecutionContext &amp;, <a class="el" href="classboost_1_1asio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;::<a class="el" href="structboost_1_1type.html">type</a> *=0)</td></tr>
<tr class="memdesc:aa55bff23492228c56d07a1468d778f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and open a <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html" title="Provides stream-oriented socket functionality.">basic_stream_socket</a>.  <a href="classboost_1_1asio_1_1basic__stream__socket.html#aa55bff23492228c56d07a1468d778f57">[詳解]</a><br /></td></tr>
<tr class="separator:aa55bff23492228c56d07a1468d778f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc245bb8d33614ce3383cecbc225746"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#a6dc245bb8d33614ce3383cecbc225746">basic_stream_socket</a> (const <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#a425b8c8edc06ec1741e51c42bedfed09">executor_type</a> &amp;ex, const <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#aafc4cf21b43db2f9235cc154d37a01c8">endpoint_type</a> &amp;endpoint)</td></tr>
<tr class="separator:a6dc245bb8d33614ce3383cecbc225746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cdcb828d9115423a7e2a3d8d15ad38e"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext &gt; </td></tr>
<tr class="memitem:a1cdcb828d9115423a7e2a3d8d15ad38e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#a1cdcb828d9115423a7e2a3d8d15ad38e">basic_stream_socket</a> (ExecutionContext &amp;context, const <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#aafc4cf21b43db2f9235cc154d37a01c8">endpoint_type</a> &amp;endpoint, typename <a class="el" href="structboost_1_1asio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structboost_1_1is__convertible.html">is_convertible</a>&lt; ExecutionContext &amp;, <a class="el" href="classboost_1_1asio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;::<a class="el" href="structboost_1_1type.html">type</a> *=0)</td></tr>
<tr class="separator:a1cdcb828d9115423a7e2a3d8d15ad38e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8570e9aa8184aac92ca0a8f3a9fc57"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#a3d8570e9aa8184aac92ca0a8f3a9fc57">basic_stream_socket</a> (const <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#a425b8c8edc06ec1741e51c42bedfed09">executor_type</a> &amp;ex, const <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#aede673f876ec45b978cb360974073415">protocol_type</a> &amp;protocol, const <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#aa383e95d6ccae072417a0125507750bc">native_handle_type</a> &amp;native_socket)</td></tr>
<tr class="memdesc:a3d8570e9aa8184aac92ca0a8f3a9fc57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html" title="Provides stream-oriented socket functionality.">basic_stream_socket</a> on an existing native socket.  <a href="classboost_1_1asio_1_1basic__stream__socket.html#a3d8570e9aa8184aac92ca0a8f3a9fc57">[詳解]</a><br /></td></tr>
<tr class="separator:a3d8570e9aa8184aac92ca0a8f3a9fc57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ba37c78bf160d027456e77b3710e9c"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext &gt; </td></tr>
<tr class="memitem:a42ba37c78bf160d027456e77b3710e9c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#a42ba37c78bf160d027456e77b3710e9c">basic_stream_socket</a> (ExecutionContext &amp;context, const <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#aede673f876ec45b978cb360974073415">protocol_type</a> &amp;protocol, const <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#aa383e95d6ccae072417a0125507750bc">native_handle_type</a> &amp;native_socket, typename <a class="el" href="structboost_1_1asio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structboost_1_1is__convertible.html">is_convertible</a>&lt; ExecutionContext &amp;, <a class="el" href="classboost_1_1asio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;::<a class="el" href="structboost_1_1type.html">type</a> *=0)</td></tr>
<tr class="memdesc:a42ba37c78bf160d027456e77b3710e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html" title="Provides stream-oriented socket functionality.">basic_stream_socket</a> on an existing native socket.  <a href="classboost_1_1asio_1_1basic__stream__socket.html#a42ba37c78bf160d027456e77b3710e9c">[詳解]</a><br /></td></tr>
<tr class="separator:a42ba37c78bf160d027456e77b3710e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07cc8e0a1249bb3e0a68dd55dfc2a517"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#a07cc8e0a1249bb3e0a68dd55dfc2a517">~basic_stream_socket</a> ()</td></tr>
<tr class="memdesc:a07cc8e0a1249bb3e0a68dd55dfc2a517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the socket.  <a href="classboost_1_1asio_1_1basic__stream__socket.html#a07cc8e0a1249bb3e0a68dd55dfc2a517">[詳解]</a><br /></td></tr>
<tr class="separator:a07cc8e0a1249bb3e0a68dd55dfc2a517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d47cc2bc565c7bf295e471a1c0849ca"><td class="memTemplParams" colspan="2">template&lt;typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:a9d47cc2bc565c7bf295e471a1c0849ca"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#a9d47cc2bc565c7bf295e471a1c0849ca">send</a> (const ConstBufferSequence &amp;buffers)</td></tr>
<tr class="memdesc:a9d47cc2bc565c7bf295e471a1c0849ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send some data on the socket.  <a href="classboost_1_1asio_1_1basic__stream__socket.html#a9d47cc2bc565c7bf295e471a1c0849ca">[詳解]</a><br /></td></tr>
<tr class="separator:a9d47cc2bc565c7bf295e471a1c0849ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7cac3e507c9485510781daf8c53908"><td class="memTemplParams" colspan="2">template&lt;typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:a6d7cac3e507c9485510781daf8c53908"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#a6d7cac3e507c9485510781daf8c53908">send</a> (const ConstBufferSequence &amp;buffers, <a class="el" href="classboost_1_1asio_1_1socket__base.html#a67128c96152cd551ec50af11773f29eb">socket_base::message_flags</a> flags)</td></tr>
<tr class="memdesc:a6d7cac3e507c9485510781daf8c53908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send some data on the socket.  <a href="classboost_1_1asio_1_1basic__stream__socket.html#a6d7cac3e507c9485510781daf8c53908">[詳解]</a><br /></td></tr>
<tr class="separator:a6d7cac3e507c9485510781daf8c53908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2f004368a85e3026495f31d751aede"><td class="memTemplParams" colspan="2">template&lt;typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:aab2f004368a85e3026495f31d751aede"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#aab2f004368a85e3026495f31d751aede">send</a> (const ConstBufferSequence &amp;buffers, <a class="el" href="classboost_1_1asio_1_1socket__base.html#a67128c96152cd551ec50af11773f29eb">socket_base::message_flags</a> flags, <a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:aab2f004368a85e3026495f31d751aede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send some data on the socket.  <a href="classboost_1_1asio_1_1basic__stream__socket.html#aab2f004368a85e3026495f31d751aede">[詳解]</a><br /></td></tr>
<tr class="separator:aab2f004368a85e3026495f31d751aede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e027195454e49471c9d4894b55085c"><td class="memTemplParams" colspan="2">template&lt;typename ConstBufferSequence , BOOST_ASIO_COMPLETION_TOKEN_FOR(void(boost::system::error_code, std::size_t)) WriteHandler BOOST_ASIO_DEFAULT_COMPLETION_TOKEN_TYPE(executor_type) &gt; </td></tr>
<tr class="memitem:af2e027195454e49471c9d4894b55085c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#af2e027195454e49471c9d4894b55085c">BOOST_ASIO_INITFN_AUTO_RESULT_TYPE</a> (WriteHandler, void(<a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>, std::size_t)) async_send(const ConstBufferSequence &amp;buffers</td></tr>
<tr class="memdesc:af2e027195454e49471c9d4894b55085c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous send.  <a href="classboost_1_1asio_1_1basic__stream__socket.html#af2e027195454e49471c9d4894b55085c">[詳解]</a><br /></td></tr>
<tr class="separator:af2e027195454e49471c9d4894b55085c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3062d91379c504d042ebf026a2cf0fc"><td class="memItemLeft" align="right" valign="top"><a id="ac3062d91379c504d042ebf026a2cf0fc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_ASIO_MOVE_ARG</b> (WriteHandler) handler BOOST_ASIO_DEFAULT_COMPLETION_TOKEN(<a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#a425b8c8edc06ec1741e51c42bedfed09">executor_type</a>))</td></tr>
<tr class="separator:ac3062d91379c504d042ebf026a2cf0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e027195454e49471c9d4894b55085c"><td class="memTemplParams" colspan="2">template&lt;typename ConstBufferSequence , BOOST_ASIO_COMPLETION_TOKEN_FOR(void(boost::system::error_code, std::size_t)) WriteHandler BOOST_ASIO_DEFAULT_COMPLETION_TOKEN_TYPE(executor_type) &gt; </td></tr>
<tr class="memitem:af2e027195454e49471c9d4894b55085c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#af2e027195454e49471c9d4894b55085c">BOOST_ASIO_INITFN_AUTO_RESULT_TYPE</a> (WriteHandler, void(<a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>, std::size_t)) async_send(const ConstBufferSequence &amp;buffers</td></tr>
<tr class="memdesc:af2e027195454e49471c9d4894b55085c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous send.  <a href="classboost_1_1asio_1_1basic__stream__socket.html#af2e027195454e49471c9d4894b55085c">[詳解]</a><br /></td></tr>
<tr class="separator:af2e027195454e49471c9d4894b55085c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af766b41c4121b28768d50346fc8b7b75"><td class="memItemLeft" align="right" valign="top"><a id="af766b41c4121b28768d50346fc8b7b75"></a>
<a class="el" href="classboost_1_1asio_1_1socket__base.html#a67128c96152cd551ec50af11773f29eb">socket_base::message_flags</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_ASIO_MOVE_ARG</b> (WriteHandler) handler BOOST_ASIO_DEFAULT_COMPLETION_TOKEN(<a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#a425b8c8edc06ec1741e51c42bedfed09">executor_type</a>))</td></tr>
<tr class="separator:af766b41c4121b28768d50346fc8b7b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5294631a8e0522c8aef6ba0642c4fbf"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:ae5294631a8e0522c8aef6ba0642c4fbf"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#ae5294631a8e0522c8aef6ba0642c4fbf">receive</a> (const MutableBufferSequence &amp;buffers)</td></tr>
<tr class="memdesc:ae5294631a8e0522c8aef6ba0642c4fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive some data on the socket.  <a href="classboost_1_1asio_1_1basic__stream__socket.html#ae5294631a8e0522c8aef6ba0642c4fbf">[詳解]</a><br /></td></tr>
<tr class="separator:ae5294631a8e0522c8aef6ba0642c4fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906b84e5b9f73f2dc3a0821b356bcc72"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:a906b84e5b9f73f2dc3a0821b356bcc72"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#a906b84e5b9f73f2dc3a0821b356bcc72">receive</a> (const MutableBufferSequence &amp;buffers, <a class="el" href="classboost_1_1asio_1_1socket__base.html#a67128c96152cd551ec50af11773f29eb">socket_base::message_flags</a> flags)</td></tr>
<tr class="memdesc:a906b84e5b9f73f2dc3a0821b356bcc72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive some data on the socket.  <a href="classboost_1_1asio_1_1basic__stream__socket.html#a906b84e5b9f73f2dc3a0821b356bcc72">[詳解]</a><br /></td></tr>
<tr class="separator:a906b84e5b9f73f2dc3a0821b356bcc72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b16d3110aed9a13346a5e8a45edbf4"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:a97b16d3110aed9a13346a5e8a45edbf4"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#a97b16d3110aed9a13346a5e8a45edbf4">receive</a> (const MutableBufferSequence &amp;buffers, <a class="el" href="classboost_1_1asio_1_1socket__base.html#a67128c96152cd551ec50af11773f29eb">socket_base::message_flags</a> flags, <a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a97b16d3110aed9a13346a5e8a45edbf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive some data on a connected socket.  <a href="classboost_1_1asio_1_1basic__stream__socket.html#a97b16d3110aed9a13346a5e8a45edbf4">[詳解]</a><br /></td></tr>
<tr class="separator:a97b16d3110aed9a13346a5e8a45edbf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e6fcfeaa7a9097f39d4136b06efae5"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence , BOOST_ASIO_COMPLETION_TOKEN_FOR(void(boost::system::error_code, std::size_t)) ReadHandler BOOST_ASIO_DEFAULT_COMPLETION_TOKEN_TYPE(executor_type) &gt; </td></tr>
<tr class="memitem:a36e6fcfeaa7a9097f39d4136b06efae5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#a36e6fcfeaa7a9097f39d4136b06efae5">BOOST_ASIO_INITFN_AUTO_RESULT_TYPE</a> (ReadHandler, void(<a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>, std::size_t)) async_receive(const MutableBufferSequence &amp;buffers</td></tr>
<tr class="memdesc:a36e6fcfeaa7a9097f39d4136b06efae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous receive.  <a href="classboost_1_1asio_1_1basic__stream__socket.html#a36e6fcfeaa7a9097f39d4136b06efae5">[詳解]</a><br /></td></tr>
<tr class="separator:a36e6fcfeaa7a9097f39d4136b06efae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd13295164f753cf27b5775f076748e2"><td class="memItemLeft" align="right" valign="top"><a id="abd13295164f753cf27b5775f076748e2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_ASIO_MOVE_ARG</b> (ReadHandler) handler BOOST_ASIO_DEFAULT_COMPLETION_TOKEN(<a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#a425b8c8edc06ec1741e51c42bedfed09">executor_type</a>))</td></tr>
<tr class="separator:abd13295164f753cf27b5775f076748e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e6fcfeaa7a9097f39d4136b06efae5"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence , BOOST_ASIO_COMPLETION_TOKEN_FOR(void(boost::system::error_code, std::size_t)) ReadHandler BOOST_ASIO_DEFAULT_COMPLETION_TOKEN_TYPE(executor_type) &gt; </td></tr>
<tr class="memitem:a36e6fcfeaa7a9097f39d4136b06efae5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#a36e6fcfeaa7a9097f39d4136b06efae5">BOOST_ASIO_INITFN_AUTO_RESULT_TYPE</a> (ReadHandler, void(<a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>, std::size_t)) async_receive(const MutableBufferSequence &amp;buffers</td></tr>
<tr class="memdesc:a36e6fcfeaa7a9097f39d4136b06efae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous receive.  <a href="classboost_1_1asio_1_1basic__stream__socket.html#a36e6fcfeaa7a9097f39d4136b06efae5">[詳解]</a><br /></td></tr>
<tr class="separator:a36e6fcfeaa7a9097f39d4136b06efae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a9363849b40c77b40cde3598580449"><td class="memItemLeft" align="right" valign="top"><a id="ad8a9363849b40c77b40cde3598580449"></a>
<a class="el" href="classboost_1_1asio_1_1socket__base.html#a67128c96152cd551ec50af11773f29eb">socket_base::message_flags</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_ASIO_MOVE_ARG</b> (ReadHandler) handler BOOST_ASIO_DEFAULT_COMPLETION_TOKEN(<a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#a425b8c8edc06ec1741e51c42bedfed09">executor_type</a>))</td></tr>
<tr class="separator:ad8a9363849b40c77b40cde3598580449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1839351534ae6013f9464ee0357eb3"><td class="memTemplParams" colspan="2">template&lt;typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:acd1839351534ae6013f9464ee0357eb3"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#acd1839351534ae6013f9464ee0357eb3">write_some</a> (const ConstBufferSequence &amp;buffers)</td></tr>
<tr class="memdesc:acd1839351534ae6013f9464ee0357eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write some data to the socket.  <a href="classboost_1_1asio_1_1basic__stream__socket.html#acd1839351534ae6013f9464ee0357eb3">[詳解]</a><br /></td></tr>
<tr class="separator:acd1839351534ae6013f9464ee0357eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac406958c7d28c236ffa3dfc44f09c96e"><td class="memTemplParams" colspan="2">template&lt;typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:ac406958c7d28c236ffa3dfc44f09c96e"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#ac406958c7d28c236ffa3dfc44f09c96e">write_some</a> (const ConstBufferSequence &amp;buffers, <a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ac406958c7d28c236ffa3dfc44f09c96e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write some data to the socket.  <a href="classboost_1_1asio_1_1basic__stream__socket.html#ac406958c7d28c236ffa3dfc44f09c96e">[詳解]</a><br /></td></tr>
<tr class="separator:ac406958c7d28c236ffa3dfc44f09c96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56bd4f66ae770a2bad12020c5c1c87b"><td class="memTemplParams" colspan="2">template&lt;typename ConstBufferSequence , BOOST_ASIO_COMPLETION_TOKEN_FOR(void(boost::system::error_code, std::size_t)) WriteHandler BOOST_ASIO_DEFAULT_COMPLETION_TOKEN_TYPE(executor_type) &gt; </td></tr>
<tr class="memitem:ae56bd4f66ae770a2bad12020c5c1c87b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#ae56bd4f66ae770a2bad12020c5c1c87b">BOOST_ASIO_INITFN_AUTO_RESULT_TYPE</a> (WriteHandler, void(<a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>, std::size_t)) async_write_some(const ConstBufferSequence &amp;buffers</td></tr>
<tr class="memdesc:ae56bd4f66ae770a2bad12020c5c1c87b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous write.  <a href="classboost_1_1asio_1_1basic__stream__socket.html#ae56bd4f66ae770a2bad12020c5c1c87b">[詳解]</a><br /></td></tr>
<tr class="separator:ae56bd4f66ae770a2bad12020c5c1c87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3062d91379c504d042ebf026a2cf0fc"><td class="memItemLeft" align="right" valign="top"><a id="ac3062d91379c504d042ebf026a2cf0fc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_ASIO_MOVE_ARG</b> (WriteHandler) handler BOOST_ASIO_DEFAULT_COMPLETION_TOKEN(<a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#a425b8c8edc06ec1741e51c42bedfed09">executor_type</a>))</td></tr>
<tr class="separator:ac3062d91379c504d042ebf026a2cf0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736c9cfc66f44cff539cf82627b0682b"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:a736c9cfc66f44cff539cf82627b0682b"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#a736c9cfc66f44cff539cf82627b0682b">read_some</a> (const MutableBufferSequence &amp;buffers)</td></tr>
<tr class="memdesc:a736c9cfc66f44cff539cf82627b0682b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read some data from the socket.  <a href="classboost_1_1asio_1_1basic__stream__socket.html#a736c9cfc66f44cff539cf82627b0682b">[詳解]</a><br /></td></tr>
<tr class="separator:a736c9cfc66f44cff539cf82627b0682b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05944260473860b6c8a63e2f2ef74807"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:a05944260473860b6c8a63e2f2ef74807"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#a05944260473860b6c8a63e2f2ef74807">read_some</a> (const MutableBufferSequence &amp;buffers, <a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a05944260473860b6c8a63e2f2ef74807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read some data from the socket.  <a href="classboost_1_1asio_1_1basic__stream__socket.html#a05944260473860b6c8a63e2f2ef74807">[詳解]</a><br /></td></tr>
<tr class="separator:a05944260473860b6c8a63e2f2ef74807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2771705809a5eb7da9ec16d9c61f7dde"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence , BOOST_ASIO_COMPLETION_TOKEN_FOR(void(boost::system::error_code, std::size_t)) ReadHandler BOOST_ASIO_DEFAULT_COMPLETION_TOKEN_TYPE(executor_type) &gt; </td></tr>
<tr class="memitem:a2771705809a5eb7da9ec16d9c61f7dde"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#a2771705809a5eb7da9ec16d9c61f7dde">BOOST_ASIO_INITFN_AUTO_RESULT_TYPE</a> (ReadHandler, void(<a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>, std::size_t)) async_read_some(const MutableBufferSequence &amp;buffers</td></tr>
<tr class="memdesc:a2771705809a5eb7da9ec16d9c61f7dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous read.  <a href="classboost_1_1asio_1_1basic__stream__socket.html#a2771705809a5eb7da9ec16d9c61f7dde">[詳解]</a><br /></td></tr>
<tr class="separator:a2771705809a5eb7da9ec16d9c61f7dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd13295164f753cf27b5775f076748e2"><td class="memItemLeft" align="right" valign="top"><a id="abd13295164f753cf27b5775f076748e2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_ASIO_MOVE_ARG</b> (ReadHandler) handler BOOST_ASIO_DEFAULT_COMPLETION_TOKEN(<a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#a425b8c8edc06ec1741e51c42bedfed09">executor_type</a>))</td></tr>
<tr class="separator:abd13295164f753cf27b5775f076748e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
公開変数類</h2></td></tr>
<tr class="memitem:aa20fdb1c1f1735bc8d18348702a05787"><td class="memItemLeft" align="right" valign="top"><a id="aa20fdb1c1f1735bc8d18348702a05787"></a>
<a class="el" href="classboost_1_1asio_1_1socket__base.html#a67128c96152cd551ec50af11773f29eb">socket_base::message_flags</a>&#160;</td><td class="memItemRight" valign="bottom"><b>flags</b></td></tr>
<tr class="separator:aa20fdb1c1f1735bc8d18348702a05787"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">詳解</h2>
<div class="textblock"><h3>template&lt;typename Protocol, typename Executor&gt;<br />
class boost::asio::basic_stream_socket&lt; Protocol, Executor &gt;</h3>

<p>Provides stream-oriented socket functionality. </p>
<p>The <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html" title="Provides stream-oriented socket functionality.">basic_stream_socket</a> class template provides asynchronous and blocking stream-oriented socket functionality.</p>
<dl class="section user"><dt>Thread Safety</dt><dd><em>Distinct</em> <em>objects:</em> Safe.<br  />
<em>Shared</em> <em>objects:</em> Unsafe.</dd></dl>
<dl class="section user"><dt>Concepts:</dt><dd>AsyncReadStream, AsyncWriteStream, Stream, SyncReadStream, SyncWriteStream. </dd></dl>
</div><h2 class="groupheader">構築子と解体子</h2>
<a id="aff01fefa05e301f3bf64cd0ad4f2c70c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff01fefa05e301f3bf64cd0ad4f2c70c">&#9670;&nbsp;</a></span>basic_stream_socket() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html">boost::asio::basic_stream_socket</a>&lt; Protocol, Executor &gt;::<a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html">basic_stream_socket</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#a425b8c8edc06ec1741e51c42bedfed09">executor_type</a> &amp;&#160;</td>
          <td class="paramname"><em>ex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html" title="Provides stream-oriented socket functionality.">basic_stream_socket</a> without opening it. </p>
<p>This constructor creates a stream socket without opening it. The socket needs to be opened and then connected or accepted before data can be sent or received on it.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>The I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7bd3574354cf9e418766312fe2303045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bd3574354cf9e418766312fe2303045">&#9670;&nbsp;</a></span>basic_stream_socket() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor &gt; </div>
<div class="memtemplate">
template&lt;typename ExecutionContext &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html">boost::asio::basic_stream_socket</a>&lt; Protocol, Executor &gt;::<a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html">basic_stream_socket</a> </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structboost_1_1asio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structboost_1_1is__convertible.html">is_convertible</a>&lt; ExecutionContext &amp;, <a class="el" href="classboost_1_1asio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;::<a class="el" href="structboost_1_1type.html">type</a> *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html" title="Provides stream-oriented socket functionality.">basic_stream_socket</a> without opening it. </p>
<p>This constructor creates a stream socket without opening it. The socket needs to be opened and then connected or accepted before data can be sent or received on it.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>An execution context which provides the I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfc4bee6043a49626e4c12a8e51ba256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc4bee6043a49626e4c12a8e51ba256">&#9670;&nbsp;</a></span>basic_stream_socket() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html">boost::asio::basic_stream_socket</a>&lt; Protocol, Executor &gt;::<a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html">basic_stream_socket</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#a425b8c8edc06ec1741e51c42bedfed09">executor_type</a> &amp;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#aede673f876ec45b978cb360974073415">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct and open a <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html" title="Provides stream-oriented socket functionality.">basic_stream_socket</a>. </p>
<p>This constructor creates and opens a stream socket. The socket needs to be connected or accepted before data can be sent or received on it.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>The I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.</td></tr>
    <tr><td class="paramname">protocol</td><td>An object specifying protocol parameters to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classboost_1_1system_1_1system__error.html">boost::system::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa55bff23492228c56d07a1468d778f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa55bff23492228c56d07a1468d778f57">&#9670;&nbsp;</a></span>basic_stream_socket() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor &gt; </div>
<div class="memtemplate">
template&lt;typename ExecutionContext &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html">boost::asio::basic_stream_socket</a>&lt; Protocol, Executor &gt;::<a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html">basic_stream_socket</a> </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#aede673f876ec45b978cb360974073415">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structboost_1_1asio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structboost_1_1is__convertible.html">is_convertible</a>&lt; ExecutionContext &amp;, <a class="el" href="classboost_1_1asio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;::<a class="el" href="structboost_1_1type.html">type</a> *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct and open a <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html" title="Provides stream-oriented socket functionality.">basic_stream_socket</a>. </p>
<p>This constructor creates and opens a stream socket. The socket needs to be connected or accepted before data can be sent or received on it.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>An execution context which provides the I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.</td></tr>
    <tr><td class="paramname">protocol</td><td>An object specifying protocol parameters to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classboost_1_1system_1_1system__error.html">boost::system::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6dc245bb8d33614ce3383cecbc225746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dc245bb8d33614ce3383cecbc225746">&#9670;&nbsp;</a></span>basic_stream_socket() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html">boost::asio::basic_stream_socket</a>&lt; Protocol, Executor &gt;::<a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html">basic_stream_socket</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#a425b8c8edc06ec1741e51c42bedfed09">executor_type</a> &amp;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#aafc4cf21b43db2f9235cc154d37a01c8">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>endpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct a <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html" title="Provides stream-oriented socket functionality.">basic_stream_socket</a>, opening it and binding it to the given local endpoint. This constructor creates a stream socket and automatically opens it bound to the specified endpoint on the local machine. The protocol used is the protocol associated with the given endpoint.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>The I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.</td></tr>
    <tr><td class="paramname">endpoint</td><td>An endpoint on the local machine to which the stream socket will be bound.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classboost_1_1system_1_1system__error.html">boost::system::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1cdcb828d9115423a7e2a3d8d15ad38e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cdcb828d9115423a7e2a3d8d15ad38e">&#9670;&nbsp;</a></span>basic_stream_socket() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor &gt; </div>
<div class="memtemplate">
template&lt;typename ExecutionContext &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html">boost::asio::basic_stream_socket</a>&lt; Protocol, Executor &gt;::<a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html">basic_stream_socket</a> </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#aafc4cf21b43db2f9235cc154d37a01c8">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structboost_1_1asio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structboost_1_1is__convertible.html">is_convertible</a>&lt; ExecutionContext &amp;, <a class="el" href="classboost_1_1asio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;::<a class="el" href="structboost_1_1type.html">type</a> *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct a <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html" title="Provides stream-oriented socket functionality.">basic_stream_socket</a>, opening it and binding it to the given local endpoint. This constructor creates a stream socket and automatically opens it bound to the specified endpoint on the local machine. The protocol used is the protocol associated with the given endpoint.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>An execution context which provides the I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.</td></tr>
    <tr><td class="paramname">endpoint</td><td>An endpoint on the local machine to which the stream socket will be bound.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classboost_1_1system_1_1system__error.html">boost::system::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d8570e9aa8184aac92ca0a8f3a9fc57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d8570e9aa8184aac92ca0a8f3a9fc57">&#9670;&nbsp;</a></span>basic_stream_socket() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html">boost::asio::basic_stream_socket</a>&lt; Protocol, Executor &gt;::<a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html">basic_stream_socket</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#a425b8c8edc06ec1741e51c42bedfed09">executor_type</a> &amp;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#aede673f876ec45b978cb360974073415">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#aa383e95d6ccae072417a0125507750bc">native_handle_type</a> &amp;&#160;</td>
          <td class="paramname"><em>native_socket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html" title="Provides stream-oriented socket functionality.">basic_stream_socket</a> on an existing native socket. </p>
<p>This constructor creates a stream socket object to hold an existing native socket.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>The I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.</td></tr>
    <tr><td class="paramname">protocol</td><td>An object specifying protocol parameters to be used.</td></tr>
    <tr><td class="paramname">native_socket</td><td>The new underlying socket implementation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classboost_1_1system_1_1system__error.html">boost::system::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42ba37c78bf160d027456e77b3710e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42ba37c78bf160d027456e77b3710e9c">&#9670;&nbsp;</a></span>basic_stream_socket() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor &gt; </div>
<div class="memtemplate">
template&lt;typename ExecutionContext &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html">boost::asio::basic_stream_socket</a>&lt; Protocol, Executor &gt;::<a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html">basic_stream_socket</a> </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#aede673f876ec45b978cb360974073415">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html#aa383e95d6ccae072417a0125507750bc">native_handle_type</a> &amp;&#160;</td>
          <td class="paramname"><em>native_socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structboost_1_1asio_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structboost_1_1is__convertible.html">is_convertible</a>&lt; ExecutionContext &amp;, <a class="el" href="classboost_1_1asio_1_1execution__context.html">execution_context</a> &amp; &gt;::value &gt;::<a class="el" href="structboost_1_1type.html">type</a> *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html" title="Provides stream-oriented socket functionality.">basic_stream_socket</a> on an existing native socket. </p>
<p>This constructor creates a stream socket object to hold an existing native socket.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>An execution context which provides the I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.</td></tr>
    <tr><td class="paramname">protocol</td><td>An object specifying protocol parameters to be used.</td></tr>
    <tr><td class="paramname">native_socket</td><td>The new underlying socket implementation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classboost_1_1system_1_1system__error.html">boost::system::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07cc8e0a1249bb3e0a68dd55dfc2a517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07cc8e0a1249bb3e0a68dd55dfc2a517">&#9670;&nbsp;</a></span>~basic_stream_socket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html">boost::asio::basic_stream_socket</a>&lt; Protocol, Executor &gt;::~<a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html">basic_stream_socket</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the socket. </p>
<p>This function destroys the socket, cancelling any outstanding asynchronous operations associated with the socket as if by calling <code>cancel</code>. </p>

</div>
</div>
<h2 class="groupheader">関数詳解</h2>
<a id="a2771705809a5eb7da9ec16d9c61f7dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2771705809a5eb7da9ec16d9c61f7dde">&#9670;&nbsp;</a></span>BOOST_ASIO_INITFN_AUTO_RESULT_TYPE() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor &gt; </div>
<div class="memtemplate">
template&lt;typename MutableBufferSequence , BOOST_ASIO_COMPLETION_TOKEN_FOR(void(boost::system::error_code, std::size_t)) ReadHandler BOOST_ASIO_DEFAULT_COMPLETION_TOKEN_TYPE(executor_type) &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html">boost::asio::basic_stream_socket</a>&lt; Protocol, Executor &gt;::BOOST_ASIO_INITFN_AUTO_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">ReadHandler&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(<a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>, std::size_t)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an asynchronous read. </p>
<p>This function is used to asynchronously read data from the stream socket. The function call always returns immediately.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>&amp; error, <span class="comment">// Result of operation.</span></div>
<div class="line">  std::size_t bytes_transferred           <span class="comment">// Number of bytes read.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using boost::asio::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>The read operation may not read all of the requested number of bytes. Consider using the async_read function if you need to ensure that the requested amount of data is read before the asynchronous operation completes.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read into a single data buffer use the <a class="el" href="group__buffer.html">boost::asio::buffer</a> function as follows: <div class="fragment"><div class="line">socket.async_read_some(boost::asio::buffer(data, size), handler);</div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">boost::asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector. </dd></dl>

</div>
</div>
<a id="a36e6fcfeaa7a9097f39d4136b06efae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36e6fcfeaa7a9097f39d4136b06efae5">&#9670;&nbsp;</a></span>BOOST_ASIO_INITFN_AUTO_RESULT_TYPE() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor &gt; </div>
<div class="memtemplate">
template&lt;typename MutableBufferSequence , BOOST_ASIO_COMPLETION_TOKEN_FOR(void(boost::system::error_code, std::size_t)) ReadHandler BOOST_ASIO_DEFAULT_COMPLETION_TOKEN_TYPE(executor_type) &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html">boost::asio::basic_stream_socket</a>&lt; Protocol, Executor &gt;::BOOST_ASIO_INITFN_AUTO_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">ReadHandler&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(<a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>, std::size_t)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an asynchronous receive. </p>
<p>This function is used to asynchronously receive data from the stream socket. The function call always returns immediately.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be received. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the receive operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>&amp; error, <span class="comment">// Result of operation.</span></div>
<div class="line">  std::size_t bytes_transferred           <span class="comment">// Number of bytes received.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using boost::asio::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>The receive operation may not receive all of the requested number of bytes. Consider using the async_read function if you need to ensure that the requested amount of data is received before the asynchronous operation completes.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To receive into a single data buffer use the <a class="el" href="group__buffer.html">boost::asio::buffer</a> function as follows: <div class="fragment"><div class="line">socket.async_receive(boost::asio::buffer(data, size), handler);</div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">boost::asio::buffer</a> documentation for information on receiving into multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector. </dd></dl>

</div>
</div>
<a id="a36e6fcfeaa7a9097f39d4136b06efae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36e6fcfeaa7a9097f39d4136b06efae5">&#9670;&nbsp;</a></span>BOOST_ASIO_INITFN_AUTO_RESULT_TYPE() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor &gt; </div>
<div class="memtemplate">
template&lt;typename MutableBufferSequence , BOOST_ASIO_COMPLETION_TOKEN_FOR(void(boost::system::error_code, std::size_t)) ReadHandler BOOST_ASIO_DEFAULT_COMPLETION_TOKEN_TYPE(executor_type) &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html">boost::asio::basic_stream_socket</a>&lt; Protocol, Executor &gt;::BOOST_ASIO_INITFN_AUTO_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">ReadHandler&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(<a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>, std::size_t)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an asynchronous receive. </p>
<p>This function is used to asynchronously receive data from the stream socket. The function call always returns immediately.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be received. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">flags</td><td>Flags specifying how the receive call is to be made.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the receive operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>&amp; error, <span class="comment">// Result of operation.</span></div>
<div class="line">  std::size_t bytes_transferred           <span class="comment">// Number of bytes received.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using boost::asio::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>The receive operation may not receive all of the requested number of bytes. Consider using the async_read function if you need to ensure that the requested amount of data is received before the asynchronous operation completes.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To receive into a single data buffer use the <a class="el" href="group__buffer.html">boost::asio::buffer</a> function as follows: <div class="fragment"><div class="line">socket.async_receive(boost::asio::buffer(data, size), 0, handler);</div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">boost::asio::buffer</a> documentation for information on receiving into multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector. </dd></dl>

</div>
</div>
<a id="af2e027195454e49471c9d4894b55085c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2e027195454e49471c9d4894b55085c">&#9670;&nbsp;</a></span>BOOST_ASIO_INITFN_AUTO_RESULT_TYPE() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor &gt; </div>
<div class="memtemplate">
template&lt;typename ConstBufferSequence , BOOST_ASIO_COMPLETION_TOKEN_FOR(void(boost::system::error_code, std::size_t)) WriteHandler BOOST_ASIO_DEFAULT_COMPLETION_TOKEN_TYPE(executor_type) &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html">boost::asio::basic_stream_socket</a>&lt; Protocol, Executor &gt;::BOOST_ASIO_INITFN_AUTO_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">WriteHandler&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(<a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>, std::size_t)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an asynchronous send. </p>
<p>This function is used to asynchronously send data on the stream socket. The function call always returns immediately.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>One or more data buffers to be sent on the socket. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the send operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>&amp; error, <span class="comment">// Result of operation.</span></div>
<div class="line">  std::size_t bytes_transferred           <span class="comment">// Number of bytes sent.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using boost::asio::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>The send operation may not transmit all of the data to the peer. Consider using the <a class="el" href="group__async__write.html">boost::asio::async_write</a> function if you need to ensure that all data is written before the asynchronous operation completes.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To send a single data buffer use the <a class="el" href="group__buffer.html">boost::asio::buffer</a> function as follows: <div class="fragment"><div class="line">socket.async_send(boost::asio::buffer(data, size), handler);</div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">boost::asio::buffer</a> documentation for information on sending multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector. </dd></dl>

</div>
</div>
<a id="af2e027195454e49471c9d4894b55085c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2e027195454e49471c9d4894b55085c">&#9670;&nbsp;</a></span>BOOST_ASIO_INITFN_AUTO_RESULT_TYPE() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor &gt; </div>
<div class="memtemplate">
template&lt;typename ConstBufferSequence , BOOST_ASIO_COMPLETION_TOKEN_FOR(void(boost::system::error_code, std::size_t)) WriteHandler BOOST_ASIO_DEFAULT_COMPLETION_TOKEN_TYPE(executor_type) &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html">boost::asio::basic_stream_socket</a>&lt; Protocol, Executor &gt;::BOOST_ASIO_INITFN_AUTO_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">WriteHandler&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(<a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>, std::size_t)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an asynchronous send. </p>
<p>This function is used to asynchronously send data on the stream socket. The function call always returns immediately.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>One or more data buffers to be sent on the socket. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">flags</td><td>Flags specifying how the send call is to be made.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the send operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>&amp; error, <span class="comment">// Result of operation.</span></div>
<div class="line">  std::size_t bytes_transferred           <span class="comment">// Number of bytes sent.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using boost::asio::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>The send operation may not transmit all of the data to the peer. Consider using the <a class="el" href="group__async__write.html">boost::asio::async_write</a> function if you need to ensure that all data is written before the asynchronous operation completes.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To send a single data buffer use the <a class="el" href="group__buffer.html">boost::asio::buffer</a> function as follows: <div class="fragment"><div class="line">socket.async_send(boost::asio::buffer(data, size), 0, handler);</div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">boost::asio::buffer</a> documentation for information on sending multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector. </dd></dl>

</div>
</div>
<a id="ae56bd4f66ae770a2bad12020c5c1c87b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae56bd4f66ae770a2bad12020c5c1c87b">&#9670;&nbsp;</a></span>BOOST_ASIO_INITFN_AUTO_RESULT_TYPE() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor &gt; </div>
<div class="memtemplate">
template&lt;typename ConstBufferSequence , BOOST_ASIO_COMPLETION_TOKEN_FOR(void(boost::system::error_code, std::size_t)) WriteHandler BOOST_ASIO_DEFAULT_COMPLETION_TOKEN_TYPE(executor_type) &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html">boost::asio::basic_stream_socket</a>&lt; Protocol, Executor &gt;::BOOST_ASIO_INITFN_AUTO_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">WriteHandler&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(<a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>, std::size_t)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an asynchronous write. </p>
<p>This function is used to asynchronously write data to the stream socket. The function call always returns immediately.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>One or more data buffers to be written to the socket. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>&amp; error, <span class="comment">// Result of operation.</span></div>
<div class="line">  std::size_t bytes_transferred           <span class="comment">// Number of bytes written.</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using boost::asio::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>The write operation may not transmit all of the data to the peer. Consider using the <a class="el" href="group__async__write.html">boost::asio::async_write</a> function if you need to ensure that all data is written before the asynchronous operation completes.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To write a single data buffer use the <a class="el" href="group__buffer.html">boost::asio::buffer</a> function as follows: <div class="fragment"><div class="line">socket.async_write_some(boost::asio::buffer(data, size), handler);</div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">boost::asio::buffer</a> documentation for information on writing multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector. </dd></dl>

</div>
</div>
<a id="a736c9cfc66f44cff539cf82627b0682b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a736c9cfc66f44cff539cf82627b0682b">&#9670;&nbsp;</a></span>read_some() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor &gt; </div>
<div class="memtemplate">
template&lt;typename MutableBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html">boost::asio::basic_stream_socket</a>&lt; Protocol, Executor &gt;::read_some </td>
          <td>(</td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read some data from the socket. </p>
<p>This function is used to read data from the stream socket. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The number of bytes read.</dd></dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classboost_1_1system_1_1system__error.html">boost::system::system_error</a></td><td>Thrown on failure. An error code of boost::asio::error::eof indicates that the connection was closed by the peer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>The read_some operation may not read all of the requested number of bytes. Consider using the read function if you need to ensure that the requested amount of data is read before the blocking operation completes.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read into a single data buffer use the <a class="el" href="group__buffer.html">boost::asio::buffer</a> function as follows: <div class="fragment"><div class="line">socket.read_some(boost::asio::buffer(data, size));</div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">boost::asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector. </dd></dl>

</div>
</div>
<a id="a05944260473860b6c8a63e2f2ef74807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05944260473860b6c8a63e2f2ef74807">&#9670;&nbsp;</a></span>read_some() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor &gt; </div>
<div class="memtemplate">
template&lt;typename MutableBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html">boost::asio::basic_stream_socket</a>&lt; Protocol, Executor &gt;::read_some </td>
          <td>(</td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read some data from the socket. </p>
<p>This function is used to read data from the stream socket. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The number of bytes read. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>覚え書き</dt><dd>The read_some operation may not read all of the requested number of bytes. Consider using the read function if you need to ensure that the requested amount of data is read before the blocking operation completes. </dd></dl>

</div>
</div>
<a id="ae5294631a8e0522c8aef6ba0642c4fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5294631a8e0522c8aef6ba0642c4fbf">&#9670;&nbsp;</a></span>receive() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor &gt; </div>
<div class="memtemplate">
template&lt;typename MutableBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html">boost::asio::basic_stream_socket</a>&lt; Protocol, Executor &gt;::receive </td>
          <td>(</td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive some data on the socket. </p>
<p>This function is used to receive data on the stream socket. The function call will block until one or more bytes of data has been received successfully, or until an error occurs.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be received.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The number of bytes received.</dd></dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classboost_1_1system_1_1system__error.html">boost::system::system_error</a></td><td>Thrown on failure. An error code of boost::asio::error::eof indicates that the connection was closed by the peer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>The receive operation may not receive all of the requested number of bytes. Consider using the read function if you need to ensure that the requested amount of data is read before the blocking operation completes.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To receive into a single data buffer use the <a class="el" href="group__buffer.html">boost::asio::buffer</a> function as follows: <div class="fragment"><div class="line">socket.receive(boost::asio::buffer(data, size));</div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">boost::asio::buffer</a> documentation for information on receiving into multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector. </dd></dl>

</div>
</div>
<a id="a906b84e5b9f73f2dc3a0821b356bcc72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a906b84e5b9f73f2dc3a0821b356bcc72">&#9670;&nbsp;</a></span>receive() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor &gt; </div>
<div class="memtemplate">
template&lt;typename MutableBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html">boost::asio::basic_stream_socket</a>&lt; Protocol, Executor &gt;::receive </td>
          <td>(</td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1asio_1_1socket__base.html#a67128c96152cd551ec50af11773f29eb">socket_base::message_flags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive some data on the socket. </p>
<p>This function is used to receive data on the stream socket. The function call will block until one or more bytes of data has been received successfully, or until an error occurs.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be received.</td></tr>
    <tr><td class="paramname">flags</td><td>Flags specifying how the receive call is to be made.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The number of bytes received.</dd></dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classboost_1_1system_1_1system__error.html">boost::system::system_error</a></td><td>Thrown on failure. An error code of boost::asio::error::eof indicates that the connection was closed by the peer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>The receive operation may not receive all of the requested number of bytes. Consider using the read function if you need to ensure that the requested amount of data is read before the blocking operation completes.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To receive into a single data buffer use the <a class="el" href="group__buffer.html">boost::asio::buffer</a> function as follows: <div class="fragment"><div class="line">socket.receive(boost::asio::buffer(data, size), 0);</div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">boost::asio::buffer</a> documentation for information on receiving into multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector. </dd></dl>

</div>
</div>
<a id="a97b16d3110aed9a13346a5e8a45edbf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b16d3110aed9a13346a5e8a45edbf4">&#9670;&nbsp;</a></span>receive() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor &gt; </div>
<div class="memtemplate">
template&lt;typename MutableBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html">boost::asio::basic_stream_socket</a>&lt; Protocol, Executor &gt;::receive </td>
          <td>(</td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1asio_1_1socket__base.html#a67128c96152cd551ec50af11773f29eb">socket_base::message_flags</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive some data on a connected socket. </p>
<p>This function is used to receive data on the stream socket. The function call will block until one or more bytes of data has been received successfully, or until an error occurs.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be received.</td></tr>
    <tr><td class="paramname">flags</td><td>Flags specifying how the receive call is to be made.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The number of bytes received. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>覚え書き</dt><dd>The receive operation may not receive all of the requested number of bytes. Consider using the read function if you need to ensure that the requested amount of data is read before the blocking operation completes. </dd></dl>

</div>
</div>
<a id="a9d47cc2bc565c7bf295e471a1c0849ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d47cc2bc565c7bf295e471a1c0849ca">&#9670;&nbsp;</a></span>send() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor &gt; </div>
<div class="memtemplate">
template&lt;typename ConstBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html">boost::asio::basic_stream_socket</a>&lt; Protocol, Executor &gt;::send </td>
          <td>(</td>
          <td class="paramtype">const ConstBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send some data on the socket. </p>
<p>This function is used to send data on the stream socket. The function call will block until one or more bytes of the data has been sent successfully, or an until error occurs.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>One or more data buffers to be sent on the socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The number of bytes sent.</dd></dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classboost_1_1system_1_1system__error.html">boost::system::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>The send operation may not transmit all of the data to the peer. Consider using the <a class="el" href="group__write.html">boost::asio::write</a> function if you need to ensure that all data is written before the blocking operation completes.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To send a single data buffer use the <a class="el" href="group__buffer.html">boost::asio::buffer</a> function as follows: <div class="fragment"><div class="line">socket.send(boost::asio::buffer(data, size));</div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">boost::asio::buffer</a> documentation for information on sending multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector. </dd></dl>

</div>
</div>
<a id="a6d7cac3e507c9485510781daf8c53908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d7cac3e507c9485510781daf8c53908">&#9670;&nbsp;</a></span>send() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor &gt; </div>
<div class="memtemplate">
template&lt;typename ConstBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html">boost::asio::basic_stream_socket</a>&lt; Protocol, Executor &gt;::send </td>
          <td>(</td>
          <td class="paramtype">const ConstBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1asio_1_1socket__base.html#a67128c96152cd551ec50af11773f29eb">socket_base::message_flags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send some data on the socket. </p>
<p>This function is used to send data on the stream socket. The function call will block until one or more bytes of the data has been sent successfully, or an until error occurs.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>One or more data buffers to be sent on the socket.</td></tr>
    <tr><td class="paramname">flags</td><td>Flags specifying how the send call is to be made.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The number of bytes sent.</dd></dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classboost_1_1system_1_1system__error.html">boost::system::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>The send operation may not transmit all of the data to the peer. Consider using the <a class="el" href="group__write.html">boost::asio::write</a> function if you need to ensure that all data is written before the blocking operation completes.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To send a single data buffer use the <a class="el" href="group__buffer.html">boost::asio::buffer</a> function as follows: <div class="fragment"><div class="line">socket.send(boost::asio::buffer(data, size), 0);</div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">boost::asio::buffer</a> documentation for information on sending multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector. </dd></dl>

</div>
</div>
<a id="aab2f004368a85e3026495f31d751aede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab2f004368a85e3026495f31d751aede">&#9670;&nbsp;</a></span>send() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor &gt; </div>
<div class="memtemplate">
template&lt;typename ConstBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html">boost::asio::basic_stream_socket</a>&lt; Protocol, Executor &gt;::send </td>
          <td>(</td>
          <td class="paramtype">const ConstBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1asio_1_1socket__base.html#a67128c96152cd551ec50af11773f29eb">socket_base::message_flags</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send some data on the socket. </p>
<p>This function is used to send data on the stream socket. The function call will block until one or more bytes of the data has been sent successfully, or an until error occurs.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>One or more data buffers to be sent on the socket.</td></tr>
    <tr><td class="paramname">flags</td><td>Flags specifying how the send call is to be made.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The number of bytes sent. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>覚え書き</dt><dd>The send operation may not transmit all of the data to the peer. Consider using the <a class="el" href="group__write.html">boost::asio::write</a> function if you need to ensure that all data is written before the blocking operation completes. </dd></dl>

</div>
</div>
<a id="acd1839351534ae6013f9464ee0357eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd1839351534ae6013f9464ee0357eb3">&#9670;&nbsp;</a></span>write_some() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor &gt; </div>
<div class="memtemplate">
template&lt;typename ConstBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html">boost::asio::basic_stream_socket</a>&lt; Protocol, Executor &gt;::write_some </td>
          <td>(</td>
          <td class="paramtype">const ConstBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write some data to the socket. </p>
<p>This function is used to write data to the stream socket. The function call will block until one or more bytes of the data has been written successfully, or until an error occurs.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>One or more data buffers to be written to the socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The number of bytes written.</dd></dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classboost_1_1system_1_1system__error.html">boost::system::system_error</a></td><td>Thrown on failure. An error code of boost::asio::error::eof indicates that the connection was closed by the peer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>The write_some operation may not transmit all of the data to the peer. Consider using the <a class="el" href="group__write.html">boost::asio::write</a> function if you need to ensure that all data is written before the blocking operation completes.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To write a single data buffer use the <a class="el" href="group__buffer.html">boost::asio::buffer</a> function as follows: <div class="fragment"><div class="line">socket.write_some(boost::asio::buffer(data, size));</div>
</div><!-- fragment --> See the <a class="el" href="group__buffer.html">boost::asio::buffer</a> documentation for information on writing multiple buffers in one go, and how to use it with arrays, <a class="el" href="classboost_1_1array.html">boost::array</a> or std::vector. </dd></dl>

</div>
</div>
<a id="ac406958c7d28c236ffa3dfc44f09c96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac406958c7d28c236ffa3dfc44f09c96e">&#9670;&nbsp;</a></span>write_some() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Executor &gt; </div>
<div class="memtemplate">
template&lt;typename ConstBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html">boost::asio::basic_stream_socket</a>&lt; Protocol, Executor &gt;::write_some </td>
          <td>(</td>
          <td class="paramtype">const ConstBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write some data to the socket. </p>
<p>This function is used to write data to the stream socket. The function call will block until one or more bytes of the data has been written successfully, or until an error occurs.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>One or more data buffers to be written to the socket.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The number of bytes written. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>覚え書き</dt><dd>The write_some operation may not transmit all of the data to the peer. Consider using the <a class="el" href="group__write.html">boost::asio::write</a> function if you need to ensure that all data is written before the blocking operation completes. </dd></dl>

</div>
</div>
<hr/>このクラス詳解は次のファイルから抽出されました:<ul>
<li>include/external/boost/boost/asio/<a class="el" href="basic__stream__socket_8hpp_source.html">basic_stream_socket.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="aclassboost_1_1system_1_1error__code_html"><div class="ttname"><a href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a></div><div class="ttdef"><b>Definition:</b> error_code.hpp:571</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceboost.html">boost</a></li><li class="navelem"><b>asio</b></li><li class="navelem"><a class="el" href="classboost_1_1asio_1_1basic__stream__socket.html">basic_stream_socket</a></li>
    <li class="footer">構築:
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
