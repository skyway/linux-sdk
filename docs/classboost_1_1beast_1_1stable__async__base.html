<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
<head>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
        'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
        })(window,document,'script','dataLayer','GTM-NN5JX4B');</script>
    <!-- End Google Tag Manager -->
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=11"/>
    <meta name="generator" content="Doxygen 1.9.8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>SkyWay Linux SDK</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="resize.js"></script>
    <script type="text/javascript" src="navtreedata.js"></script>
    <script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="search/searchdata.js"></script>
    <script type="text/javascript" src="search/search.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NN5JX4B"
        height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
            <tbody>
                <tr id="projectrow">
                    <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
                    <td id="projectalign">
                        <div id="projectname">SkyWay Linux SDK
                        </div>
                    </td>
                </tr>
            </tbody>
        </table>
    </div><!-- 構築: Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'検索');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','検索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classboost_1_1beast_1_1stable__async__base.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">公開メンバ関数</a> &#124;
<a href="#friends">フレンド</a> &#124;
<a href="classboost_1_1beast_1_1stable__async__base-members.html">全メンバ一覧</a>  </div>
  <div class="headertitle">
<div class="title">boost::beast::stable_async_base&lt; Handler, Executor1, Allocator &gt; クラステンプレート</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="async__base_8hpp_source.html">async_base.hpp</a>&gt;</code></p>
<div class="dynheader">
boost::beast::stable_async_base&lt; Handler, Executor1, Allocator &gt; の継承関係図</div>
<div class="dyncontent">
 <div class="center">
  <img src="classboost_1_1beast_1_1stable__async__base.png" usemap="#boost::beast::stable_5Fasync_5Fbase_3C_20Handler_2C_20Executor1_2C_20Allocator_20_3E_map" alt=""/>
  <map id="boost::beast::stable_5Fasync_5Fbase_3C_20Handler_2C_20Executor1_2C_20Allocator_20_3E_map" name="boost::beast::stable_5Fasync_5Fbase_3C_20Handler_2C_20Executor1_2C_20Allocator_20_3E_map">
<area href="classboost_1_1beast_1_1async__base.html" alt="boost::beast::async_base&lt; Handler, Executor1, std::allocator&lt; void &gt; &gt;" shape="rect" coords="0,56,415,80"/>
<area href="classboost_1_1empty___1_1empty__value.html" alt="boost::empty_::empty_value&lt; T, N, E &gt;" shape="rect" coords="0,0,415,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
公開メンバ関数</h2></td></tr>
<tr class="memitem:a1218a3963987b9ef48e822caf0729317"><td class="memTemplParams" colspan="2">template&lt;class Handler_ , class  = typename std::enable_if&lt;            ! std::is_same&lt;typename                std::decay&lt;Handler_&gt;::type,                stable_async_base            &gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a1218a3963987b9ef48e822caf0729317"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1stable__async__base.html#a1218a3963987b9ef48e822caf0729317">stable_async_base</a> (Handler_ &amp;&amp;<a class="el" href="classboost_1_1beast_1_1async__base.html#abe01a96330049c65f0de233617661813">handler</a>, Executor1 const &amp;ex1)</td></tr>
<tr class="separator:a1218a3963987b9ef48e822caf0729317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b17df82ae6aa5c1cf2241881643842a"><td class="memTemplParams" colspan="2"><a id="a6b17df82ae6aa5c1cf2241881643842a"></a>
template&lt;class Handler_ &gt; </td></tr>
<tr class="memitem:a6b17df82ae6aa5c1cf2241881643842a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>stable_async_base</b> (Handler_ &amp;&amp;<a class="el" href="classboost_1_1beast_1_1async__base.html#abe01a96330049c65f0de233617661813">handler</a>, Executor1 const &amp;ex1, Allocator const &amp;alloc)</td></tr>
<tr class="separator:a6b17df82ae6aa5c1cf2241881643842a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab111c2b67adc9770b67a96de5081a6a0"><td class="memItemLeft" align="right" valign="top"><a id="ab111c2b67adc9770b67a96de5081a6a0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1stable__async__base.html#ab111c2b67adc9770b67a96de5081a6a0">stable_async_base</a> (<a class="el" href="classboost_1_1beast_1_1stable__async__base.html">stable_async_base</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:ab111c2b67adc9770b67a96de5081a6a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move Constructor <br /></td></tr>
<tr class="separator:ab111c2b67adc9770b67a96de5081a6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f88ef066879570ae5f380f2318bcea8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1stable__async__base.html#a4f88ef066879570ae5f380f2318bcea8">~stable_async_base</a> ()</td></tr>
<tr class="separator:a4f88ef066879570ae5f380f2318bcea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classboost_1_1beast_1_1async__base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classboost_1_1beast_1_1async__base')"><img src="closed.png" alt="-"/>&#160;基底クラス <a class="el" href="classboost_1_1beast_1_1async__base.html">boost::beast::async_base&lt; Handler, Executor1, std::allocator&lt; void &gt; &gt;</a> に属する継承公開メンバ関数</td></tr>
<tr class="memitem:a99299e04284c1195525a4d63f33f0cf4 inherit pub_methods_classboost_1_1beast_1_1async__base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1async__base.html#a99299e04284c1195525a4d63f33f0cf4">async_base</a> (Handler_ &amp;&amp;<a class="el" href="classboost_1_1beast_1_1async__base.html#abe01a96330049c65f0de233617661813">handler</a>, Executor1 const &amp;ex1)</td></tr>
<tr class="separator:a99299e04284c1195525a4d63f33f0cf4 inherit pub_methods_classboost_1_1beast_1_1async__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49de0bbb8649957481b70d13bb9b6d40 inherit pub_methods_classboost_1_1beast_1_1async__base"><td class="memItemLeft" align="right" valign="top"><a id="a49de0bbb8649957481b70d13bb9b6d40"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>async_base</b> (Handler_ &amp;&amp;<a class="el" href="classboost_1_1beast_1_1async__base.html#abe01a96330049c65f0de233617661813">handler</a>, Executor1 const &amp;ex1, std::allocator&lt; void &gt; const &amp;alloc)</td></tr>
<tr class="separator:a49de0bbb8649957481b70d13bb9b6d40 inherit pub_methods_classboost_1_1beast_1_1async__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c48dd74e75ce95a07ec8d2f762436e inherit pub_methods_classboost_1_1beast_1_1async__base"><td class="memItemLeft" align="right" valign="top"><a id="ab7c48dd74e75ce95a07ec8d2f762436e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1async__base.html#ab7c48dd74e75ce95a07ec8d2f762436e">async_base</a> (<a class="el" href="classboost_1_1beast_1_1async__base.html">async_base</a> &amp;&amp;other)=default</td></tr>
<tr class="memdesc:ab7c48dd74e75ce95a07ec8d2f762436e inherit pub_methods_classboost_1_1beast_1_1async__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move Constructor <br /></td></tr>
<tr class="separator:ab7c48dd74e75ce95a07ec8d2f762436e inherit pub_methods_classboost_1_1beast_1_1async__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a7017977b8555f42fa535c27ebdb34 inherit pub_methods_classboost_1_1beast_1_1async__base"><td class="memItemLeft" align="right" valign="top"><a id="a74a7017977b8555f42fa535c27ebdb34"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>async_base</b> (<a class="el" href="classboost_1_1beast_1_1async__base.html">async_base</a> const &amp;)=delete</td></tr>
<tr class="separator:a74a7017977b8555f42fa535c27ebdb34 inherit pub_methods_classboost_1_1beast_1_1async__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a371c96cef7840f5768175e590d70620b inherit pub_methods_classboost_1_1beast_1_1async__base"><td class="memItemLeft" align="right" valign="top"><a id="a371c96cef7840f5768175e590d70620b"></a>
<a class="el" href="classboost_1_1beast_1_1async__base.html">async_base</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classboost_1_1beast_1_1async__base.html">async_base</a> const &amp;)=delete</td></tr>
<tr class="separator:a371c96cef7840f5768175e590d70620b inherit pub_methods_classboost_1_1beast_1_1async__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2015267035930ff804df6cabbd1f78 inherit pub_methods_classboost_1_1beast_1_1async__base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1async__base.html#aadc29d21f36269207b3117e227c468c0">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1async__base.html#a6e2015267035930ff804df6cabbd1f78">get_allocator</a> () const noexcept</td></tr>
<tr class="separator:a6e2015267035930ff804df6cabbd1f78 inherit pub_methods_classboost_1_1beast_1_1async__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb531dd62c0c2d4b0a0846b9ab2ff8be inherit pub_methods_classboost_1_1beast_1_1async__base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1async__base.html#a34bf423eb7bb284dd1e740ed0e009b42">executor_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1async__base.html#abb531dd62c0c2d4b0a0846b9ab2ff8be">get_executor</a> () const noexcept</td></tr>
<tr class="separator:abb531dd62c0c2d4b0a0846b9ab2ff8be inherit pub_methods_classboost_1_1beast_1_1async__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe01a96330049c65f0de233617661813 inherit pub_methods_classboost_1_1beast_1_1async__base"><td class="memItemLeft" align="right" valign="top"><a id="abe01a96330049c65f0de233617661813"></a>
Handler const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1async__base.html#abe01a96330049c65f0de233617661813">handler</a> () const noexcept</td></tr>
<tr class="memdesc:abe01a96330049c65f0de233617661813 inherit pub_methods_classboost_1_1beast_1_1async__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the handler associated with this object <br /></td></tr>
<tr class="separator:abe01a96330049c65f0de233617661813 inherit pub_methods_classboost_1_1beast_1_1async__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20d783ce163443781f97dfa20c99376 inherit pub_methods_classboost_1_1beast_1_1async__base"><td class="memItemLeft" align="right" valign="top">Handler&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1async__base.html#ad20d783ce163443781f97dfa20c99376">release_handler</a> ()</td></tr>
<tr class="separator:ad20d783ce163443781f97dfa20c99376 inherit pub_methods_classboost_1_1beast_1_1async__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29215ff56ff262e4703ec56dd973166 inherit pub_methods_classboost_1_1beast_1_1async__base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1async__base.html#ad29215ff56ff262e4703ec56dd973166">complete</a> (bool is_continuation, Args &amp;&amp;... args)</td></tr>
<tr class="separator:ad29215ff56ff262e4703ec56dd973166 inherit pub_methods_classboost_1_1beast_1_1async__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264c45bc7c0def00869cc0984ac2bee8 inherit pub_methods_classboost_1_1beast_1_1async__base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1async__base.html#a264c45bc7c0def00869cc0984ac2bee8">complete_now</a> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:a264c45bc7c0def00869cc0984ac2bee8 inherit pub_methods_classboost_1_1beast_1_1async__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3de34b0ed0a41e868873946abe7fd3 inherit pub_methods_classboost_1_1beast_1_1async__base"><td class="memItemLeft" align="right" valign="top"><a id="a3c3de34b0ed0a41e868873946abe7fd3"></a>
Handler *&#160;</td><td class="memItemRight" valign="bottom"><b>get_legacy_handler_pointer</b> () noexcept</td></tr>
<tr class="separator:a3c3de34b0ed0a41e868873946abe7fd3 inherit pub_methods_classboost_1_1beast_1_1async__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
フレンド</h2></td></tr>
<tr class="memitem:a85aa5a5ab8c90eef41c20ef9bce41739"><td class="memTemplParams" colspan="2">template&lt;class State , class Handler_ , class Executor1_ , class Allocator_ , class... Args&gt; </td></tr>
<tr class="memitem:a85aa5a5ab8c90eef41c20ef9bce41739"><td class="memTemplItemLeft" align="right" valign="top">State &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1stable__async__base.html#a85aa5a5ab8c90eef41c20ef9bce41739">allocate_stable</a> (<a class="el" href="classboost_1_1beast_1_1stable__async__base.html">stable_async_base</a>&lt; Handler_, Executor1_, Allocator_ &gt; &amp;base, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a85aa5a5ab8c90eef41c20ef9bce41739"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
その他の継承メンバ</h2></td></tr>
<tr class="inherit_header pub_types_classboost_1_1beast_1_1async__base"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classboost_1_1beast_1_1async__base')"><img src="closed.png" alt="-"/>&#160;基底クラス <a class="el" href="classboost_1_1beast_1_1async__base.html">boost::beast::async_base&lt; Handler, Executor1, std::allocator&lt; void &gt; &gt;</a> に属する継承公開型</td></tr>
<tr class="memitem:a34bf423eb7bb284dd1e740ed0e009b42 inherit pub_types_classboost_1_1beast_1_1async__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1async__base.html#a34bf423eb7bb284dd1e740ed0e009b42">executor_type</a> = typename <a class="el" href="structboost_1_1asio_1_1associated__executor.html">net::associated_executor</a>&lt; Handler, typename detail::select_work_guard_t&lt; Executor1 &gt;::<a class="el" href="classboost_1_1beast_1_1async__base.html#a34bf423eb7bb284dd1e740ed0e009b42">executor_type</a> &gt;::type</td></tr>
<tr class="separator:a34bf423eb7bb284dd1e740ed0e009b42 inherit pub_types_classboost_1_1beast_1_1async__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc29d21f36269207b3117e227c468c0 inherit pub_types_classboost_1_1beast_1_1async__base"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1async__base.html#aadc29d21f36269207b3117e227c468c0">allocator_type</a> = net::associated_allocator_t&lt; Handler, std::allocator&lt; void &gt; &gt;</td></tr>
<tr class="separator:aadc29d21f36269207b3117e227c468c0 inherit pub_types_classboost_1_1beast_1_1async__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">詳解</h2>
<div class="textblock"><h3>template&lt;class Handler, class Executor1, class Allocator = std::allocator&lt;void&gt;&gt;<br />
class boost::beast::stable_async_base&lt; Handler, Executor1, Allocator &gt;</h3>

<p>Base class to provide completion handler boilerplate for composed operations.</p>
<p>A function object submitted to intermediate initiating functions during a composed operation may derive from this type to inherit all of the boilerplate to forward the executor, allocator, and legacy customization points associated with the completion handler invoked at the end of the composed operation.</p>
<p>The composed operation must be typical; that is, associated with one executor of an I/O object, and invoking a caller-provided completion handler when the operation is finished. Classes derived from <a class="el" href="classboost_1_1beast_1_1async__base.html">async_base</a> will acquire these properties:</p>
<ul>
<li>Ownership of the final completion handler provided upon construction.</li>
</ul>
<ul>
<li>If the final handler has an associated allocator, this allocator will be propagated to the composed operation subclass. Otherwise, the associated allocator will be the type specified in the allocator template parameter, or the default of <code>std::allocator&lt;void&gt;</code> if the parameter is omitted.</li>
</ul>
<ul>
<li>If the final handler has an associated executor, then it will be used as the executor associated with the composed operation. Otherwise, the specified <code>Executor1</code> will be the type of executor associated with the composed operation.</li>
</ul>
<ul>
<li>An instance of <code>net::executor_work_guard</code> for the instance of <code>Executor1</code> shall be maintained until either the final handler is invoked, or the operation base is destroyed, whichever comes first.</li>
</ul>
<ul>
<li>Calls to the legacy customization points <code>asio_handler_invoke</code>, <code>asio_handler_allocate</code>, <code>asio_handler_deallocate</code>, and <code>asio_handler_is_continuation</code>, which use argument-dependent lookup, will be forwarded to the legacy customization points associated with the handler.</li>
</ul>
<p>Data members of composed operations implemented as completion handlers do not have stable addresses, as the composed operation object is move constructed upon each call to an initiating function. For most operations this is not a problem. For complex operations requiring stable temporary storage, the class <a class="el" href="classboost_1_1beast_1_1stable__async__base.html">stable_async_base</a> is provided which offers additional functionality:</p>
<ul>
<li>The free function beast::allocate_stable may be used to allocate one or more temporary objects associated with the composed operation.</li>
</ul>
<ul>
<li>Memory for stable temporary objects is allocated using the allocator associated with the composed operation.</li>
</ul>
<ul>
<li>Stable temporary objects are automatically destroyed, and the memory freed using the associated allocator, either before the final completion handler is invoked (a Networking requirement) or when the composed operation is destroyed, whichever occurs first.</li>
</ul>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<p>The following code demonstrates how <a class="el" href="classboost_1_1beast_1_1stable__async__base.html">stable_async_base</a> may be be used to assist authoring an asynchronous initiating function, by providing all of the boilerplate to manage the final completion handler in a way that maintains the allocator and executor associations. Furthermore, the operation shown allocates temporary memory using beast::allocate_stable for the timer and message, whose addresses must not change between intermediate operations:</p>
<div class="fragment"><div class="line"><span class="comment">// Asynchronously send a message multiple times, once per second</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> AsyncWriteStream, <span class="keyword">class</span> T, <span class="keyword">class</span> WriteHandler&gt;</div>
<div class="line"><span class="keyword">auto</span> async_write_messages(</div>
<div class="line">    AsyncWriteStream&amp; stream,</div>
<div class="line">    T <span class="keyword">const</span>&amp; message,</div>
<div class="line">    std::size_t repeat_count,</div>
<div class="line">    WriteHandler&amp;&amp; <a class="code" href="classboost_1_1beast_1_1async__base.html#abe01a96330049c65f0de233617661813">handler</a>) -&gt;</div>
<div class="line">        <span class="keyword">typename</span> <a class="code" href="classboost_1_1asio_1_1async__result.html">net::async_result</a>&lt;</div>
<div class="line">            <span class="keyword">typename</span> std::decay&lt;WriteHandler&gt;::type,</div>
<div class="line">            void(error_code)&gt;::return_type</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> handler_type = <span class="keyword">typename</span> <a class="code" href="structboost_1_1asio_1_1async__completion.html">net::async_completion</a>&lt;WriteHandler, void(error_code)&gt;::completion_handler_type;</div>
<div class="line">    <span class="keyword">using</span> base_type = stable_async_base&lt;handler_type, typename AsyncWriteStream::executor_type&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">struct </span>op : base_type, <a class="code" href="classboost_1_1asio_1_1coroutine.html">boost::asio::coroutine</a></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// This object must have a stable address</span></div>
<div class="line">        <span class="keyword">struct </span>temporary_data</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Although std::string is in theory movable, most implementations</span></div>
<div class="line">            <span class="comment">// use a &quot;small buffer optimization&quot; which means that we might</span></div>
<div class="line">            <span class="comment">// be submitting a buffer to the write operation and then</span></div>
<div class="line">            <span class="comment">// moving the string, invalidating the buffer. To prevent</span></div>
<div class="line">            <span class="comment">// undefined behavior we store the string object itself at</span></div>
<div class="line">            <span class="comment">// a stable location.</span></div>
<div class="line">            std::string <span class="keyword">const</span> message;</div>
<div class="line"> </div>
<div class="line">            net::steady_timer timer;</div>
<div class="line"> </div>
<div class="line">            temporary_data(std::string message_, <a class="code" href="classboost_1_1asio_1_1io__context.html">net::io_context</a>&amp; ctx)</div>
<div class="line">                : message(std::move(message_))</div>
<div class="line">                , timer(ctx)</div>
<div class="line">            {</div>
<div class="line">            }</div>
<div class="line">        };</div>
<div class="line"> </div>
<div class="line">        AsyncWriteStream&amp; stream_;</div>
<div class="line">        std::size_t repeats_;</div>
<div class="line">        temporary_data&amp; data_;</div>
<div class="line"> </div>
<div class="line">        op(AsyncWriteStream&amp; stream, std::size_t repeats, std::string message, handler_type&amp; <a class="code" href="classboost_1_1beast_1_1async__base.html#abe01a96330049c65f0de233617661813">handler</a>)</div>
<div class="line">            : base_type(std::move(<a class="code" href="classboost_1_1beast_1_1async__base.html#abe01a96330049c65f0de233617661813">handler</a>), stream.<a class="code" href="classboost_1_1beast_1_1async__base.html#abb531dd62c0c2d4b0a0846b9ab2ff8be">get_executor</a>())</div>
<div class="line">            , stream_(stream)</div>
<div class="line">            , repeats_(repeats)</div>
<div class="line">            , data_(<a class="code" href="classboost_1_1beast_1_1stable__async__base.html#a85aa5a5ab8c90eef41c20ef9bce41739">allocate_stable</a>&lt;temporary_data&gt;(*this, std::move(message), stream.<a class="code" href="classboost_1_1beast_1_1async__base.html#abb531dd62c0c2d4b0a0846b9ab2ff8be">get_executor</a>().context()))</div>
<div class="line">        {</div>
<div class="line">            (*this)(); <span class="comment">// start the operation</span></div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Including this file provides the keywords for macro-based coroutines</span></div>
<div class="line"><span class="preprocessor">        #include &lt;boost/asio/yield.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">void</span> operator()(error_code ec = {}, std::size_t = 0)</div>
<div class="line">        {</div>
<div class="line">            reenter(*<span class="keyword">this</span>)</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">// If repeats starts at 0 then we must complete immediately. But</span></div>
<div class="line">                <span class="comment">// we can&#39;t call the final handler from inside the initiating</span></div>
<div class="line">                <span class="comment">// function, so we post our intermediate handler first. We use</span></div>
<div class="line">                <span class="comment">// net::async_write with an empty buffer instead of calling</span></div>
<div class="line">                <span class="comment">// net::post to avoid an extra function template instantiation, to</span></div>
<div class="line">                <span class="comment">// keep compile times lower and make the resulting executable smaller.</span></div>
<div class="line">                yield net::async_write(stream_, <a class="code" href="classboost_1_1asio_1_1const__buffer.html">net::const_buffer</a>{}, std::move(*<span class="keyword">this</span>));</div>
<div class="line">                <span class="keywordflow">while</span>(! ec &amp;&amp; repeats_-- &gt; 0)</div>
<div class="line">                {</div>
<div class="line">                    <span class="comment">// Send the string. We construct a `const_buffer` here to guarantee</span></div>
<div class="line">                    <span class="comment">// that we do not create an additional function template instantation</span></div>
<div class="line">                    <span class="comment">// of net::async_write, since we already instantiated it above for</span></div>
<div class="line">                    <span class="comment">// net::const_buffer.</span></div>
<div class="line"> </div>
<div class="line">                    yield net::async_write(stream_,</div>
<div class="line">                        <a class="code" href="classboost_1_1asio_1_1const__buffer.html">net::const_buffer</a>(net::buffer(data_.message)), std::move(*<span class="keyword">this</span>));</div>
<div class="line">                    <span class="keywordflow">if</span>(ec)</div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line"> </div>
<div class="line">                    <span class="comment">// Set the timer and wait</span></div>
<div class="line">                    data_.timer.expires_after(std::chrono::seconds(1));</div>
<div class="line">                    yield data_.timer.async_wait(std::move(*<span class="keyword">this</span>));</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// The base class destroys the temporary data automatically,</span></div>
<div class="line">            <span class="comment">// before invoking the final completion handler</span></div>
<div class="line">            this-&gt;<a class="code" href="classboost_1_1beast_1_1async__base.html#a264c45bc7c0def00869cc0984ac2bee8">complete_now</a>(ec);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Including this file undefines the macros for the coroutines</span></div>
<div class="line"><span class="preprocessor">        #include &lt;boost/asio/unyield.hpp&gt;</span></div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="structboost_1_1asio_1_1async__completion.html">net::async_completion</a>&lt;WriteHandler, void(error_code)&gt; completion(<a class="code" href="classboost_1_1beast_1_1async__base.html#abe01a96330049c65f0de233617661813">handler</a>);</div>
<div class="line">    std::ostringstream os;</div>
<div class="line">    os &lt;&lt; message;</div>
<div class="line">    op(stream, repeat_count, os.str(), completion.completion_handler);</div>
<div class="line">    <span class="keywordflow">return</span> completion.result.get();</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Handler</td><td>The type of the completion handler to store. This type must meet the requirements of <em>CompletionHandler</em>.</td></tr>
    <tr><td class="paramname">Executor1</td><td>The type of the executor used when the handler has no associated executor. An instance of this type must be provided upon construction. The implementation will maintain an executor work guard and a copy of this instance.</td></tr>
    <tr><td class="paramname">Allocator</td><td>The allocator type to use if the handler does not have an associated allocator. If this parameter is omitted, then <code>std::allocator&lt;void&gt;</code> will be used. If the specified allocator is not default constructible, an instance of the type must be provided upon construction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>参照</dt><dd><a class="el" href="classboost_1_1beast_1_1stable__async__base.html#a85aa5a5ab8c90eef41c20ef9bce41739">allocate_stable</a>, <a class="el" href="classboost_1_1beast_1_1async__base.html">async_base</a> </dd></dl>
</div><h2 class="groupheader">構築子と解体子</h2>
<a id="a1218a3963987b9ef48e822caf0729317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1218a3963987b9ef48e822caf0729317">&#9670;&nbsp;</a></span>stable_async_base()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Handler , class Executor1 , class Allocator  = std::allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Handler_ , class  = typename std::enable_if&lt;            ! std::is_same&lt;typename                std::decay&lt;Handler_&gt;::type,                stable_async_base            &gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1stable__async__base.html">boost::beast::stable_async_base</a>&lt; Handler, Executor1, Allocator &gt;::<a class="el" href="classboost_1_1beast_1_1stable__async__base.html">stable_async_base</a> </td>
          <td>(</td>
          <td class="paramtype">Handler_ &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Executor1 const &amp;&#160;</td>
          <td class="paramname"><em>ex1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>The final completion handler. The type of this object must meet the requirements of <em>CompletionHandler</em>. The implementation takes ownership of the handler by performing a decay-copy.</td></tr>
    <tr><td class="paramname">ex1</td><td>The executor associated with the implied I/O object target of the operation. The implementation shall maintain an executor work guard for the lifetime of the operation, or until the final completion handler is invoked, whichever is shorter.</td></tr>
    <tr><td class="paramname">alloc</td><td>The allocator to be associated with objects derived from this class. If <code>Allocator</code> is default-constructible, this parameter is optional and may be omitted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f88ef066879570ae5f380f2318bcea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f88ef066879570ae5f380f2318bcea8">&#9670;&nbsp;</a></span>~stable_async_base()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Handler , class Executor1 , class Allocator  = std::allocator&lt;void&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1stable__async__base.html">boost::beast::stable_async_base</a>&lt; Handler, Executor1, Allocator &gt;::~<a class="el" href="classboost_1_1beast_1_1stable__async__base.html">stable_async_base</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor</p>
<p>If the completion handler was not invoked, then any state objects allocated with <a class="el" href="classboost_1_1beast_1_1stable__async__base.html#a85aa5a5ab8c90eef41c20ef9bce41739">allocate_stable</a> will be destroyed here. </p>

</div>
</div>
<h2 class="groupheader">フレンドと関連関数の詳解</h2>
<a id="a85aa5a5ab8c90eef41c20ef9bce41739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85aa5a5ab8c90eef41c20ef9bce41739">&#9670;&nbsp;</a></span>allocate_stable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Handler , class Executor1 , class Allocator  = std::allocator&lt;void&gt;&gt; </div>
<div class="memtemplate">
template&lt;class State , class Handler_ , class Executor1_ , class Allocator_ , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">State&amp; allocate_stable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1stable__async__base.html">stable_async_base</a>&lt; Handler_, Executor1_, Allocator_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocate a temporary object to hold operation state.</p>
<p>The object will be destroyed just before the completion handler is invoked, or when the operation base is destroyed. </p>

</div>
</div>
<hr/>このクラス詳解は次のファイルから抽出されました:<ul>
<li>include/external/boost/boost/beast/core/<a class="el" href="async__base_8hpp_source.html">async_base.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="aclassboost_1_1asio_1_1io__context_html"><div class="ttname"><a href="classboost_1_1asio_1_1io__context.html">boost::asio::io_context</a></div><div class="ttdoc">Provides core I/O functionality.</div><div class="ttdef"><b>Definition:</b> io_context.hpp:212</div></div>
<div class="ttc" id="aclassboost_1_1asio_1_1const__buffer_html"><div class="ttname"><a href="classboost_1_1asio_1_1const__buffer.html">boost::asio::const_buffer</a></div><div class="ttdoc">Holds a buffer that cannot be modified.</div><div class="ttdef"><b>Definition:</b> buffer.hpp:227</div></div>
<div class="ttc" id="aclassboost_1_1beast_1_1async__base_html_abb531dd62c0c2d4b0a0846b9ab2ff8be"><div class="ttname"><a href="classboost_1_1beast_1_1async__base.html#abb531dd62c0c2d4b0a0846b9ab2ff8be">boost::beast::async_base&lt; Handler, Executor1, std::allocator&lt; void &gt; &gt;::get_executor</a></div><div class="ttdeci">executor_type get_executor() const noexcept</div><div class="ttdef"><b>Definition:</b> async_base.hpp:305</div></div>
<div class="ttc" id="aclassboost_1_1beast_1_1async__base_html_abe01a96330049c65f0de233617661813"><div class="ttname"><a href="classboost_1_1beast_1_1async__base.html#abe01a96330049c65f0de233617661813">boost::beast::async_base&lt; Handler, Executor1, std::allocator&lt; void &gt; &gt;::handler</a></div><div class="ttdeci">Handler const &amp; handler() const noexcept</div><div class="ttdoc">Returns the handler associated with this object</div><div class="ttdef"><b>Definition:</b> async_base.hpp:313</div></div>
<div class="ttc" id="aclassboost_1_1beast_1_1stable__async__base_html_a85aa5a5ab8c90eef41c20ef9bce41739"><div class="ttname"><a href="classboost_1_1beast_1_1stable__async__base.html#a85aa5a5ab8c90eef41c20ef9bce41739">boost::beast::stable_async_base::allocate_stable</a></div><div class="ttdeci">friend State &amp; allocate_stable(stable_async_base&lt; Handler_, Executor1_, Allocator_ &gt; &amp;base, Args &amp;&amp;... args)</div></div>
<div class="ttc" id="aclassboost_1_1asio_1_1async__result_html"><div class="ttname"><a href="classboost_1_1asio_1_1async__result.html">boost::asio::async_result</a></div><div class="ttdoc">An interface for customising the behaviour of an initiating function.</div><div class="ttdef"><b>Definition:</b> async_result.hpp:107</div></div>
<div class="ttc" id="astructboost_1_1asio_1_1async__completion_html"><div class="ttname"><a href="structboost_1_1asio_1_1async__completion.html">boost::asio::async_completion</a></div><div class="ttdef"><b>Definition:</b> async_result.hpp:207</div></div>
<div class="ttc" id="aclassboost_1_1beast_1_1async__base_html_a264c45bc7c0def00869cc0984ac2bee8"><div class="ttname"><a href="classboost_1_1beast_1_1async__base.html#a264c45bc7c0def00869cc0984ac2bee8">boost::beast::async_base&lt; Handler, Executor1, std::allocator&lt; void &gt; &gt;::complete_now</a></div><div class="ttdeci">void complete_now(Args &amp;&amp;... args)</div><div class="ttdef"><b>Definition:</b> async_base.hpp:388</div></div>
<div class="ttc" id="aclassboost_1_1asio_1_1coroutine_html"><div class="ttname"><a href="classboost_1_1asio_1_1coroutine.html">boost::asio::coroutine</a></div><div class="ttdoc">Provides support for implementing stackless coroutines.</div><div class="ttdef"><b>Definition:</b> coroutine.hpp:242</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceboost.html">boost</a></li><li class="navelem"><b>beast</b></li><li class="navelem"><a class="el" href="classboost_1_1beast_1_1stable__async__base.html">stable_async_base</a></li>
    <li class="footer">構築:
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
