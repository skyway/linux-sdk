<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
<head>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
        'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
        })(window,document,'script','dataLayer','GTM-NN5JX4B');</script>
    <!-- End Google Tag Manager -->
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=11"/>
    <meta name="generator" content="Doxygen 1.9.8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>SkyWay Linux SDK</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="resize.js"></script>
    <script type="text/javascript" src="navtreedata.js"></script>
    <script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="search/searchdata.js"></script>
    <script type="text/javascript" src="search/search.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NN5JX4B"
        height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
            <tbody>
                <tr id="projectrow">
                    <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
                    <td id="projectalign">
                        <div id="projectname">SkyWay Linux SDK
                        </div>
                    </td>
                </tr>
            </tbody>
        </table>
    </div><!-- 構築: Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'検索');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','検索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classboost_1_1beast_1_1ssl__stream.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">公開型</a> &#124;
<a href="#pub-methods">公開メンバ関数</a> &#124;
<a href="#friends">フレンド</a> &#124;
<a href="classboost_1_1beast_1_1ssl__stream-members.html">全メンバ一覧</a>  </div>
  <div class="headertitle">
<div class="title">boost::beast::ssl_stream&lt; NextLayer &gt; クラステンプレート</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="ssl__stream_8hpp_source.html">ssl_stream.hpp</a>&gt;</code></p>
<div class="dynheader">
boost::beast::ssl_stream&lt; NextLayer &gt; の継承関係図</div>
<div class="dyncontent">
 <div class="center">
  <img src="classboost_1_1beast_1_1ssl__stream.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
公開型</h2></td></tr>
<tr class="memitem:aaaeda5cbf9612bdae322868feea829a1"><td class="memItemLeft" align="right" valign="top"><a id="aaaeda5cbf9612bdae322868feea829a1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html#aaaeda5cbf9612bdae322868feea829a1">native_handle_type</a> = typename ssl_stream_type::native_handle_type</td></tr>
<tr class="memdesc:aaaeda5cbf9612bdae322868feea829a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The native handle type of the SSL stream. <br /></td></tr>
<tr class="separator:aaaeda5cbf9612bdae322868feea829a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24e209290326af75c4311e0530e04b1"><td class="memItemLeft" align="right" valign="top"><a id="ad24e209290326af75c4311e0530e04b1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html#ad24e209290326af75c4311e0530e04b1">impl_struct</a> = typename ssl_stream_type::impl_struct</td></tr>
<tr class="memdesc:ad24e209290326af75c4311e0530e04b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for use with deprecated impl_type. <br /></td></tr>
<tr class="separator:ad24e209290326af75c4311e0530e04b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b15924c21ea546b5ab3c1c9b0ce4fc0"><td class="memItemLeft" align="right" valign="top"><a id="a7b15924c21ea546b5ab3c1c9b0ce4fc0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html#a7b15924c21ea546b5ab3c1c9b0ce4fc0">next_layer_type</a> = typename ssl_stream_type::next_layer_type</td></tr>
<tr class="memdesc:a7b15924c21ea546b5ab3c1c9b0ce4fc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the next layer. <br /></td></tr>
<tr class="separator:a7b15924c21ea546b5ab3c1c9b0ce4fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee69a1311aee6c9a742844b2da129216"><td class="memItemLeft" align="right" valign="top"><a id="aee69a1311aee6c9a742844b2da129216"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html#aee69a1311aee6c9a742844b2da129216">executor_type</a> = typename <a class="el" href="classboost_1_1beast_1_1flat__stream.html#a3cfc604e2737ae77defc1bb0f3badf72">stream_type::executor_type</a></td></tr>
<tr class="memdesc:aee69a1311aee6c9a742844b2da129216"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the executor associated with the object. <br /></td></tr>
<tr class="separator:aee69a1311aee6c9a742844b2da129216"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
公開メンバ関数</h2></td></tr>
<tr class="memitem:a57fcbd4908304897c9ec33a0e62315c0"><td class="memTemplParams" colspan="2">template&lt;class Arg &gt; </td></tr>
<tr class="memitem:a57fcbd4908304897c9ec33a0e62315c0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html#a57fcbd4908304897c9ec33a0e62315c0">ssl_stream</a> (Arg &amp;&amp;<a class="el" href="structarg.html">arg</a>, net::ssl::context &amp;ctx)</td></tr>
<tr class="separator:a57fcbd4908304897c9ec33a0e62315c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d9f867f400365eebc3f7d3964e6602"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html#aee69a1311aee6c9a742844b2da129216">executor_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html#a75d9f867f400365eebc3f7d3964e6602">get_executor</a> () noexcept</td></tr>
<tr class="separator:a75d9f867f400365eebc3f7d3964e6602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4152403200acb5bc3860a238aac14595"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html#aaaeda5cbf9612bdae322868feea829a1">native_handle_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html#a4152403200acb5bc3860a238aac14595">native_handle</a> () noexcept</td></tr>
<tr class="separator:a4152403200acb5bc3860a238aac14595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3adca92c85974f0f965dd695bb1ccd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html#a7b15924c21ea546b5ab3c1c9b0ce4fc0">next_layer_type</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html#aef3adca92c85974f0f965dd695bb1ccd">next_layer</a> () const noexcept</td></tr>
<tr class="separator:aef3adca92c85974f0f965dd695bb1ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac730aa905daf9e3162e926c207df1331"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html#a7b15924c21ea546b5ab3c1c9b0ce4fc0">next_layer_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html#ac730aa905daf9e3162e926c207df1331">next_layer</a> () noexcept</td></tr>
<tr class="separator:ac730aa905daf9e3162e926c207df1331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b03e61bfa89306e6ab042a4338a2684"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html#a1b03e61bfa89306e6ab042a4338a2684">set_verify_mode</a> (net::ssl::verify_mode v)</td></tr>
<tr class="separator:a1b03e61bfa89306e6ab042a4338a2684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad486a0898ee32e5cb1f3253f7ef00a9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html#ad486a0898ee32e5cb1f3253f7ef00a9f">set_verify_mode</a> (net::ssl::verify_mode v, <a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a> &amp;ec)</td></tr>
<tr class="separator:ad486a0898ee32e5cb1f3253f7ef00a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861371a1378d05c84448ca6ea9f12924"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html#a861371a1378d05c84448ca6ea9f12924">set_verify_depth</a> (int depth)</td></tr>
<tr class="separator:a861371a1378d05c84448ca6ea9f12924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8dbf921a3337fbc60a9a3cb5e795ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html#adc8dbf921a3337fbc60a9a3cb5e795ca">set_verify_depth</a> (int depth, <a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a> &amp;ec)</td></tr>
<tr class="separator:adc8dbf921a3337fbc60a9a3cb5e795ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac63d343a4d304acc25e931b92aa93ee"><td class="memTemplParams" colspan="2">template&lt;class VerifyCallback &gt; </td></tr>
<tr class="memitem:aac63d343a4d304acc25e931b92aa93ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html#aac63d343a4d304acc25e931b92aa93ee">set_verify_callback</a> (VerifyCallback callback)</td></tr>
<tr class="separator:aac63d343a4d304acc25e931b92aa93ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711d6f021ed2981c443b3e97ec7605bd"><td class="memTemplParams" colspan="2">template&lt;class VerifyCallback &gt; </td></tr>
<tr class="memitem:a711d6f021ed2981c443b3e97ec7605bd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html#a711d6f021ed2981c443b3e97ec7605bd">set_verify_callback</a> (VerifyCallback callback, <a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a> &amp;ec)</td></tr>
<tr class="separator:a711d6f021ed2981c443b3e97ec7605bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35474e3a61f593150575921f076de38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html#ae35474e3a61f593150575921f076de38">handshake</a> (handshake_type <a class="el" href="structboost_1_1type.html">type</a>)</td></tr>
<tr class="separator:ae35474e3a61f593150575921f076de38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae137a656bca5eaf1ef70286517a19746"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html#ae137a656bca5eaf1ef70286517a19746">handshake</a> (handshake_type <a class="el" href="structboost_1_1type.html">type</a>, <a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a> &amp;ec)</td></tr>
<tr class="separator:ae137a656bca5eaf1ef70286517a19746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fcfca7d5c85d8547c3e7cb86c85dae3"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence &gt; </td></tr>
<tr class="memitem:a0fcfca7d5c85d8547c3e7cb86c85dae3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html#a0fcfca7d5c85d8547c3e7cb86c85dae3">handshake</a> (handshake_type <a class="el" href="structboost_1_1type.html">type</a>, ConstBufferSequence const &amp;buffers)</td></tr>
<tr class="separator:a0fcfca7d5c85d8547c3e7cb86c85dae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93addc7137a9bd9b8dfd4cfc35d6438"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence &gt; </td></tr>
<tr class="memitem:aa93addc7137a9bd9b8dfd4cfc35d6438"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html#aa93addc7137a9bd9b8dfd4cfc35d6438">handshake</a> (handshake_type <a class="el" href="structboost_1_1type.html">type</a>, ConstBufferSequence const &amp;buffers, <a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a> &amp;ec)</td></tr>
<tr class="separator:aa93addc7137a9bd9b8dfd4cfc35d6438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2392de5358c64c8806f890bbe48ddbb1"><td class="memTemplParams" colspan="2">template&lt;class HandshakeHandler &gt; </td></tr>
<tr class="memitem:a2392de5358c64c8806f890bbe48ddbb1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html#a2392de5358c64c8806f890bbe48ddbb1">async_handshake</a> (handshake_type <a class="el" href="structboost_1_1type.html">type</a>, BOOST_ASIO_MOVE_ARG(HandshakeHandler) handler)</td></tr>
<tr class="separator:a2392de5358c64c8806f890bbe48ddbb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b9f5e809a96a125b22e451726d9276"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence , class BufferedHandshakeHandler &gt; </td></tr>
<tr class="memitem:a91b9f5e809a96a125b22e451726d9276"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html#a91b9f5e809a96a125b22e451726d9276">async_handshake</a> (handshake_type <a class="el" href="structboost_1_1type.html">type</a>, ConstBufferSequence const &amp;buffers, BOOST_ASIO_MOVE_ARG(BufferedHandshakeHandler) handler)</td></tr>
<tr class="separator:a91b9f5e809a96a125b22e451726d9276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8cc3b2d44a328a4b26bc6f87265fe0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html#a8b8cc3b2d44a328a4b26bc6f87265fe0">shutdown</a> ()</td></tr>
<tr class="separator:a8b8cc3b2d44a328a4b26bc6f87265fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4496d53e70ef490fe47ff84613fcc69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html#aa4496d53e70ef490fe47ff84613fcc69">shutdown</a> (<a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a> &amp;ec)</td></tr>
<tr class="separator:aa4496d53e70ef490fe47ff84613fcc69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d9a0fc6da78597a4bc1052308e236db"><td class="memTemplParams" colspan="2">template&lt;class ShutdownHandler &gt; </td></tr>
<tr class="memitem:a7d9a0fc6da78597a4bc1052308e236db"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html#a7d9a0fc6da78597a4bc1052308e236db">async_shutdown</a> (BOOST_ASIO_MOVE_ARG(ShutdownHandler) handler)</td></tr>
<tr class="separator:a7d9a0fc6da78597a4bc1052308e236db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885ec7242fbd91a0970bf2c42add5d42"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence &gt; </td></tr>
<tr class="memitem:a885ec7242fbd91a0970bf2c42add5d42"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html#a885ec7242fbd91a0970bf2c42add5d42">write_some</a> (ConstBufferSequence const &amp;buffers)</td></tr>
<tr class="separator:a885ec7242fbd91a0970bf2c42add5d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f93c86a985ccf78c111e533ae2d7884"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence &gt; </td></tr>
<tr class="memitem:a3f93c86a985ccf78c111e533ae2d7884"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html#a3f93c86a985ccf78c111e533ae2d7884">write_some</a> (ConstBufferSequence const &amp;buffers, <a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a> &amp;ec)</td></tr>
<tr class="separator:a3f93c86a985ccf78c111e533ae2d7884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74db1bcb44eede456291bd4ee81cf467"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence , BOOST_BEAST_ASYNC_TPARAM2 WriteHandler&gt; </td></tr>
<tr class="memitem:a74db1bcb44eede456291bd4ee81cf467"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html#a74db1bcb44eede456291bd4ee81cf467">async_write_some</a> (ConstBufferSequence const &amp;buffers, BOOST_ASIO_MOVE_ARG(WriteHandler) handler)</td></tr>
<tr class="separator:a74db1bcb44eede456291bd4ee81cf467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03cb4af46ce7726106e5b4bfb88006e7"><td class="memTemplParams" colspan="2">template&lt;class MutableBufferSequence &gt; </td></tr>
<tr class="memitem:a03cb4af46ce7726106e5b4bfb88006e7"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html#a03cb4af46ce7726106e5b4bfb88006e7">read_some</a> (MutableBufferSequence const &amp;buffers)</td></tr>
<tr class="separator:a03cb4af46ce7726106e5b4bfb88006e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1584c74725c18970cb5ac4c82847f1be"><td class="memTemplParams" colspan="2">template&lt;class MutableBufferSequence &gt; </td></tr>
<tr class="memitem:a1584c74725c18970cb5ac4c82847f1be"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html#a1584c74725c18970cb5ac4c82847f1be">read_some</a> (MutableBufferSequence const &amp;buffers, <a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a> &amp;ec)</td></tr>
<tr class="separator:a1584c74725c18970cb5ac4c82847f1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c1992e3afdbbca47f600e19f0e97c6"><td class="memTemplParams" colspan="2">template&lt;class MutableBufferSequence , BOOST_BEAST_ASYNC_TPARAM2 ReadHandler&gt; </td></tr>
<tr class="memitem:a04c1992e3afdbbca47f600e19f0e97c6"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html#a04c1992e3afdbbca47f600e19f0e97c6">async_read_some</a> (MutableBufferSequence const &amp;buffers, BOOST_ASIO_MOVE_ARG(ReadHandler) handler)</td></tr>
<tr class="separator:a04c1992e3afdbbca47f600e19f0e97c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
フレンド</h2></td></tr>
<tr class="memitem:a1239a583cb5c125a97ba5675a9458726"><td class="memTemplParams" colspan="2"><a id="a1239a583cb5c125a97ba5675a9458726"></a>
template&lt;class SyncStream &gt; </td></tr>
<tr class="memitem:a1239a583cb5c125a97ba5675a9458726"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>teardown</b> (boost::beast::role_type role, <a class="el" href="classboost_1_1beast_1_1ssl__stream.html">ssl_stream</a>&lt; SyncStream &gt; &amp;stream, <a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a> &amp;ec)</td></tr>
<tr class="separator:a1239a583cb5c125a97ba5675a9458726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379a7ad23695da65d8488f8a5232a6f8"><td class="memTemplParams" colspan="2"><a id="a379a7ad23695da65d8488f8a5232a6f8"></a>
template&lt;class AsyncStream , class TeardownHandler &gt; </td></tr>
<tr class="memitem:a379a7ad23695da65d8488f8a5232a6f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>async_teardown</b> (boost::beast::role_type role, <a class="el" href="classboost_1_1beast_1_1ssl__stream.html">ssl_stream</a>&lt; AsyncStream &gt; &amp;stream, TeardownHandler &amp;&amp;handler)</td></tr>
<tr class="separator:a379a7ad23695da65d8488f8a5232a6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">詳解</h2>
<div class="textblock"><h3>template&lt;class NextLayer&gt;<br />
class boost::beast::ssl_stream&lt; NextLayer &gt;</h3>

<p>Provides stream-oriented functionality using OpenSSL</p>
<p>The stream class template provides asynchronous and blocking stream-oriented functionality using SSL.</p>
<dl class="section user"><dt>Thread Safety</dt><dd><em>Distinct</em> <em>objects:</em> Safe.<br  />
<em>Shared</em> <em>objects:</em> Unsafe. The application must also ensure that all asynchronous operations are performed within the same implicit or explicit strand.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To use this template with a tcp_stream, you would write: <div class="fragment"><div class="line"><a class="code" href="classboost_1_1asio_1_1io__context.html">net::io_context</a> ioc;</div>
<div class="line">net::ssl::context ctx{net::ssl::context::tlsv12};</div>
<div class="line">beast::ssl_stream&lt;beast::tcp_stream&gt; sock{ioc, ctx};</div>
</div><!-- fragment --></dd></dl>
<p>In addition to providing an interface identical to <code>net::ssl::stream</code>, the wrapper has the following additional properties:</p>
<ul>
<li>Satisfies <b>MoveConstructible</b> </li>
</ul>
<ul>
<li>Satisfies <b>MoveAssignable</b> </li>
</ul>
<ul>
<li>Constructible from a moved socket.</li>
</ul>
<ul>
<li>Uses <a class="el" href="classboost_1_1beast_1_1flat__stream.html">flat_stream</a> internally, as a performance work-around for a limitation of <code>net::ssl::stream</code> when writing buffer sequences having length greater than one.</li>
</ul>
<dl class="section user"><dt>Concepts:</dt><dd><ul>
<li>AsyncReadStream </li>
<li>AsyncWriteStream </li>
<li>Stream </li>
<li>SyncReadStream </li>
<li>SyncWriteStream </li>
</ul>
</dd></dl>
</div><h2 class="groupheader">構築子と解体子</h2>
<a id="a57fcbd4908304897c9ec33a0e62315c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57fcbd4908304897c9ec33a0e62315c0">&#9670;&nbsp;</a></span>ssl_stream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class Arg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html">boost::beast::ssl_stream</a>&lt; NextLayer &gt;::<a class="el" href="classboost_1_1beast_1_1ssl__stream.html">ssl_stream</a> </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">net::ssl::context &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct a stream.</p>
<p>This constructor creates a stream and initialises the underlying stream object.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The argument to be passed to initialise the underlying stream.</td></tr>
    <tr><td class="paramname">ctx</td><td>The SSL context to be used for the stream. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">関数詳解</h2>
<a id="a2392de5358c64c8806f890bbe48ddbb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2392de5358c64c8806f890bbe48ddbb1">&#9670;&nbsp;</a></span>async_handshake() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class HandshakeHandler &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html">boost::beast::ssl_stream</a>&lt; NextLayer &gt;::async_handshake </td>
          <td>(</td>
          <td class="paramtype">handshake_type&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOST_ASIO_MOVE_ARG(HandshakeHandler)&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous SSL handshake.</p>
<p>This function is used to asynchronously perform an SSL handshake on the stream. This function call always returns immediately.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of handshaking to be performed, i.e. as a client or as a server.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the handshake operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>&amp; error <span class="comment">// Result of operation.</span></div>
<div class="line">); </div>
</div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91b9f5e809a96a125b22e451726d9276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91b9f5e809a96a125b22e451726d9276">&#9670;&nbsp;</a></span>async_handshake() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence , class BufferedHandshakeHandler &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html">boost::beast::ssl_stream</a>&lt; NextLayer &gt;::async_handshake </td>
          <td>(</td>
          <td class="paramtype">handshake_type&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOST_ASIO_MOVE_ARG(BufferedHandshakeHandler)&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous SSL handshake.</p>
<p>This function is used to asynchronously perform an SSL handshake on the stream. This function call always returns immediately.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of handshaking to be performed, i.e. as a client or as a server.</td></tr>
    <tr><td class="paramname">buffers</td><td>The buffered data to be reused for the handshake. Although the buffers object may be copied as necessary, ownership of the underlying buffers is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the handshake operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>&amp; error, <span class="comment">// Result of operation.</span></div>
<div class="line">  std::size_t bytes_transferred <span class="comment">// Amount of buffers used in handshake.</span></div>
<div class="line">); </div>
</div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04c1992e3afdbbca47f600e19f0e97c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c1992e3afdbbca47f600e19f0e97c6">&#9670;&nbsp;</a></span>async_read_some()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class MutableBufferSequence , BOOST_BEAST_ASYNC_TPARAM2 ReadHandler&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html">boost::beast::ssl_stream</a>&lt; NextLayer &gt;::async_read_some </td>
          <td>(</td>
          <td class="paramtype">MutableBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOST_ASIO_MOVE_ARG(ReadHandler)&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous read.</p>
<p>This function is used to asynchronously read one or more bytes of data from the stream. The function call always returns immediately.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The buffers into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying buffers is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>&amp; error, <span class="comment">// Result of operation.</span></div>
<div class="line">  std::size_t bytes_transferred           <span class="comment">// Number of bytes read.</span></div>
<div class="line">); </div>
</div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>The <code>async_read_some</code> operation may not read all of the requested number of bytes. Consider using the <code>net::async_read</code> function if you need to ensure that the requested amount of data is read before the asynchronous operation completes. </dd></dl>

</div>
</div>
<a id="a7d9a0fc6da78597a4bc1052308e236db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d9a0fc6da78597a4bc1052308e236db">&#9670;&nbsp;</a></span>async_shutdown()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class ShutdownHandler &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html">boost::beast::ssl_stream</a>&lt; NextLayer &gt;::async_shutdown </td>
          <td>(</td>
          <td class="paramtype">BOOST_ASIO_MOVE_ARG(ShutdownHandler)&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronously shut down SSL on the stream.</p>
<p>This function is used to asynchronously shut down SSL on the stream. This function call always returns immediately.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>The handler to be called when the handshake operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>&amp; error <span class="comment">// Result of operation.</span></div>
<div class="line">); </div>
</div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74db1bcb44eede456291bd4ee81cf467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74db1bcb44eede456291bd4ee81cf467">&#9670;&nbsp;</a></span>async_write_some()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence , BOOST_BEAST_ASYNC_TPARAM2 WriteHandler&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html">boost::beast::ssl_stream</a>&lt; NextLayer &gt;::async_write_some </td>
          <td>(</td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOST_ASIO_MOVE_ARG(WriteHandler)&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start an asynchronous write.</p>
<p>This function is used to asynchronously write one or more bytes of data to the stream. The function call always returns immediately.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The data to be written to the stream. Although the buffers object may be copied as necessary, ownership of the underlying buffers is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the write operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a>&amp; error, <span class="comment">// Result of operation.</span></div>
<div class="line">  std::size_t bytes_transferred           <span class="comment">// Number of bytes written.</span></div>
<div class="line">); </div>
</div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>The <code>async_write_some</code> operation may not transmit all of the data to the peer. Consider using the <code>net::async_write</code> function if you need to ensure that all data is written before the asynchronous operation completes. </dd></dl>

</div>
</div>
<a id="a75d9f867f400365eebc3f7d3964e6602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d9f867f400365eebc3f7d3964e6602">&#9670;&nbsp;</a></span>get_executor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html#aee69a1311aee6c9a742844b2da129216">executor_type</a> <a class="el" href="classboost_1_1beast_1_1ssl__stream.html">boost::beast::ssl_stream</a>&lt; NextLayer &gt;::get_executor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the executor associated with the object.</p>
<p>This function may be used to obtain the executor object that the stream uses to dispatch handlers for asynchronous operations.</p>
<dl class="section return"><dt>戻り値</dt><dd>A copy of the executor that stream will use to dispatch handlers. </dd></dl>

</div>
</div>
<a id="ae35474e3a61f593150575921f076de38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae35474e3a61f593150575921f076de38">&#9670;&nbsp;</a></span>handshake() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1ssl__stream.html">boost::beast::ssl_stream</a>&lt; NextLayer &gt;::handshake </td>
          <td>(</td>
          <td class="paramtype">handshake_type&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform SSL handshaking.</p>
<p>This function is used to perform SSL handshaking on the stream. The function call will block until handshaking is complete or an error occurs.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of handshaking to be performed, i.e. as a client or as a server.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classboost_1_1system_1_1system__error.html">boost::system::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae137a656bca5eaf1ef70286517a19746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae137a656bca5eaf1ef70286517a19746">&#9670;&nbsp;</a></span>handshake() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1ssl__stream.html">boost::beast::ssl_stream</a>&lt; NextLayer &gt;::handshake </td>
          <td>(</td>
          <td class="paramtype">handshake_type&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform SSL handshaking.</p>
<p>This function is used to perform SSL handshaking on the stream. The function call will block until handshaking is complete or an error occurs.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of handshaking to be performed, i.e. as a client or as a server.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0fcfca7d5c85d8547c3e7cb86c85dae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fcfca7d5c85d8547c3e7cb86c85dae3">&#9670;&nbsp;</a></span>handshake() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1ssl__stream.html">boost::beast::ssl_stream</a>&lt; NextLayer &gt;::handshake </td>
          <td>(</td>
          <td class="paramtype">handshake_type&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform SSL handshaking.</p>
<p>This function is used to perform SSL handshaking on the stream. The function call will block until handshaking is complete or an error occurs.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of handshaking to be performed, i.e. as a client or as a server.</td></tr>
    <tr><td class="paramname">buffers</td><td>The buffered data to be reused for the handshake.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classboost_1_1system_1_1system__error.html">boost::system::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa93addc7137a9bd9b8dfd4cfc35d6438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa93addc7137a9bd9b8dfd4cfc35d6438">&#9670;&nbsp;</a></span>handshake() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1ssl__stream.html">boost::beast::ssl_stream</a>&lt; NextLayer &gt;::handshake </td>
          <td>(</td>
          <td class="paramtype">handshake_type&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform SSL handshaking.</p>
<p>This function is used to perform SSL handshaking on the stream. The function call will block until handshaking is complete or an error occurs.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of handshaking to be performed, i.e. as a client or as a server.</td></tr>
    <tr><td class="paramname">buffers</td><td>The buffered data to be reused for the handshake.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4152403200acb5bc3860a238aac14595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4152403200acb5bc3860a238aac14595">&#9670;&nbsp;</a></span>native_handle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html#aaaeda5cbf9612bdae322868feea829a1">native_handle_type</a> <a class="el" href="classboost_1_1beast_1_1ssl__stream.html">boost::beast::ssl_stream</a>&lt; NextLayer &gt;::native_handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the underlying implementation in the native type.</p>
<p>This function may be used to obtain the underlying implementation of the context. This is intended to allow access to context functionality that is not otherwise provided.</p>
<dl class="section user"><dt>Example</dt><dd>The <a class="el" href="classboost_1_1beast_1_1ssl__stream.html#a4152403200acb5bc3860a238aac14595">native_handle()</a> function returns a pointer of type <code>SSL*</code> that is suitable for passing to functions such as <code>SSL_get_verify_result</code> and <code>SSL_get_peer_certificate:</code> <div class="fragment"><div class="line"><a class="code" href="classboost_1_1beast_1_1ssl__stream.html">boost::beast::ssl_stream&lt;net::ip::tcp::socket&gt;</a> ss{ioc, ctx};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ... establish connection and perform handshake ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (X509* cert = SSL_get_peer_certificate(ss.native_handle()))</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (SSL_get_verify_result(ss.native_handle()) == X509_V_OK)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aef3adca92c85974f0f965dd695bb1ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef3adca92c85974f0f965dd695bb1ccd">&#9670;&nbsp;</a></span>next_layer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html#a7b15924c21ea546b5ab3c1c9b0ce4fc0">next_layer_type</a> const&amp; <a class="el" href="classboost_1_1beast_1_1ssl__stream.html">boost::beast::ssl_stream</a>&lt; NextLayer &gt;::next_layer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a reference to the next layer.</p>
<p>This function returns a reference to the next layer in a stack of stream layers.</p>
<dl class="section note"><dt>覚え書き</dt><dd>The next layer is the wrapped stream and not the <a class="el" href="classboost_1_1beast_1_1flat__stream.html">flat_stream</a> used in the implementation.</dd></dl>
<dl class="section return"><dt>戻り値</dt><dd>A reference to the next layer in the stack of stream layers. Ownership is not transferred to the caller. </dd></dl>

</div>
</div>
<a id="ac730aa905daf9e3162e926c207df1331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac730aa905daf9e3162e926c207df1331">&#9670;&nbsp;</a></span>next_layer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html#a7b15924c21ea546b5ab3c1c9b0ce4fc0">next_layer_type</a>&amp; <a class="el" href="classboost_1_1beast_1_1ssl__stream.html">boost::beast::ssl_stream</a>&lt; NextLayer &gt;::next_layer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a reference to the next layer.</p>
<p>This function returns a reference to the next layer in a stack of stream layers.</p>
<dl class="section note"><dt>覚え書き</dt><dd>The next layer is the wrapped stream and not the <a class="el" href="classboost_1_1beast_1_1flat__stream.html">flat_stream</a> used in the implementation.</dd></dl>
<dl class="section return"><dt>戻り値</dt><dd>A reference to the next layer in the stack of stream layers. Ownership is not transferred to the caller. </dd></dl>

</div>
</div>
<a id="a03cb4af46ce7726106e5b4bfb88006e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03cb4af46ce7726106e5b4bfb88006e7">&#9670;&nbsp;</a></span>read_some() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class MutableBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1ssl__stream.html">boost::beast::ssl_stream</a>&lt; NextLayer &gt;::read_some </td>
          <td>(</td>
          <td class="paramtype">MutableBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read some data from the stream.</p>
<p>This function is used to read data from the stream. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The buffers into which the data will be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The number of bytes read.</dd></dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classboost_1_1system_1_1system__error.html">boost::system::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>The <code>read_some</code> operation may not read all of the requested number of bytes. Consider using the <code>net::read</code> function if you need to ensure that the requested amount of data is read before the blocking operation completes. </dd></dl>

</div>
</div>
<a id="a1584c74725c18970cb5ac4c82847f1be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1584c74725c18970cb5ac4c82847f1be">&#9670;&nbsp;</a></span>read_some() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class MutableBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1ssl__stream.html">boost::beast::ssl_stream</a>&lt; NextLayer &gt;::read_some </td>
          <td>(</td>
          <td class="paramtype">MutableBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read some data from the stream.</p>
<p>This function is used to read data from the stream. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The buffers into which the data will be read.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The number of bytes read. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>覚え書き</dt><dd>The <code>read_some</code> operation may not read all of the requested number of bytes. Consider using the <code>net::read</code> function if you need to ensure that the requested amount of data is read before the blocking operation completes. </dd></dl>

</div>
</div>
<a id="aac63d343a4d304acc25e931b92aa93ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac63d343a4d304acc25e931b92aa93ee">&#9670;&nbsp;</a></span>set_verify_callback() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class VerifyCallback &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1ssl__stream.html">boost::beast::ssl_stream</a>&lt; NextLayer &gt;::set_verify_callback </td>
          <td>(</td>
          <td class="paramtype">VerifyCallback&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the callback used to verify peer certificates.</p>
<p>This function is used to specify a callback function that will be called by the implementation when it needs to verify a peer certificate.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The function object to be used for verifying a certificate. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">bool</span> verify_callback(</div>
<div class="line">  <span class="keywordtype">bool</span> preverified, <span class="comment">// True if the certificate passed pre-verification.</span></div>
<div class="line">  verify_context&amp; ctx <span class="comment">// The peer certificate and other context.</span></div>
<div class="line">); </div>
</div><!-- fragment --> The return value of the callback is true if the certificate has passed verification, false otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classboost_1_1system_1_1system__error.html">boost::system::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>Calls <code>SSL_set_verify</code>. </dd></dl>

</div>
</div>
<a id="a711d6f021ed2981c443b3e97ec7605bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a711d6f021ed2981c443b3e97ec7605bd">&#9670;&nbsp;</a></span>set_verify_callback() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class VerifyCallback &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1ssl__stream.html">boost::beast::ssl_stream</a>&lt; NextLayer &gt;::set_verify_callback </td>
          <td>(</td>
          <td class="paramtype">VerifyCallback&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the callback used to verify peer certificates.</p>
<p>This function is used to specify a callback function that will be called by the implementation when it needs to verify a peer certificate.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The function object to be used for verifying a certificate. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">bool</span> verify_callback(</div>
<div class="line">  <span class="keywordtype">bool</span> preverified, <span class="comment">// True if the certificate passed pre-verification.</span></div>
<div class="line">  net::verify_context&amp; ctx <span class="comment">// The peer certificate and other context.</span></div>
<div class="line">); </div>
</div><!-- fragment --> The return value of the callback is true if the certificate has passed verification, false otherwise.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>Calls <code>SSL_set_verify</code>. </dd></dl>

</div>
</div>
<a id="a861371a1378d05c84448ca6ea9f12924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861371a1378d05c84448ca6ea9f12924">&#9670;&nbsp;</a></span>set_verify_depth() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1ssl__stream.html">boost::beast::ssl_stream</a>&lt; NextLayer &gt;::set_verify_depth </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the peer verification depth.</p>
<p>This function may be used to configure the maximum verification depth allowed by the stream.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">depth</td><td>Maximum depth for the certificate chain verification that shall be allowed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classboost_1_1system_1_1system__error.html">boost::system::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>Calls <code>SSL_set_verify_depth</code>. </dd></dl>

</div>
</div>
<a id="adc8dbf921a3337fbc60a9a3cb5e795ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc8dbf921a3337fbc60a9a3cb5e795ca">&#9670;&nbsp;</a></span>set_verify_depth() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1ssl__stream.html">boost::beast::ssl_stream</a>&lt; NextLayer &gt;::set_verify_depth </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the peer verification depth.</p>
<p>This function may be used to configure the maximum verification depth allowed by the stream.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">depth</td><td>Maximum depth for the certificate chain verification that shall be allowed.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>Calls <code>SSL_set_verify_depth</code>. </dd></dl>

</div>
</div>
<a id="a1b03e61bfa89306e6ab042a4338a2684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b03e61bfa89306e6ab042a4338a2684">&#9670;&nbsp;</a></span>set_verify_mode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1ssl__stream.html">boost::beast::ssl_stream</a>&lt; NextLayer &gt;::set_verify_mode </td>
          <td>(</td>
          <td class="paramtype">net::ssl::verify_mode&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the peer verification mode.</p>
<p>This function may be used to configure the peer verification mode used by the stream. The new mode will override the mode inherited from the context.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A bitmask of peer verification modes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classboost_1_1system_1_1system__error.html">boost::system::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>Calls <code>SSL_set_verify</code>. </dd></dl>

</div>
</div>
<a id="ad486a0898ee32e5cb1f3253f7ef00a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad486a0898ee32e5cb1f3253f7ef00a9f">&#9670;&nbsp;</a></span>set_verify_mode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1ssl__stream.html">boost::beast::ssl_stream</a>&lt; NextLayer &gt;::set_verify_mode </td>
          <td>(</td>
          <td class="paramtype">net::ssl::verify_mode&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the peer verification mode.</p>
<p>This function may be used to configure the peer verification mode used by the stream. The new mode will override the mode inherited from the context.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A bitmask of peer verification modes. See <code>verify_mode</code> for available values.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>Calls <code>SSL_set_verify</code>. </dd></dl>

</div>
</div>
<a id="a8b8cc3b2d44a328a4b26bc6f87265fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b8cc3b2d44a328a4b26bc6f87265fe0">&#9670;&nbsp;</a></span>shutdown() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1ssl__stream.html">boost::beast::ssl_stream</a>&lt; NextLayer &gt;::shutdown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Shut down SSL on the stream.</p>
<p>This function is used to shut down SSL on the stream. The function call will block until SSL has been shut down or an error occurs.</p>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classboost_1_1system_1_1system__error.html">boost::system::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4496d53e70ef490fe47ff84613fcc69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4496d53e70ef490fe47ff84613fcc69">&#9670;&nbsp;</a></span>shutdown() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1ssl__stream.html">boost::beast::ssl_stream</a>&lt; NextLayer &gt;::shutdown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Shut down SSL on the stream.</p>
<p>This function is used to shut down SSL on the stream. The function call will block until SSL has been shut down or an error occurs.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a885ec7242fbd91a0970bf2c42add5d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a885ec7242fbd91a0970bf2c42add5d42">&#9670;&nbsp;</a></span>write_some() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1ssl__stream.html">boost::beast::ssl_stream</a>&lt; NextLayer &gt;::write_some </td>
          <td>(</td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write some data to the stream.</p>
<p>This function is used to write data on the stream. The function call will block until one or more bytes of data has been written successfully, or until an error occurs.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The data to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The number of bytes written.</dd></dl>
<dl class="exception"><dt>例外</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classboost_1_1system_1_1system__error.html">boost::system::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>The <code>write_some</code> operation may not transmit all of the data to the peer. Consider using the <code>net::write</code> function if you need to ensure that all data is written before the blocking operation completes. </dd></dl>

</div>
</div>
<a id="a3f93c86a985ccf78c111e533ae2d7884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f93c86a985ccf78c111e533ae2d7884">&#9670;&nbsp;</a></span>write_some() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1ssl__stream.html">boost::beast::ssl_stream</a>&lt; NextLayer &gt;::write_some </td>
          <td>(</td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write some data to the stream.</p>
<p>This function is used to write data on the stream. The function call will block until one or more bytes of data has been written successfully, or until an error occurs.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The data to be written to the stream.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>戻り値</dt><dd>The number of bytes written. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>覚え書き</dt><dd>The <code>write_some</code> operation may not transmit all of the data to the peer. Consider using the <code>net::write</code> function if you need to ensure that all data is written before the blocking operation completes. </dd></dl>

</div>
</div>
<hr/>このクラス詳解は次のファイルから抽出されました:<ul>
<li>include/external/boost/boost/beast/ssl/<a class="el" href="ssl__stream_8hpp_source.html">ssl_stream.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="aclassboost_1_1system_1_1error__code_html"><div class="ttname"><a href="classboost_1_1system_1_1error__code.html">boost::system::error_code</a></div><div class="ttdef"><b>Definition:</b> error_code.hpp:571</div></div>
<div class="ttc" id="aclassboost_1_1asio_1_1io__context_html"><div class="ttname"><a href="classboost_1_1asio_1_1io__context.html">boost::asio::io_context</a></div><div class="ttdoc">Provides core I/O functionality.</div><div class="ttdef"><b>Definition:</b> io_context.hpp:212</div></div>
<div class="ttc" id="aclassboost_1_1beast_1_1ssl__stream_html"><div class="ttname"><a href="classboost_1_1beast_1_1ssl__stream.html">boost::beast::ssl_stream</a></div><div class="ttdef"><b>Definition:</b> ssl_stream.hpp:73</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceboost.html">boost</a></li><li class="navelem"><b>beast</b></li><li class="navelem"><a class="el" href="classboost_1_1beast_1_1ssl__stream.html">ssl_stream</a></li>
    <li class="footer">構築:
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
