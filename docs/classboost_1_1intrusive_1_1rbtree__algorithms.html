<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
<head>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
        'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
        })(window,document,'script','dataLayer','GTM-NN5JX4B');</script>
    <!-- End Google Tag Manager -->
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=11"/>
    <meta name="generator" content="Doxygen 1.9.8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>SkyWay Linux SDK</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="resize.js"></script>
    <script type="text/javascript" src="navtreedata.js"></script>
    <script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="search/searchdata.js"></script>
    <script type="text/javascript" src="search/search.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NN5JX4B"
        height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
            <tbody>
                <tr id="projectrow">
                    <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
                    <td id="projectalign">
                        <div id="projectname">SkyWay Linux SDK
                        </div>
                    </td>
                </tr>
            </tbody>
        </table>
    </div><!-- 構築: Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'検索');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','検索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classboost_1_1intrusive_1_1rbtree__algorithms.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">公開型</a> &#124;
<a href="#pub-static-methods">静的公開メンバ関数</a> &#124;
<a href="classboost_1_1intrusive_1_1rbtree__algorithms-members.html">全メンバ一覧</a>  </div>
  <div class="headertitle">
<div class="title">boost::intrusive::rbtree_algorithms&lt; NodeTraits &gt; クラステンプレート</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="rbtree__algorithms_8hpp_source.html">rbtree_algorithms.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
公開型</h2></td></tr>
<tr class="memitem:ac41af04160d73bee6606370196ecef06"><td class="memItemLeft" align="right" valign="top"><a id="ac41af04160d73bee6606370196ecef06"></a>
typedef NodeTraits&#160;</td><td class="memItemRight" valign="bottom"><b>node_traits</b></td></tr>
<tr class="separator:ac41af04160d73bee6606370196ecef06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a705e22b78f7f53a6efb191db1c9ca"><td class="memItemLeft" align="right" valign="top"><a id="a34a705e22b78f7f53a6efb191db1c9ca"></a>
typedef NodeTraits::node&#160;</td><td class="memItemRight" valign="bottom"><b>node</b></td></tr>
<tr class="separator:a34a705e22b78f7f53a6efb191db1c9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00ee63b6381d20d6236e1b5afbe9751"><td class="memItemLeft" align="right" valign="top"><a id="ae00ee63b6381d20d6236e1b5afbe9751"></a>
typedef NodeTraits::node_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>node_ptr</b></td></tr>
<tr class="separator:ae00ee63b6381d20d6236e1b5afbe9751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb90f9e771c6cddb7d803d2a2e63692"><td class="memItemLeft" align="right" valign="top"><a id="a1cb90f9e771c6cddb7d803d2a2e63692"></a>
typedef NodeTraits::const_node_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>const_node_ptr</b></td></tr>
<tr class="separator:a1cb90f9e771c6cddb7d803d2a2e63692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748d7009806a38585a3c95c15a57f89f"><td class="memItemLeft" align="right" valign="top"><a id="a748d7009806a38585a3c95c15a57f89f"></a>
typedef NodeTraits::color&#160;</td><td class="memItemRight" valign="bottom"><b>color</b></td></tr>
<tr class="separator:a748d7009806a38585a3c95c15a57f89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfdad4e40067c4dfeebf6313c8e9fd1d"><td class="memItemLeft" align="right" valign="top">typedef bstree_algo::insert_commit_data&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html#acfdad4e40067c4dfeebf6313c8e9fd1d">insert_commit_data</a></td></tr>
<tr class="separator:acfdad4e40067c4dfeebf6313c8e9fd1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
静的公開メンバ関数</h2></td></tr>
<tr class="memitem:a6b153cb16536b7fc4a62a500970c4045"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html#a6b153cb16536b7fc4a62a500970c4045">swap_nodes</a> (node_ptr node1, node_ptr node2)</td></tr>
<tr class="separator:a6b153cb16536b7fc4a62a500970c4045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc4065be6e5dd4d345ae77c5692278c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html#aadc4065be6e5dd4d345ae77c5692278c">swap_nodes</a> (node_ptr node1, node_ptr header1, node_ptr node2, node_ptr header2)</td></tr>
<tr class="separator:aadc4065be6e5dd4d345ae77c5692278c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2225885bee193c7e618e1d99a8978c57"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html#a2225885bee193c7e618e1d99a8978c57">replace_node</a> (node_ptr node_to_be_replaced, node_ptr new_node)</td></tr>
<tr class="separator:a2225885bee193c7e618e1d99a8978c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539fea35724afa64bb9db172bd34d238"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html#a539fea35724afa64bb9db172bd34d238">replace_node</a> (node_ptr node_to_be_replaced, node_ptr header, node_ptr new_node)</td></tr>
<tr class="separator:a539fea35724afa64bb9db172bd34d238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888d53e84c86042ed6336b605ac0fa14"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html#a888d53e84c86042ed6336b605ac0fa14">unlink</a> (const node_ptr &amp;node)</td></tr>
<tr class="separator:a888d53e84c86042ed6336b605ac0fa14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2cdd5bc6958631229641da57a55d6df"><td class="memItemLeft" align="right" valign="top">static BOOST_INTRUSIVE_FORCEINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html#af2cdd5bc6958631229641da57a55d6df">init_header</a> (node_ptr header)</td></tr>
<tr class="separator:af2cdd5bc6958631229641da57a55d6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44655f4e73f675c8af56273b620d74ee"><td class="memItemLeft" align="right" valign="top">static node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html#a44655f4e73f675c8af56273b620d74ee">erase</a> (node_ptr header, node_ptr z)</td></tr>
<tr class="separator:a44655f4e73f675c8af56273b620d74ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f73fc5c6049c2b7bb24f44e5abc9a55"><td class="memTemplParams" colspan="2">template&lt;class NodePtrCompare &gt; </td></tr>
<tr class="memitem:a5f73fc5c6049c2b7bb24f44e5abc9a55"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html#a5f73fc5c6049c2b7bb24f44e5abc9a55">transfer_unique</a> (node_ptr header1, NodePtrCompare comp, node_ptr header2, node_ptr z)</td></tr>
<tr class="separator:a5f73fc5c6049c2b7bb24f44e5abc9a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8242f2ac6a85674029b6978081134eb8"><td class="memTemplParams" colspan="2">template&lt;class NodePtrCompare &gt; </td></tr>
<tr class="memitem:a8242f2ac6a85674029b6978081134eb8"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html#a8242f2ac6a85674029b6978081134eb8">transfer_equal</a> (node_ptr header1, NodePtrCompare comp, node_ptr header2, node_ptr z)</td></tr>
<tr class="separator:a8242f2ac6a85674029b6978081134eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4a40d50fd039846d3cff730c7b31e3"><td class="memTemplParams" colspan="2">template&lt;class Cloner , class Disposer &gt; </td></tr>
<tr class="memitem:aed4a40d50fd039846d3cff730c7b31e3"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html#aed4a40d50fd039846d3cff730c7b31e3">clone</a> (const_node_ptr source_header, node_ptr target_header, Cloner cloner, Disposer disposer)</td></tr>
<tr class="separator:aed4a40d50fd039846d3cff730c7b31e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f9fdd3ef3251f91406480d8c05e362"><td class="memTemplParams" colspan="2">template&lt;class NodePtrCompare &gt; </td></tr>
<tr class="memitem:a87f9fdd3ef3251f91406480d8c05e362"><td class="memTemplItemLeft" align="right" valign="top">static node_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html#a87f9fdd3ef3251f91406480d8c05e362">insert_equal_upper_bound</a> (node_ptr h, node_ptr new_node, NodePtrCompare comp)</td></tr>
<tr class="separator:a87f9fdd3ef3251f91406480d8c05e362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd0636d972273023d738c743adb83d1"><td class="memTemplParams" colspan="2">template&lt;class NodePtrCompare &gt; </td></tr>
<tr class="memitem:a4bd0636d972273023d738c743adb83d1"><td class="memTemplItemLeft" align="right" valign="top">static node_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html#a4bd0636d972273023d738c743adb83d1">insert_equal_lower_bound</a> (node_ptr h, node_ptr new_node, NodePtrCompare comp)</td></tr>
<tr class="separator:a4bd0636d972273023d738c743adb83d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa844cced7490a43ba2a8460ef86198c2"><td class="memTemplParams" colspan="2">template&lt;class NodePtrCompare &gt; </td></tr>
<tr class="memitem:aa844cced7490a43ba2a8460ef86198c2"><td class="memTemplItemLeft" align="right" valign="top">static node_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html#aa844cced7490a43ba2a8460ef86198c2">insert_equal</a> (node_ptr header, node_ptr hint, node_ptr new_node, NodePtrCompare comp)</td></tr>
<tr class="separator:aa844cced7490a43ba2a8460ef86198c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660b4c163a14e8fb46d8293d5b55837e"><td class="memItemLeft" align="right" valign="top">static node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html#a660b4c163a14e8fb46d8293d5b55837e">insert_before</a> (node_ptr header, node_ptr pos, node_ptr new_node)</td></tr>
<tr class="separator:a660b4c163a14e8fb46d8293d5b55837e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac169e5b40067c9767c6db82caa7f87b9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html#ac169e5b40067c9767c6db82caa7f87b9">push_back</a> (node_ptr header, node_ptr new_node)</td></tr>
<tr class="separator:ac169e5b40067c9767c6db82caa7f87b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af927268a9024a75989757be7d69f2708"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html#af927268a9024a75989757be7d69f2708">push_front</a> (node_ptr header, node_ptr new_node)</td></tr>
<tr class="separator:af927268a9024a75989757be7d69f2708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3a8679a8c3e8e652e88cef30f88ff7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html#a6b3a8679a8c3e8e652e88cef30f88ff7">insert_unique_commit</a> (node_ptr header, node_ptr new_value, const <a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html#acfdad4e40067c4dfeebf6313c8e9fd1d">insert_commit_data</a> &amp;commit_data)</td></tr>
<tr class="separator:a6b3a8679a8c3e8e652e88cef30f88ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc30b41e39a191f3ca86c0937e5b87c6"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html#abc30b41e39a191f3ca86c0937e5b87c6">is_header</a> (const const_node_ptr &amp;p)</td></tr>
<tr class="separator:abc30b41e39a191f3ca86c0937e5b87c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">詳解</h2>
<div class="textblock"><h3>template&lt;class NodeTraits&gt;<br />
class boost::intrusive::rbtree_algorithms&lt; NodeTraits &gt;</h3>

<p><a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html">rbtree_algorithms</a> provides basic algorithms to manipulate nodes forming a red-black tree. The insertion and deletion algorithms are based on those in Cormen, Leiserson, and Rivest, Introduction to Algorithms (MIT Press, 1990), except that</p>
<p>(1) the header node is maintained with links not only to the root but also to the leftmost node of the tree, to enable constant time begin(), and to the rightmost node of the tree, to enable linear time performance when used with the generic set algorithms (set_union, etc.);</p>
<p>(2) when a node being deleted has two children its successor node is relinked into its place, rather than copied, so that the only pointers invalidated are those referring to the deleted node.</p>
<p><a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html">rbtree_algorithms</a> is configured with a NodeTraits class, which encapsulates the information about the node to be manipulated. NodeTraits must support the following interface:</p>
<p><b>Typedefs</b>:</p>
<p><code>node</code>: The type of the node that forms the binary search tree</p>
<p><code>node_ptr</code>: A pointer to a node</p>
<p><code>const_node_ptr</code>: A pointer to a const node</p>
<p><code>color</code>: The type that can store the color of a node</p>
<p><b>Static functions</b>:</p>
<p><code>static node_ptr get_parent(const_node_ptr n);</code></p>
<p><code>static void set_parent(node_ptr n, node_ptr parent);</code></p>
<p><code>static node_ptr get_left(const_node_ptr n);</code></p>
<p><code>static void set_left(node_ptr n, node_ptr left);</code></p>
<p><code>static node_ptr get_right(const_node_ptr n);</code></p>
<p><code>static void set_right(node_ptr n, node_ptr right);</code></p>
<p><code>static color get_color(const_node_ptr n);</code></p>
<p><code>static void set_color(node_ptr n, color c);</code></p>
<p><code>static color black();</code></p>
<p><code>static color red();</code> </p>
</div><h2 class="groupheader">型定義メンバ詳解</h2>
<a id="acfdad4e40067c4dfeebf6313c8e9fd1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfdad4e40067c4dfeebf6313c8e9fd1d">&#9670;&nbsp;</a></span>insert_commit_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef bstree_algo::insert_commit_data <a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html">boost::intrusive::rbtree_algorithms</a>&lt; NodeTraits &gt;::<a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html#acfdad4e40067c4dfeebf6313c8e9fd1d">insert_commit_data</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type is the information that will be filled by insert_unique_check </p>

</div>
</div>
<h2 class="groupheader">関数詳解</h2>
<a id="aed4a40d50fd039846d3cff730c7b31e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed4a40d50fd039846d3cff730c7b31e3">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<div class="memtemplate">
template&lt;class Cloner , class Disposer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html">boost::intrusive::rbtree_algorithms</a>&lt; NodeTraits &gt;::clone </td>
          <td>(</td>
          <td class="paramtype">const_node_ptr&#160;</td>
          <td class="paramname"><em>source_header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>target_header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cloner&#160;</td>
          <td class="paramname"><em>cloner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Disposer&#160;</td>
          <td class="paramname"><em>disposer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p><b>Requires</b>: "cloner" must be a function object taking a node_ptr and returning a new cloned node of it. "disposer" must take a node_ptr and shouldn't throw.</p>
<p><b>Effects</b>: First empties target tree calling <code>void disposer::operator()(const node_ptr &amp;)</code> for every node of the tree except the header.</p>
<p>Then, duplicates the entire tree pointed by "source_header" cloning each source node with <code>node_ptr Cloner::operator()(const node_ptr &amp;)</code> to obtain the nodes of the target tree. If "cloner" throws, the cloned target nodes are disposed using <code>void disposer(const node_ptr &amp;)</code>.</p>
<p><b>Complexity</b>: Linear to the number of element of the source tree plus the number of elements of tree target tree when calling this function.</p>
<p><b>Throws</b>: If cloner functor throws. If this happens target nodes are disposed. </p>

</div>
</div>
<a id="a44655f4e73f675c8af56273b620d74ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44655f4e73f675c8af56273b620d74ee">&#9670;&nbsp;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static node_ptr <a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html">boost::intrusive::rbtree_algorithms</a>&lt; NodeTraits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p><b>Requires</b>: header must be the header of a tree, z a node of that tree and z != header.</p>
<p><b>Effects</b>: Erases node "z" from the tree with header "header".</p>
<p><b>Complexity</b>: Amortized constant time.</p>
<p><b>Throws</b>: Nothing. </p>

</div>
</div>
<a id="af2cdd5bc6958631229641da57a55d6df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2cdd5bc6958631229641da57a55d6df">&#9670;&nbsp;</a></span>init_header()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BOOST_INTRUSIVE_FORCEINLINE void <a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html">boost::intrusive::rbtree_algorithms</a>&lt; NodeTraits &gt;::init_header </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>header</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p><b>Requires</b>: node must not be part of any tree.</p>
<p><b>Effects</b>: Initializes the header to represent an empty tree. unique(header) == true.</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Nodes</b>: If node is inserted in a tree, this function corrupts the tree. </p>

</div>
</div>
<a id="a660b4c163a14e8fb46d8293d5b55837e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a660b4c163a14e8fb46d8293d5b55837e">&#9670;&nbsp;</a></span>insert_before()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static node_ptr <a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html">boost::intrusive::rbtree_algorithms</a>&lt; NodeTraits &gt;::insert_before </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>new_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="aa844cced7490a43ba2a8460ef86198c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa844cced7490a43ba2a8460ef86198c2">&#9670;&nbsp;</a></span>insert_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<div class="memtemplate">
template&lt;class NodePtrCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static node_ptr <a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html">boost::intrusive::rbtree_algorithms</a>&lt; NodeTraits &gt;::insert_equal </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>new_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodePtrCompare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="a4bd0636d972273023d738c743adb83d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd0636d972273023d738c743adb83d1">&#9670;&nbsp;</a></span>insert_equal_lower_bound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<div class="memtemplate">
template&lt;class NodePtrCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static node_ptr <a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html">boost::intrusive::rbtree_algorithms</a>&lt; NodeTraits &gt;::insert_equal_lower_bound </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>new_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodePtrCompare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="a87f9fdd3ef3251f91406480d8c05e362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f9fdd3ef3251f91406480d8c05e362">&#9670;&nbsp;</a></span>insert_equal_upper_bound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<div class="memtemplate">
template&lt;class NodePtrCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static node_ptr <a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html">boost::intrusive::rbtree_algorithms</a>&lt; NodeTraits &gt;::insert_equal_upper_bound </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>new_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodePtrCompare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="a6b3a8679a8c3e8e652e88cef30f88ff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b3a8679a8c3e8e652e88cef30f88ff7">&#9670;&nbsp;</a></span>insert_unique_commit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html">boost::intrusive::rbtree_algorithms</a>&lt; NodeTraits &gt;::insert_unique_commit </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>new_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html#acfdad4e40067c4dfeebf6313c8e9fd1d">insert_commit_data</a> &amp;&#160;</td>
          <td class="paramname"><em>commit_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p><b>Requires</b>: "header" must be the header node of a tree. "commit_data" must have been obtained from a previous call to "insert_unique_check". No objects should have been inserted or erased from the set between the "insert_unique_check" that filled "commit_data" and the call to "insert_commit".</p>
<p><b>Effects</b>: Inserts new_node in the set using the information obtained from the "commit_data" that a previous "insert_check" filled.</p>
<p><b>Complexity</b>: Constant time.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Notes</b>: This function has only sense if a "insert_unique_check" has been previously executed to fill "commit_data". No value should be inserted or erased between the "insert_check" and "insert_commit" calls. </p>

</div>
</div>
<a id="abc30b41e39a191f3ca86c0937e5b87c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc30b41e39a191f3ca86c0937e5b87c6">&#9670;&nbsp;</a></span>is_header()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html">boost::intrusive::rbtree_algorithms</a>&lt; NodeTraits &gt;::is_header </td>
          <td>(</td>
          <td class="paramtype">const const_node_ptr &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p><b>Requires</b>: p is a node of a tree.</p>
<p><b>Effects</b>: Returns true if p is the header of the tree.</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Throws</b>: Nothing. </p>

</div>
</div>
<a id="ac169e5b40067c9767c6db82caa7f87b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac169e5b40067c9767c6db82caa7f87b9">&#9670;&nbsp;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html">boost::intrusive::rbtree_algorithms</a>&lt; NodeTraits &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>new_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="af927268a9024a75989757be7d69f2708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af927268a9024a75989757be7d69f2708">&#9670;&nbsp;</a></span>push_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html">boost::intrusive::rbtree_algorithms</a>&lt; NodeTraits &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>new_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="a539fea35724afa64bb9db172bd34d238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a539fea35724afa64bb9db172bd34d238">&#9670;&nbsp;</a></span>replace_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html">boost::intrusive::rbtree_algorithms</a>&lt; NodeTraits &gt;::replace_node </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>node_to_be_replaced</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>new_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p><b>Requires</b>: node_to_be_replaced must be inserted in a tree with header "header" and new_node must not be inserted in a tree.</p>
<p><b>Effects</b>: Replaces node_to_be_replaced in its position in the tree with new_node. The tree does not need to be rebalanced</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Note</b>: This function will break container ordering invariants if new_node is not equivalent to node_to_be_replaced according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed. Experimental function </p>

</div>
</div>
<a id="a2225885bee193c7e618e1d99a8978c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2225885bee193c7e618e1d99a8978c57">&#9670;&nbsp;</a></span>replace_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html">boost::intrusive::rbtree_algorithms</a>&lt; NodeTraits &gt;::replace_node </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>node_to_be_replaced</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>new_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p><b>Requires</b>: node_to_be_replaced must be inserted in a tree and new_node must not be inserted in a tree.</p>
<p><b>Effects</b>: Replaces node_to_be_replaced in its position in the tree with new_node. The tree does not need to be rebalanced</p>
<p><b>Complexity</b>: Logarithmic.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Note</b>: This function will break container ordering invariants if new_node is not equivalent to node_to_be_replaced according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing and comparison is needed. Experimental function </p>

</div>
</div>
<a id="aadc4065be6e5dd4d345ae77c5692278c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadc4065be6e5dd4d345ae77c5692278c">&#9670;&nbsp;</a></span>swap_nodes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html">boost::intrusive::rbtree_algorithms</a>&lt; NodeTraits &gt;::swap_nodes </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>header1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>node2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>header2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p><b>Requires</b>: node1 and node2 can't be header nodes of two trees with header header1 and header2.</p>
<p><b>Effects</b>: Swaps two nodes. After the function node1 will be inserted in the position node2 before the function. node2 will be inserted in the position node1 had before the function.</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Note</b>: This function will break container ordering invariants if node1 and node2 are not equivalent according to the ordering rules.</p>
<p>Experimental function </p>

</div>
</div>
<a id="a6b153cb16536b7fc4a62a500970c4045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b153cb16536b7fc4a62a500970c4045">&#9670;&nbsp;</a></span>swap_nodes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html">boost::intrusive::rbtree_algorithms</a>&lt; NodeTraits &gt;::swap_nodes </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>node2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p><b>Requires</b>: node1 and node2 can't be header nodes of two trees.</p>
<p><b>Effects</b>: Swaps two nodes. After the function node1 will be inserted in the position node2 before the function. node2 will be inserted in the position node1 had before the function.</p>
<p><b>Complexity</b>: Logarithmic.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Note</b>: This function will break container ordering invariants if node1 and node2 are not equivalent according to the ordering rules.</p>
<p>Experimental function </p>

</div>
</div>
<a id="a8242f2ac6a85674029b6978081134eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8242f2ac6a85674029b6978081134eb8">&#9670;&nbsp;</a></span>transfer_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<div class="memtemplate">
template&lt;class NodePtrCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html">boost::intrusive::rbtree_algorithms</a>&lt; NodeTraits &gt;::transfer_equal </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>header1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodePtrCompare&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>header2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p><b>Requires</b>: header1 and header2 must be the headers of trees tree1 and tree2 respectively, z a non-header node of tree1. NodePtrCompare is the comparison function of tree1..</p>
<p><b>Effects</b>: Transfers node "z" from tree1 to tree2.</p>
<p><b>Complexity</b>: Logarithmic.</p>
<p><b>Throws</b>: If the comparison throws. </p>

</div>
</div>
<a id="a5f73fc5c6049c2b7bb24f44e5abc9a55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f73fc5c6049c2b7bb24f44e5abc9a55">&#9670;&nbsp;</a></span>transfer_unique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<div class="memtemplate">
template&lt;class NodePtrCompare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html">boost::intrusive::rbtree_algorithms</a>&lt; NodeTraits &gt;::transfer_unique </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>header1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodePtrCompare&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>header2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p><b>Requires</b>: header1 and header2 must be the headers of trees tree1 and tree2 respectively, z a non-header node of tree1. NodePtrCompare is the comparison function of tree1..</p>
<p><b>Effects</b>: Transfers node "z" from tree1 to tree2 if tree1 does not contain a node that is equivalent to z.</p>
<p><b>Returns</b>: True if the node was trasferred, false otherwise.</p>
<p><b>Complexity</b>: Logarithmic.</p>
<p><b>Throws</b>: If the comparison throws. </p>

</div>
</div>
<a id="a888d53e84c86042ed6336b605ac0fa14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a888d53e84c86042ed6336b605ac0fa14">&#9670;&nbsp;</a></span>unlink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html">boost::intrusive::rbtree_algorithms</a>&lt; NodeTraits &gt;::unlink </td>
          <td>(</td>
          <td class="paramtype">const node_ptr &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p><b>Requires</b>: node is a tree node but not the header.</p>
<p><b>Effects</b>: Unlinks the node and rebalances the tree.</p>
<p><b>Complexity</b>: Average complexity is constant time.</p>
<p><b>Throws</b>: Nothing. </p>

</div>
</div>
<hr/>このクラス詳解は次のファイルから抽出されました:<ul>
<li>include/external/boost/boost/intrusive/<a class="el" href="intrusive__fwd_8hpp_source.html">intrusive_fwd.hpp</a></li>
<li>include/external/boost/boost/intrusive/<a class="el" href="rbtree__algorithms_8hpp_source.html">rbtree_algorithms.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceboost.html">boost</a></li><li class="navelem"><b>intrusive</b></li><li class="navelem"><a class="el" href="classboost_1_1intrusive_1_1rbtree__algorithms.html">rbtree_algorithms</a></li>
    <li class="footer">構築:
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
