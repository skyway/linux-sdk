<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
<head>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
        'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
        })(window,document,'script','dataLayer','GTM-NN5JX4B');</script>
    <!-- End Google Tag Manager -->
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=11"/>
    <meta name="generator" content="Doxygen 1.9.8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>SkyWay Linux SDK</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="resize.js"></script>
    <script type="text/javascript" src="navtreedata.js"></script>
    <script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="search/searchdata.js"></script>
    <script type="text/javascript" src="search/search.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NN5JX4B"
        height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
            <tbody>
                <tr id="projectrow">
                    <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
                    <td id="projectalign">
                        <div id="projectname">SkyWay Linux SDK
                        </div>
                    </td>
                </tr>
            </tbody>
        </table>
    </div><!-- 構築: Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'検索');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','検索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classboost_1_1beast_1_1http_1_1serializer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">公開型</a> &#124;
<a href="#pub-methods">公開メンバ関数</a> &#124;
<a href="classboost_1_1beast_1_1http_1_1serializer-members.html">全メンバ一覧</a>  </div>
  <div class="headertitle">
<div class="title">boost::beast::http::serializer&lt; isRequest, Body, Fields &gt; クラステンプレート</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="serializer_8hpp_source.html">serializer.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
公開型</h2></td></tr>
<tr class="memitem:aa58b595f115e4658c10e5de0c5be7b7f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html#aa58b595f115e4658c10e5de0c5be7b7f">value_type</a> = typename std::conditional&lt; std::is_constructible&lt; typename Body::writer, <a class="el" href="classboost_1_1beast_1_1http_1_1header.html">header</a>&lt; isRequest, Fields &gt; &amp;, typename Body::value_type &amp; &gt;::value &amp;&amp;! std::is_constructible&lt; typename Body::writer, <a class="el" href="classboost_1_1beast_1_1http_1_1header.html">header</a>&lt; isRequest, Fields &gt; const  &amp;, typename Body::value_type const  &amp; &gt;::value, <a class="el" href="classboost_1_1beast_1_1http_1_1message.html">message</a>&lt; isRequest, Body, Fields &gt;, <a class="el" href="classboost_1_1beast_1_1http_1_1message.html">message</a>&lt; isRequest, Body, Fields &gt; const  &gt;::<a class="el" href="structboost_1_1type.html">type</a></td></tr>
<tr class="separator:aa58b595f115e4658c10e5de0c5be7b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
公開メンバ関数</h2></td></tr>
<tr class="memitem:a31d05136735c6173402bf5dfa332524a"><td class="memItemLeft" align="right" valign="top"><a id="a31d05136735c6173402bf5dfa332524a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html#a31d05136735c6173402bf5dfa332524a">serializer</a> (<a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html">serializer</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:a31d05136735c6173402bf5dfa332524a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor <br /></td></tr>
<tr class="separator:a31d05136735c6173402bf5dfa332524a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0958eb7b068f32498d92412e672d2fe"><td class="memItemLeft" align="right" valign="top"><a id="ab0958eb7b068f32498d92412e672d2fe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html#ab0958eb7b068f32498d92412e672d2fe">serializer</a> (<a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html">serializer</a> const &amp;)=default</td></tr>
<tr class="memdesc:ab0958eb7b068f32498d92412e672d2fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor <br /></td></tr>
<tr class="separator:ab0958eb7b068f32498d92412e672d2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40483fde9c70a9baac5688ce663e2556"><td class="memItemLeft" align="right" valign="top"><a id="a40483fde9c70a9baac5688ce663e2556"></a>
<a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html">serializer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html#a40483fde9c70a9baac5688ce663e2556">operator=</a> (<a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html">serializer</a> const &amp;)=delete</td></tr>
<tr class="memdesc:a40483fde9c70a9baac5688ce663e2556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment <br /></td></tr>
<tr class="separator:a40483fde9c70a9baac5688ce663e2556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4110a812ffac9ad3421e354ea26c8f46"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html#a4110a812ffac9ad3421e354ea26c8f46">serializer</a> (<a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html#aa58b595f115e4658c10e5de0c5be7b7f">value_type</a> &amp;msg)</td></tr>
<tr class="separator:a4110a812ffac9ad3421e354ea26c8f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5c7a2746f63c7c0726ebee6a76d97a"><td class="memItemLeft" align="right" valign="top"><a id="a4c5c7a2746f63c7c0726ebee6a76d97a"></a>
<a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html#aa58b595f115e4658c10e5de0c5be7b7f">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html#a4c5c7a2746f63c7c0726ebee6a76d97a">get</a> ()</td></tr>
<tr class="memdesc:a4c5c7a2746f63c7c0726ebee6a76d97a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the message being serialized <br /></td></tr>
<tr class="separator:a4c5c7a2746f63c7c0726ebee6a76d97a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d91f04c7d8ba9b0a5b1cf3a633024ee"><td class="memItemLeft" align="right" valign="top"><a id="a4d91f04c7d8ba9b0a5b1cf3a633024ee"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html#a4d91f04c7d8ba9b0a5b1cf3a633024ee">limit</a> ()</td></tr>
<tr class="memdesc:a4d91f04c7d8ba9b0a5b1cf3a633024ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the serialized buffer size limit <br /></td></tr>
<tr class="separator:a4d91f04c7d8ba9b0a5b1cf3a633024ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abada7e40ccca14ce0d187d345c5c1858"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html#abada7e40ccca14ce0d187d345c5c1858">limit</a> (std::size_t limit)</td></tr>
<tr class="separator:abada7e40ccca14ce0d187d345c5c1858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345e6cafe5e835f485e4e3785992b795"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html#a345e6cafe5e835f485e4e3785992b795">split</a> ()</td></tr>
<tr class="separator:a345e6cafe5e835f485e4e3785992b795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b38fdffa42aadb9459861c49bc0e391"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html#a7b38fdffa42aadb9459861c49bc0e391">split</a> (bool v)</td></tr>
<tr class="separator:a7b38fdffa42aadb9459861c49bc0e391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20a1de56e46f085844c27a4ba940763"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html#ab20a1de56e46f085844c27a4ba940763">is_header_done</a> ()</td></tr>
<tr class="separator:ab20a1de56e46f085844c27a4ba940763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ee250c17690106cef78c278b95a647"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html#a61ee250c17690106cef78c278b95a647">is_done</a> ()</td></tr>
<tr class="separator:a61ee250c17690106cef78c278b95a647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ff031177c169f05df6c1f3d07e79f4"><td class="memTemplParams" colspan="2">template&lt;class Visit &gt; </td></tr>
<tr class="memitem:a11ff031177c169f05df6c1f3d07e79f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html#a11ff031177c169f05df6c1f3d07e79f4">next</a> (<a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;ec, Visit &amp;&amp;visit)</td></tr>
<tr class="separator:a11ff031177c169f05df6c1f3d07e79f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b3b59938e012458cec3d3764d90bb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html#ab0b3b59938e012458cec3d3764d90bb9">consume</a> (std::size_t n)</td></tr>
<tr class="separator:ab0b3b59938e012458cec3d3764d90bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac155fb6f0897c9e178edfbee997b54cd"><td class="memItemLeft" align="right" valign="top">writer &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html#ac155fb6f0897c9e178edfbee997b54cd">writer_impl</a> ()</td></tr>
<tr class="separator:ac155fb6f0897c9e178edfbee997b54cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">詳解</h2>
<div class="textblock"><h3>template&lt;bool isRequest, class Body, class Fields = fields&gt;<br />
class boost::beast::http::serializer&lt; isRequest, Body, Fields &gt;</h3>

<p>Provides buffer oriented HTTP message serialization functionality.</p>
<p>An object of this type is used to serialize a complete HTTP message into a sequence of octets. To use this class, construct an instance with the message to be serialized. The implementation will automatically perform chunk encoding if the contents of the message indicate that chunk encoding is required.</p>
<p>Chunked output produced by the serializer never contains chunk extensions or trailers, and the location of chunk boundaries is not specified. If callers require chunk extensions, trailers, or control over the exact contents of each chunk they should use the serializer to write just the message header, and then assume control over serializing the chunked payload by using the chunk buffer sequence types <a class="el" href="classboost_1_1beast_1_1http_1_1chunk__body.html">chunk_body</a>, <a class="el" href="structboost_1_1beast_1_1http_1_1chunk__crlf.html">chunk_crlf</a>, <a class="el" href="classboost_1_1beast_1_1http_1_1chunk__header.html">chunk_header</a>, and <a class="el" href="classboost_1_1beast_1_1http_1_1chunk__last.html">chunk_last</a>.</p>
<dl class="tparams"><dt>テンプレート引数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">isRequest</td><td><code>true</code> if the message is a request.</td></tr>
    <tr><td class="paramname">Body</td><td>The body type of the message.</td></tr>
    <tr><td class="paramname">Fields</td><td>The type of fields in the message. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">型定義メンバ詳解</h2>
<a id="aa58b595f115e4658c10e5de0c5be7b7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa58b595f115e4658c10e5de0c5be7b7f">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest, class Body , class Fields  = fields&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html">boost::beast::http::serializer</a>&lt; isRequest, Body, Fields &gt;::<a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html#aa58b595f115e4658c10e5de0c5be7b7f">value_type</a> =  typename std::conditional&lt; std::is_constructible&lt;typename Body::writer, <a class="el" href="classboost_1_1beast_1_1http_1_1header.html">header</a>&lt;isRequest, Fields&gt;&amp;, typename Body::value_type&amp;&gt;::value &amp;&amp; ! std::is_constructible&lt;typename Body::writer, <a class="el" href="classboost_1_1beast_1_1http_1_1header.html">header</a>&lt;isRequest, Fields&gt; const&amp;, typename Body::value_type const&amp;&gt;::value, <a class="el" href="classboost_1_1beast_1_1http_1_1message.html">message</a>&lt;isRequest, Body, Fields&gt;, <a class="el" href="classboost_1_1beast_1_1http_1_1message.html">message</a>&lt;isRequest, Body, Fields&gt; const&gt;::<a class="el" href="structboost_1_1type.html">type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of message this serializer uses</p>
<p>This may be const or non-const depending on the implementation of the corresponding <em>BodyWriter</em>. </p>

</div>
</div>
<h2 class="groupheader">構築子と解体子</h2>
<a id="a4110a812ffac9ad3421e354ea26c8f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4110a812ffac9ad3421e354ea26c8f46">&#9670;&nbsp;</a></span>serializer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest, class Body , class Fields &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html">boost::beast::http::serializer</a>&lt; isRequest, Body, Fields &gt;::<a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html">serializer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html#aa58b595f115e4658c10e5de0c5be7b7f">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor</p>
<p>The implementation guarantees that the message passed on construction will not be accessed until the first call to <a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html#a11ff031177c169f05df6c1f3d07e79f4">next</a>. This allows the message to be lazily created. For example, if the header is filled in before serialization.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>A reference to the message to serialize, which must remain valid for the lifetime of the serializer. Depending on the type of Body used, this may or may not be a <code>const</code> reference.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>覚え書き</dt><dd>This function participates in overload resolution only if Body::writer is constructible from a <code>const</code> message reference. </dd></dl>

</div>
</div>
<h2 class="groupheader">関数詳解</h2>
<a id="ab0b3b59938e012458cec3d3764d90bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b3b59938e012458cec3d3764d90bb9">&#9670;&nbsp;</a></span>consume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest, class Body , class Fields &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html">boost::beast::http::serializer</a>&lt; isRequest, Body, Fields &gt;::consume </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Consume buffer octets in the serialization.</p>
<p>This function should be called after one or more octets contained in the buffers provided in the prior call to <a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html#a11ff031177c169f05df6c1f3d07e79f4">next</a> have been used.</p>
<p>After a call to <a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html#ab0b3b59938e012458cec3d3764d90bb9">consume</a>, callers should check the return value of <a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html#a61ee250c17690106cef78c278b95a647">is_done</a> to determine if the entire message has been serialized.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of octets to consume. This number must be greater than zero and no greater than the number of octets in the buffers provided in the prior call to <a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html#a11ff031177c169f05df6c1f3d07e79f4">next</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61ee250c17690106cef78c278b95a647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61ee250c17690106cef78c278b95a647">&#9670;&nbsp;</a></span>is_done()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest, class Body , class Fields  = fields&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html">boost::beast::http::serializer</a>&lt; isRequest, Body, Fields &gt;::is_done </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return <code>true</code> if serialization is complete.</p>
<p>The operation is complete when all octets corresponding to the serialized representation of the message have been successfully retrieved. </p>

</div>
</div>
<a id="ab20a1de56e46f085844c27a4ba940763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20a1de56e46f085844c27a4ba940763">&#9670;&nbsp;</a></span>is_header_done()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest, class Body , class Fields  = fields&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html">boost::beast::http::serializer</a>&lt; isRequest, Body, Fields &gt;::is_header_done </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return <code>true</code> if serialization of the header is complete.</p>
<p>This function indicates whether or not all buffers containing serialized header octets have been retrieved. </p>

</div>
</div>
<a id="abada7e40ccca14ce0d187d345c5c1858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abada7e40ccca14ce0d187d345c5c1858">&#9670;&nbsp;</a></span>limit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest, class Body , class Fields  = fields&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html">boost::beast::http::serializer</a>&lt; isRequest, Body, Fields &gt;::limit </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>limit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the serialized buffer size limit</p>
<p>This function adjusts the limit on the maximum size of the buffers passed to the visitor. The new size limit takes effect in the following call to <a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html#a11ff031177c169f05df6c1f3d07e79f4">next</a>.</p>
<p>The default is no buffer size limit.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">limit</td><td>The new buffer size limit. If this number is zero, the size limit is removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11ff031177c169f05df6c1f3d07e79f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ff031177c169f05df6c1f3d07e79f4">&#9670;&nbsp;</a></span>next()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest, class Body , class Fields &gt; </div>
<div class="memtemplate">
template&lt;class Visit &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html">boost::beast::http::serializer</a>&lt; isRequest, Body, Fields &gt;::next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1system_1_1error__code.html">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Visit &amp;&amp;&#160;</td>
          <td class="paramname"><em>visit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the next set of buffers in the serialization.</p>
<p>This function will attempt to call the <code>visit</code> function object with a <em>ConstBufferSequence</em> of unspecified type representing the next set of buffers in the serialization of the message represented by this object.</p>
<p>If there are no more buffers in the serialization, the visit function will not be called. In this case, no error will be indicated, and the function <a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html#a61ee250c17690106cef78c278b95a647">is_done</a> will return <code>true</code>.</p>
<dl class="params"><dt>引数</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to the error, if any occurred.</td></tr>
    <tr><td class="paramname">visit</td><td>The function to call. The equivalent function signature of this object must be: <div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ConstBufferSequence&gt;</div>
<div class="line"><span class="keywordtype">void</span> visit(error_code&amp;, ConstBufferSequence <span class="keyword">const</span>&amp;);</div>
</div><!-- fragment --> The function is not copied, if no error occurs it will be invoked before the call to <a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html#a11ff031177c169f05df6c1f3d07e79f4">next</a> returns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a345e6cafe5e835f485e4e3785992b795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a345e6cafe5e835f485e4e3785992b795">&#9670;&nbsp;</a></span>split() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest, class Body , class Fields  = fields&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html">boost::beast::http::serializer</a>&lt; isRequest, Body, Fields &gt;::split </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>true</code> if we will pause after writing the complete header. </p>

</div>
</div>
<a id="a7b38fdffa42aadb9459861c49bc0e391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b38fdffa42aadb9459861c49bc0e391">&#9670;&nbsp;</a></span>split() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest, class Body , class Fields  = fields&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html">boost::beast::http::serializer</a>&lt; isRequest, Body, Fields &gt;::split </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set whether the header and body are written separately.</p>
<p>When the split feature is enabled, the implementation will write only the octets corresponding to the serialized header first. If the header has already been written, this function will have no effect on output. </p>

</div>
</div>
<a id="ac155fb6f0897c9e178edfbee997b54cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac155fb6f0897c9e178edfbee997b54cd">&#9670;&nbsp;</a></span>writer_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest, class Body , class Fields  = fields&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">writer&amp; <a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html">boost::beast::http::serializer</a>&lt; isRequest, Body, Fields &gt;::writer_impl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Provides low-level access to the associated <em>BodyWriter</em></p>
<p>This function provides access to the instance of the writer associated with the body and created by the serializer upon construction. The behavior of accessing this object is defined by the specification of the particular writer and its associated body.</p>
<dl class="section return"><dt>戻り値</dt><dd>A reference to the writer. </dd></dl>

</div>
</div>
<hr/>このクラス詳解は次のファイルから抽出されました:<ul>
<li>include/external/boost/boost/beast/http/<a class="el" href="serializer_8hpp_source.html">serializer.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceboost.html">boost</a></li><li class="navelem"><b>beast</b></li><li class="navelem"><b>http</b></li><li class="navelem"><a class="el" href="classboost_1_1beast_1_1http_1_1serializer.html">serializer</a></li>
    <li class="footer">構築:
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
